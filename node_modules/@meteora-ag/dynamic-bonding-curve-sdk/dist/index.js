// src/services/pool.ts
import {
  PublicKey as PublicKey9,
  Transaction as Transaction2,
  SYSVAR_INSTRUCTIONS_PUBKEY
} from "@solana/web3.js";

// src/types.ts
var ActivationType = /* @__PURE__ */ ((ActivationType2) => {
  ActivationType2[ActivationType2["Slot"] = 0] = "Slot";
  ActivationType2[ActivationType2["Timestamp"] = 1] = "Timestamp";
  return ActivationType2;
})(ActivationType || {});
var TokenType = /* @__PURE__ */ ((TokenType2) => {
  TokenType2[TokenType2["SPL"] = 0] = "SPL";
  TokenType2[TokenType2["Token2022"] = 1] = "Token2022";
  return TokenType2;
})(TokenType || {});
var CollectFeeMode = /* @__PURE__ */ ((CollectFeeMode2) => {
  CollectFeeMode2[CollectFeeMode2["OnlyQuote"] = 0] = "OnlyQuote";
  CollectFeeMode2[CollectFeeMode2["Both"] = 1] = "Both";
  return CollectFeeMode2;
})(CollectFeeMode || {});
var MigrationOption = /* @__PURE__ */ ((MigrationOption2) => {
  MigrationOption2[MigrationOption2["MET_DAMM"] = 0] = "MET_DAMM";
  MigrationOption2[MigrationOption2["MET_DAMM_V2"] = 1] = "MET_DAMM_V2";
  return MigrationOption2;
})(MigrationOption || {});
var GetFeeMode = /* @__PURE__ */ ((GetFeeMode2) => {
  GetFeeMode2[GetFeeMode2["QuoteToken"] = 0] = "QuoteToken";
  GetFeeMode2[GetFeeMode2["OutputToken"] = 1] = "OutputToken";
  return GetFeeMode2;
})(GetFeeMode || {});
var BaseFeeMode = /* @__PURE__ */ ((BaseFeeMode2) => {
  BaseFeeMode2[BaseFeeMode2["FeeSchedulerLinear"] = 0] = "FeeSchedulerLinear";
  BaseFeeMode2[BaseFeeMode2["FeeSchedulerExponential"] = 1] = "FeeSchedulerExponential";
  BaseFeeMode2[BaseFeeMode2["RateLimiter"] = 2] = "RateLimiter";
  return BaseFeeMode2;
})(BaseFeeMode || {});
var MigrationFeeOption = /* @__PURE__ */ ((MigrationFeeOption2) => {
  MigrationFeeOption2[MigrationFeeOption2["FixedBps25"] = 0] = "FixedBps25";
  MigrationFeeOption2[MigrationFeeOption2["FixedBps30"] = 1] = "FixedBps30";
  MigrationFeeOption2[MigrationFeeOption2["FixedBps100"] = 2] = "FixedBps100";
  MigrationFeeOption2[MigrationFeeOption2["FixedBps200"] = 3] = "FixedBps200";
  MigrationFeeOption2[MigrationFeeOption2["FixedBps400"] = 4] = "FixedBps400";
  MigrationFeeOption2[MigrationFeeOption2["FixedBps600"] = 5] = "FixedBps600";
  return MigrationFeeOption2;
})(MigrationFeeOption || {});
var TokenDecimal = /* @__PURE__ */ ((TokenDecimal3) => {
  TokenDecimal3[TokenDecimal3["SIX"] = 6] = "SIX";
  TokenDecimal3[TokenDecimal3["SEVEN"] = 7] = "SEVEN";
  TokenDecimal3[TokenDecimal3["EIGHT"] = 8] = "EIGHT";
  TokenDecimal3[TokenDecimal3["NINE"] = 9] = "NINE";
  return TokenDecimal3;
})(TokenDecimal || {});
var TradeDirection = /* @__PURE__ */ ((TradeDirection2) => {
  TradeDirection2[TradeDirection2["BaseToQuote"] = 0] = "BaseToQuote";
  TradeDirection2[TradeDirection2["QuoteToBase"] = 1] = "QuoteToBase";
  return TradeDirection2;
})(TradeDirection || {});
var Rounding = /* @__PURE__ */ ((Rounding2) => {
  Rounding2[Rounding2["Up"] = 0] = "Up";
  Rounding2[Rounding2["Down"] = 1] = "Down";
  return Rounding2;
})(Rounding || {});
var TokenUpdateAuthorityOption = /* @__PURE__ */ ((TokenUpdateAuthorityOption2) => {
  TokenUpdateAuthorityOption2[TokenUpdateAuthorityOption2["Mutable"] = 0] = "Mutable";
  TokenUpdateAuthorityOption2[TokenUpdateAuthorityOption2["Immutable"] = 1] = "Immutable";
  return TokenUpdateAuthorityOption2;
})(TokenUpdateAuthorityOption || {});

// src/constants.ts
import BN from "bn.js";
import { PublicKey } from "@solana/web3.js";
var OFFSET = 64;
var U64_MAX = new BN("18446744073709551615");
var MIN_SQRT_PRICE = new BN("4295048016");
var MAX_SQRT_PRICE = new BN("79226673521066979257578248091");
var RESOLUTION = 64;
var ONE_Q64 = new BN(1).shln(RESOLUTION);
var FEE_DENOMINATOR = 1e9;
var MAX_FEE_BPS = 9900;
var MIN_FEE_BPS = 1;
var MIN_FEE_NUMERATOR = 1e5;
var MAX_FEE_NUMERATOR = 99e7;
var BASIS_POINT_MAX = 1e4;
var MAX_CURVE_POINT = 16;
var PARTNER_SURPLUS_SHARE = 80;
var SWAP_BUFFER_PERCENTAGE = 25;
var MAX_SWALLOW_PERCENTAGE = 20;
var MAX_MIGRATION_FEE_PERCENTAGE = 50;
var MAX_CREATOR_MIGRATION_FEE_PERCENTAGE = 100;
var MAX_RATE_LIMITER_DURATION_IN_SECONDS = 43200;
var MAX_RATE_LIMITER_DURATION_IN_SLOTS = 108e3;
var SLOT_DURATION = 400;
var TIMESTAMP_DURATION = 1e3;
var DYNAMIC_BONDING_CURVE_PROGRAM_ID = new PublicKey(
  "dbcij3LWUppWqq96dh6gJWwBifmcGfLSB5D4DuSMaqN"
);
var METAPLEX_PROGRAM_ID = new PublicKey(
  "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
);
var DAMM_V1_PROGRAM_ID = new PublicKey(
  "Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"
);
var DAMM_V2_PROGRAM_ID = new PublicKey(
  "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG"
);
var VAULT_PROGRAM_ID = new PublicKey(
  "24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi"
);
var LOCKER_PROGRAM_ID = new PublicKey(
  "LocpQgucEQHbqNABEYvBvwoxCPsSbG91A1QaQhQQqjn"
);
var BASE_ADDRESS = new PublicKey(
  "HWzXGcGHy4tcpYfaRDCyLNzXqBTv3E6BttpCH2vJxArv"
);
var DYNAMIC_FEE_FILTER_PERIOD_DEFAULT = 10;
var DYNAMIC_FEE_DECAY_PERIOD_DEFAULT = 120;
var DYNAMIC_FEE_REDUCTION_FACTOR_DEFAULT = 5e3;
var BIN_STEP_BPS_DEFAULT = 1;
var BIN_STEP_BPS_U128_DEFAULT = new BN("1844674407370955");
var MAX_PRICE_CHANGE_BPS_DEFAULT = 1500;
var DAMM_V1_MIGRATION_FEE_ADDRESS = [
  new PublicKey("8f848CEy8eY6PhJ3VcemtBDzPPSD4Vq7aJczLZ3o8MmX"),
  // FixedBps25
  new PublicKey("HBxB8Lf14Yj8pqeJ8C4qDb5ryHL7xwpuykz31BLNYr7S"),
  // FixedBps30
  new PublicKey("7v5vBdUQHTNeqk1HnduiXcgbvCyVEZ612HLmYkQoAkik"),
  // FixedBps100
  new PublicKey("EkvP7d5yKxovj884d2DwmBQbrHUWRLGK6bympzrkXGja"),
  // FixedBps200
  new PublicKey("9EZYAJrcqNWNQzP2trzZesP7XKMHA1jEomHzbRsdX8R2"),
  // FixedBps400
  new PublicKey("8cdKo87jZU2R12KY1BUjjRPwyjgdNjLGqSGQyrDshhud")
  // FixedBps600
];
var DAMM_V2_MIGRATION_FEE_ADDRESS = [
  new PublicKey("7F6dnUcRuyM2TwR8myT1dYypFXpPSxqwKNSFNkxyNESd"),
  // FixedBps25
  new PublicKey("2nHK1kju6XjphBLbNxpM5XRGFj7p9U8vvNzyZiha1z6k"),
  // FixedBps30
  new PublicKey("Hv8Lmzmnju6m7kcokVKvwqz7QPmdX9XfKjJsXz8RXcjp"),
  // FixedBps100
  new PublicKey("2c4cYd4reUYVRAB9kUUkrq55VPyy2FNQ3FDL4o12JXmq"),
  // FixedBps200
  new PublicKey("AkmQWebAwFvWk55wBoCr5D62C6VVDTzi84NJuD9H7cFD"),
  // FixedBps400
  new PublicKey("DbCRBj8McvPYHJG1ukj8RE15h2dCNUdTAESG49XpQ44u")
  // FixedBps600
];

// src/helpers/common.ts
import BN6 from "bn.js";
import Decimal2 from "decimal.js";

// src/math/curve.ts
import BN4 from "bn.js";

// src/math/safeMath.ts
import BN2 from "bn.js";
var SafeMath = class {
  /**
   * Safe addition
   * @param a First number
   * @param b Second number
   * @returns Sum of a and b
   */
  static add(a, b) {
    return a.add(b);
  }
  /**
   * Safe subtraction
   * @param a First number
   * @param b Second number
   * @returns Difference of a and b
   * @throws Error if b > a
   */
  static sub(a, b) {
    if (b.gt(a)) {
      throw new Error("SafeMath: subtraction overflow");
    }
    return a.sub(b);
  }
  /**
   * Safe multiplication
   * @param a First number
   * @param b Second number
   * @returns Product of a and b
   */
  static mul(a, b) {
    return a.mul(b);
  }
  /**
   * Safe division
   * @param a First number
   * @param b Second number
   * @returns Quotient of a and b
   * @throws Error if b is zero
   */
  static div(a, b) {
    if (b.isZero()) {
      throw new Error("SafeMath: division by zero");
    }
    return a.div(b);
  }
  /**
   * Safe modulo
   * @param a First number
   * @param b Second number
   * @returns Remainder of a divided by b
   * @throws Error if b is zero
   */
  static mod(a, b) {
    if (b.isZero()) {
      throw new Error("SafeMath: modulo by zero");
    }
    return a.mod(b);
  }
  /**
   * Safe left shift
   * @param a Number to shift
   * @param b Number of bits to shift
   * @returns a << b
   */
  static shl(a, b) {
    return a.shln(b);
  }
  /**
   * Safe right shift
   * @param a Number to shift
   * @param b Number of bits to shift
   * @returns a >> b
   */
  static shr(a, b) {
    return a.shrn(b);
  }
};
function pow(base, exponent, scaling = true) {
  const ONE = new BN2(1).shln(RESOLUTION);
  if (exponent.isZero()) return ONE;
  if (base.isZero()) return new BN2(0);
  if (base.eq(ONE)) return ONE;
  const isNegative = exponent.isNeg();
  const absExponent = isNegative ? exponent.neg() : exponent;
  let result = ONE;
  let currentBase = base;
  let exp = absExponent;
  while (!exp.isZero()) {
    if (exp.and(new BN2(1)).eq(new BN2(1))) {
      result = SafeMath.div(SafeMath.mul(result, currentBase), ONE);
    }
    currentBase = SafeMath.div(SafeMath.mul(currentBase, currentBase), ONE);
    exp = exp.shrn(1);
  }
  if (isNegative) {
    result = SafeMath.div(ONE.mul(ONE), result);
  }
  return scaling ? result : SafeMath.div(result, ONE);
}

// src/math/utilsMath.ts
import BN3 from "bn.js";
function mulDiv(x, y, denominator, rounding) {
  if (denominator.isZero()) {
    throw new Error("MulDiv: division by zero");
  }
  if (denominator.eq(new BN3(1)) || x.isZero() || y.isZero()) {
    return x.mul(y);
  }
  const prod = x.mul(y);
  if (rounding === 0 /* Up */) {
    const numerator = prod.add(denominator.sub(new BN3(1)));
    return numerator.div(denominator);
  } else {
    return prod.div(denominator);
  }
}

// src/math/curve.ts
function getDeltaAmountBaseUnsigned(lowerSqrtPrice, upperSqrtPrice, liquidity, round) {
  if (liquidity.isZero()) {
    return new BN4(0);
  }
  if (lowerSqrtPrice.isZero() || upperSqrtPrice.isZero()) {
    throw new Error("Sqrt price cannot be zero");
  }
  const numerator = SafeMath.sub(upperSqrtPrice, lowerSqrtPrice);
  const denominator = SafeMath.mul(lowerSqrtPrice, upperSqrtPrice);
  return mulDiv(liquidity, numerator, denominator, round);
}
function getDeltaAmountQuoteUnsigned(lowerSqrtPrice, upperSqrtPrice, liquidity, round) {
  if (liquidity.isZero()) {
    return new BN4(0);
  }
  const deltaSqrtPrice = SafeMath.sub(upperSqrtPrice, lowerSqrtPrice);
  const prod = SafeMath.mul(liquidity, deltaSqrtPrice);
  if (round === 0 /* Up */) {
    const denominator = new BN4(1).shln(RESOLUTION * 2);
    const numerator = SafeMath.add(
      prod,
      SafeMath.sub(denominator, new BN4(1))
    );
    return SafeMath.div(numerator, denominator);
  } else {
    return SafeMath.shr(prod, RESOLUTION * 2);
  }
}
function getNextSqrtPriceFromInput(sqrtPrice, liquidity, amountIn, baseForQuote) {
  if (sqrtPrice.isZero() || liquidity.isZero()) {
    throw new Error("Price or liquidity cannot be zero");
  }
  if (baseForQuote) {
    return getNextSqrtPriceFromAmountBaseRoundingUp(
      sqrtPrice,
      liquidity,
      amountIn
    );
  } else {
    return getNextSqrtPriceFromAmountQuoteRoundingDown(
      sqrtPrice,
      liquidity,
      amountIn
    );
  }
}
function getNextSqrtPriceFromAmountBaseRoundingUp(sqrtPrice, liquidity, amount) {
  if (amount.isZero()) {
    return sqrtPrice;
  }
  const product = SafeMath.mul(amount, sqrtPrice);
  const denominator = SafeMath.add(liquidity, product);
  return mulDiv(liquidity, sqrtPrice, denominator, 0 /* Up */);
}
function getNextSqrtPriceFromAmountQuoteRoundingDown(sqrtPrice, liquidity, amount) {
  if (amount.isZero()) {
    return sqrtPrice;
  }
  const quotient = SafeMath.div(
    SafeMath.shl(amount, RESOLUTION * 2),
    liquidity
  );
  return SafeMath.add(sqrtPrice, quotient);
}
function getInitialLiquidityFromDeltaQuote(quoteAmount, sqrtMinPrice, sqrtPrice) {
  const priceDelta = SafeMath.sub(sqrtPrice, sqrtMinPrice);
  const quoteAmountShifted = SafeMath.shl(quoteAmount, RESOLUTION * 2);
  return SafeMath.div(quoteAmountShifted, priceDelta);
}
function getInitialLiquidityFromDeltaBase(baseAmount, sqrtMaxPrice, sqrtPrice) {
  const priceDelta = SafeMath.sub(sqrtMaxPrice, sqrtPrice);
  const prod = SafeMath.mul(SafeMath.mul(baseAmount, sqrtPrice), sqrtMaxPrice);
  return SafeMath.div(prod, priceDelta);
}
function getInitializeAmounts(sqrtMinPrice, sqrtMaxPrice, sqrtPrice, liquidity) {
  const amountBase = getDeltaAmountBaseUnsigned(
    sqrtPrice,
    sqrtMaxPrice,
    liquidity,
    0 /* Up */
  );
  const amountQuote = getDeltaAmountQuoteUnsigned(
    sqrtMinPrice,
    sqrtPrice,
    liquidity,
    0 /* Up */
  );
  return [amountBase, amountQuote];
}

// src/helpers/common.ts
import { PublicKey as PublicKey3 } from "@solana/web3.js";

// src/helpers/utils.ts
import BN5 from "bn.js";
import { PublicKey as PublicKey2 } from "@solana/web3.js";
import { NATIVE_MINT } from "@solana/spl-token";
import Decimal from "decimal.js";
function convertToLamports(amount, tokenDecimal) {
  const valueInLamports = new Decimal(amount).mul(
    Decimal.pow(10, tokenDecimal)
  );
  return fromDecimalToBN(valueInLamports);
}
function fromDecimalToBN(value) {
  return new BN5(value.floor().toFixed());
}
function createProgramAccountFilter(owner, offset) {
  const ownerKey = typeof owner === "string" ? new PublicKey2(owner) : owner;
  return [
    {
      memcmp: {
        offset,
        bytes: ownerKey.toBase58(),
        encoding: "base58"
      }
    }
  ];
}
function isNativeSol(mint) {
  return mint.toString() === NATIVE_MINT.toString();
}
function isDefaultLockedVesting(lockedVesting) {
  return lockedVesting.amountPerPeriod.eqn(0) && lockedVesting.cliffDurationFromMigrationTime.eqn(0) && lockedVesting.frequency.eqn(0) && lockedVesting.numberOfPeriod.eqn(0) && lockedVesting.cliffUnlockAmount.eqn(0);
}
function convertDecimalToBN(value) {
  return new BN5(value.floor().toFixed());
}
function bpsToFeeNumerator(bps) {
  return new BN5(bps * FEE_DENOMINATOR).divn(BASIS_POINT_MAX);
}
function feeNumeratorToBps(feeNumerator) {
  return feeNumerator.muln(BASIS_POINT_MAX).div(new BN5(FEE_DENOMINATOR)).toNumber();
}

// src/helpers/common.ts
function getFirstKey(key1, key2) {
  const buf1 = key1.toBuffer();
  const buf2 = key2.toBuffer();
  if (Buffer.compare(buf1, buf2) === 1) {
    return buf1;
  }
  return buf2;
}
function getSecondKey(key1, key2) {
  const buf1 = key1.toBuffer();
  const buf2 = key2.toBuffer();
  if (Buffer.compare(buf1, buf2) === 1) {
    return buf2;
  }
  return buf1;
}
async function getAccountData(accountAddress, accountType, program) {
  const address = accountAddress instanceof PublicKey3 ? accountAddress : new PublicKey3(accountAddress);
  return await program.account[accountType].fetchNullable(address);
}
async function getAccountCreationTimestamp(accountAddress, connection) {
  const address = accountAddress instanceof PublicKey3 ? accountAddress : new PublicKey3(accountAddress);
  const signatures = await connection.getSignaturesForAddress(address, {
    limit: 1
  });
  return signatures[0]?.blockTime ? new Date(signatures[0].blockTime * 1e3) : void 0;
}
async function getAccountCreationTimestamps(accountAddresses, connection) {
  const timestampPromises = accountAddresses.map(
    (address) => getAccountCreationTimestamp(address, connection)
  );
  return Promise.all(timestampPromises);
}
function getTotalTokenSupply(swapBaseAmount, migrationBaseThreshold, lockedVestingParams) {
  try {
    const totalCirculatingAmount = swapBaseAmount.add(
      migrationBaseThreshold
    );
    const totalLockedVestingAmount = lockedVestingParams.cliffUnlockAmount.add(
      lockedVestingParams.amountPerPeriod.mul(
        lockedVestingParams.numberOfPeriod
      )
    );
    const totalAmount = totalCirculatingAmount.add(totalLockedVestingAmount);
    if (totalAmount.isNeg() || totalAmount.bitLength() > 64) {
      throw new Error("Math overflow");
    }
    return totalAmount;
  } catch (error) {
    throw new Error("Math overflow");
  }
}
function getPriceFromSqrtPrice(sqrtPrice, tokenBaseDecimal, tokenQuoteDecimal) {
  const sqrtPriceDecimal = new Decimal2(sqrtPrice.toString());
  const lamportPrice = sqrtPriceDecimal.mul(sqrtPriceDecimal).div(new Decimal2(2).pow(128));
  const tokenPrice = lamportPrice.mul(
    new Decimal2(10).pow(tokenBaseDecimal - tokenQuoteDecimal)
  );
  return tokenPrice;
}
var getSqrtPriceFromPrice = (price, tokenADecimal, tokenBDecimal) => {
  const decimalPrice = new Decimal2(price);
  const adjustedByDecimals = decimalPrice.div(
    new Decimal2(10 ** (tokenADecimal - tokenBDecimal))
  );
  const sqrtValue = Decimal2.sqrt(adjustedByDecimals);
  const sqrtValueQ64 = sqrtValue.mul(Decimal2.pow(2, 64));
  return new BN6(sqrtValueQ64.floor().toFixed());
};
var getSqrtPriceFromMarketCap = (marketCap, totalSupply, tokenBaseDecimal, tokenQuoteDecimal) => {
  let price = new Decimal2(marketCap).div(new Decimal2(totalSupply));
  return getSqrtPriceFromPrice(
    price.toString(),
    tokenBaseDecimal,
    tokenQuoteDecimal
  );
};
function getBaseTokenForSwap(sqrtStartPrice, sqrtMigrationPrice, curve) {
  let totalAmount = new BN6(0);
  for (let i = 0; i < curve.length; i++) {
    const lowerSqrtPrice = i == 0 ? sqrtStartPrice : curve[i - 1].sqrtPrice;
    if (curve[i].sqrtPrice && curve[i].sqrtPrice.gt(sqrtMigrationPrice)) {
      const deltaAmount = getDeltaAmountBase(
        lowerSqrtPrice,
        sqrtMigrationPrice,
        curve[i].liquidity
      );
      totalAmount = totalAmount.add(deltaAmount);
      break;
    } else {
      const deltaAmount = getDeltaAmountBase(
        lowerSqrtPrice,
        curve[i].sqrtPrice,
        curve[i].liquidity
      );
      totalAmount = totalAmount.add(deltaAmount);
    }
  }
  return totalAmount;
}
function getDeltaAmountBase(lowerSqrtPrice, upperSqrtPrice, liquidity) {
  const numerator = liquidity.mul(upperSqrtPrice.sub(lowerSqrtPrice));
  const denominator = lowerSqrtPrice.mul(upperSqrtPrice);
  return numerator.add(denominator).sub(new BN6(1)).div(denominator);
}
var getMigrationQuoteAmountFromMigrationQuoteThreshold = (migrationQuoteThreshold, migrationFeePercent) => {
  const migrationQuoteAmount = migrationQuoteThreshold.mul(new Decimal2(100).sub(new Decimal2(migrationFeePercent))).div(new Decimal2(100));
  return migrationQuoteAmount;
};
var getMigrationQuoteThresholdFromMigrationQuoteAmount = (migrationQuoteAmount, migrationFeePercent) => {
  const migrationQuoteThreshold = migrationQuoteAmount.mul(new Decimal2(100)).div(new Decimal2(100).sub(new Decimal2(migrationFeePercent)));
  return migrationQuoteThreshold;
};
var getMigrationMarketCap = (percentageSupplyOnMigration, totalTokenSupply, migrationQuoteThreshold, migrationFeePercentage) => {
  if (migrationFeePercentage > MAX_MIGRATION_FEE_PERCENTAGE) {
    throw new Error("Migration fee percentage cannot be greater than 50");
  }
  const migrationBaseAmount = new Decimal2(totalTokenSupply).mul(new Decimal2(percentageSupplyOnMigration)).div(new Decimal2(100));
  const migrationQuoteAmount = getMigrationQuoteAmountFromMigrationQuoteThreshold(
    new Decimal2(migrationQuoteThreshold),
    migrationFeePercentage
  );
  const migrationPrice = migrationQuoteAmount.div(migrationBaseAmount);
  const migrationMarketCap = migrationPrice.mul(new Decimal2(totalTokenSupply));
  return migrationMarketCap;
};
var getMigrationBaseToken = (migrationQuoteAmount, sqrtMigrationPrice, migrationOption) => {
  if (migrationOption == 0 /* MET_DAMM */) {
    const price = sqrtMigrationPrice.mul(sqrtMigrationPrice);
    const quote = migrationQuoteAmount.shln(128);
    const { div: baseDiv, mod } = quote.divmod(price);
    let div = baseDiv;
    if (!mod.isZero()) {
      div = div.add(new BN6(1));
    }
    return div;
  } else if (migrationOption == 1 /* MET_DAMM_V2 */) {
    const liquidity = getInitialLiquidityFromDeltaQuote(
      migrationQuoteAmount,
      MIN_SQRT_PRICE,
      sqrtMigrationPrice
    );
    const baseAmount = getDeltaAmountBase(
      sqrtMigrationPrice,
      MAX_SQRT_PRICE,
      liquidity
    );
    return baseAmount;
  } else {
    throw Error("Invalid migration option");
  }
};
var getTotalVestingAmount = (lockedVesting) => {
  const totalVestingAmount = lockedVesting.cliffUnlockAmount.add(
    lockedVesting.amountPerPeriod.mul(lockedVesting.numberOfPeriod)
  );
  return totalVestingAmount;
};
var getLiquidity = (baseAmount, quoteAmount, minSqrtPrice, maxSqrtPrice) => {
  const liquidityFromBase = getInitialLiquidityFromDeltaBase(
    baseAmount,
    maxSqrtPrice,
    minSqrtPrice
  );
  const liquidityFromQuote = getInitialLiquidityFromDeltaQuote(
    quoteAmount,
    minSqrtPrice,
    maxSqrtPrice
  );
  return BN6.min(liquidityFromBase, liquidityFromQuote);
};
var getFirstCurve = (migrationSqrtPrice, migrationBaseAmount, swapAmount, migrationQuoteThreshold, migrationFeePercent) => {
  const migrationSqrPriceDecimal = new Decimal2(migrationSqrtPrice.toString());
  const migrationBaseAmountDecimal = new Decimal2(
    migrationBaseAmount.toString()
  );
  const swapAmountDecimal = new Decimal2(swapAmount.toString());
  const migrationFeePercentDecimal = new Decimal2(
    migrationFeePercent.toString()
  );
  const denominator = swapAmountDecimal.mul(new Decimal2(100).sub(migrationFeePercentDecimal)).div(new Decimal2(100));
  const sqrtStartPriceDecimal = migrationSqrPriceDecimal.mul(migrationBaseAmountDecimal).div(denominator);
  const sqrtStartPrice = new BN6(sqrtStartPriceDecimal.floor().toFixed());
  const liquidity = getLiquidity(
    swapAmount,
    migrationQuoteThreshold,
    sqrtStartPrice,
    migrationSqrtPrice
  );
  return {
    sqrtStartPrice,
    curve: [
      {
        sqrtPrice: migrationSqrtPrice,
        liquidity
      }
    ]
  };
};
var getTotalSupplyFromCurve = (migrationQuoteThreshold, sqrtStartPrice, curve, lockedVesting, migrationOption, leftover, migrationFeePercent) => {
  const sqrtMigrationPrice = getMigrationThresholdPrice(
    migrationQuoteThreshold,
    sqrtStartPrice,
    curve
  );
  const swapBaseAmount = getBaseTokenForSwap(
    sqrtStartPrice,
    sqrtMigrationPrice,
    curve
  );
  const swapBaseAmountBuffer = getSwapAmountWithBuffer(
    swapBaseAmount,
    sqrtStartPrice,
    curve
  );
  const migrationQuoteAmount = getMigrationQuoteAmountFromMigrationQuoteThreshold(
    new Decimal2(migrationQuoteThreshold.toString()),
    migrationFeePercent
  );
  const migrationBaseAmount = getMigrationBaseToken(
    fromDecimalToBN(migrationQuoteAmount),
    sqrtMigrationPrice,
    migrationOption
  );
  const totalVestingAmount = getTotalVestingAmount(lockedVesting);
  const minimumBaseSupplyWithBuffer = swapBaseAmountBuffer.add(migrationBaseAmount).add(totalVestingAmount).add(leftover);
  return minimumBaseSupplyWithBuffer;
};
var getMigrationThresholdPrice = (migrationThreshold, sqrtStartPrice, curve) => {
  let nextSqrtPrice = sqrtStartPrice;
  if (curve.length === 0) {
    throw Error("Curve is empty");
  }
  const totalAmount = getDeltaAmountQuoteUnsigned(
    nextSqrtPrice,
    curve[0].sqrtPrice,
    curve[0].liquidity,
    0 /* Up */
  );
  if (totalAmount.gt(migrationThreshold)) {
    nextSqrtPrice = getNextSqrtPriceFromInput(
      nextSqrtPrice,
      curve[0].liquidity,
      migrationThreshold,
      false
    );
  } else {
    let amountLeft = migrationThreshold.sub(totalAmount);
    nextSqrtPrice = curve[0].sqrtPrice;
    for (let i = 1; i < curve.length; i++) {
      const maxAmount = getDeltaAmountQuoteUnsigned(
        nextSqrtPrice,
        curve[i].sqrtPrice,
        curve[i].liquidity,
        0 /* Up */
      );
      if (maxAmount.gt(amountLeft)) {
        nextSqrtPrice = getNextSqrtPriceFromInput(
          nextSqrtPrice,
          curve[i].liquidity,
          amountLeft,
          false
        );
        amountLeft = new BN6(0);
        break;
      } else {
        amountLeft = amountLeft.sub(maxAmount);
        nextSqrtPrice = curve[i].sqrtPrice;
      }
    }
    if (!amountLeft.isZero()) {
      let migrationThresholdStr = migrationThreshold.toString();
      let amountLeftStr = amountLeft.toString();
      throw Error(
        `Not enough liquidity, migrationThreshold: ${migrationThresholdStr}  amountLeft: ${amountLeftStr}`
      );
    }
  }
  return nextSqrtPrice;
};
var getSwapAmountWithBuffer = (swapBaseAmount, sqrtStartPrice, curve) => {
  const swapAmountBuffer = swapBaseAmount.add(
    swapBaseAmount.mul(new BN6(25)).div(new BN6(100))
  );
  const maxBaseAmountOnCurve = getBaseTokenForSwap(
    sqrtStartPrice,
    MAX_SQRT_PRICE,
    curve
  );
  return BN6.min(swapAmountBuffer, maxBaseAmountOnCurve);
};
var getPercentageSupplyOnMigration = (initialMarketCap, migrationMarketCap, lockedVesting, totalLeftover, totalTokenSupply) => {
  const marketCapRatio = initialMarketCap.div(migrationMarketCap);
  const sqrtRatio = Decimal2.sqrt(marketCapRatio);
  const totalVestingAmount = getTotalVestingAmount(lockedVesting);
  const vestingPercentage = new Decimal2(totalVestingAmount.toString()).mul(new Decimal2(100)).div(new Decimal2(totalTokenSupply.toString()));
  const leftoverPercentage = new Decimal2(totalLeftover.toString()).mul(new Decimal2(100)).div(new Decimal2(totalTokenSupply.toString()));
  const numerator = new Decimal2(100).mul(sqrtRatio).sub(vestingPercentage.add(leftoverPercentage).mul(sqrtRatio));
  const denominator = new Decimal2(1).add(sqrtRatio);
  return numerator.div(denominator).toNumber();
};
var getMigrationQuoteAmount = (migrationMarketCap, percentageSupplyOnMigration) => {
  return migrationMarketCap.mul(percentageSupplyOnMigration).div(new Decimal2(100));
};
function getFeeSchedulerParams(startingBaseFeeBps, endingBaseFeeBps, baseFeeMode, numberOfPeriod, totalDuration) {
  if (startingBaseFeeBps == endingBaseFeeBps) {
    if (numberOfPeriod != 0 || totalDuration != 0) {
      throw new Error(
        "numberOfPeriod and totalDuration must both be zero"
      );
    }
    return {
      cliffFeeNumerator: bpsToFeeNumerator(startingBaseFeeBps),
      firstFactor: 0,
      secondFactor: new BN6(0),
      thirdFactor: new BN6(0),
      baseFeeMode: 0 /* FeeSchedulerLinear */
    };
  }
  if (numberOfPeriod <= 0) {
    throw new Error("Total periods must be greater than zero");
  }
  if (startingBaseFeeBps > MAX_FEE_BPS) {
    throw new Error(
      `startingBaseFeeBps (${startingBaseFeeBps} bps) exceeds maximum allowed value of ${MAX_FEE_BPS} bps`
    );
  }
  if (endingBaseFeeBps > startingBaseFeeBps) {
    throw new Error(
      "endingBaseFeeBps bps must be less than or equal to startingBaseFeeBps bps"
    );
  }
  if (numberOfPeriod == 0 || totalDuration == 0) {
    throw new Error(
      "numberOfPeriod and totalDuration must both greater than zero"
    );
  }
  const maxBaseFeeNumerator = bpsToFeeNumerator(startingBaseFeeBps);
  const minBaseFeeNumerator = bpsToFeeNumerator(endingBaseFeeBps);
  const periodFrequency = new BN6(totalDuration / numberOfPeriod);
  let reductionFactor;
  if (baseFeeMode == 0 /* FeeSchedulerLinear */) {
    const totalReduction = maxBaseFeeNumerator.sub(minBaseFeeNumerator);
    reductionFactor = totalReduction.divn(numberOfPeriod);
  } else {
    const ratio = minBaseFeeNumerator.toNumber() / maxBaseFeeNumerator.toNumber();
    const decayBase = Math.pow(ratio, 1 / numberOfPeriod);
    reductionFactor = new BN6(BASIS_POINT_MAX * (1 - decayBase));
  }
  return {
    cliffFeeNumerator: maxBaseFeeNumerator,
    firstFactor: numberOfPeriod,
    secondFactor: periodFrequency,
    thirdFactor: reductionFactor,
    baseFeeMode
  };
}
function calculateFeeSchedulerEndingBaseFeeBps(cliffFeeNumerator, numberOfPeriod, reductionFactor, baseFeeMode) {
  let baseFeeNumerator;
  if (baseFeeMode == 0 /* FeeSchedulerLinear */) {
    baseFeeNumerator = cliffFeeNumerator - numberOfPeriod * reductionFactor;
  } else {
    const decayRate = 1 - reductionFactor / BASIS_POINT_MAX;
    baseFeeNumerator = cliffFeeNumerator * Math.pow(decayRate, numberOfPeriod);
  }
  return Math.max(0, baseFeeNumerator / FEE_DENOMINATOR * BASIS_POINT_MAX);
}
function getRateLimiterParams(baseFeeBps, feeIncrementBps, referenceAmount, maxLimiterDuration, tokenQuoteDecimal, activationType) {
  const cliffFeeNumerator = bpsToFeeNumerator(baseFeeBps);
  const feeIncrementNumerator = bpsToFeeNumerator(feeIncrementBps);
  if (baseFeeBps <= 0 || feeIncrementBps <= 0 || referenceAmount <= 0 || maxLimiterDuration <= 0) {
    throw new Error("All rate limiter parameters must be greater than zero");
  }
  if (baseFeeBps > MAX_FEE_BPS) {
    throw new Error(
      `Base fee (${baseFeeBps} bps) exceeds maximum allowed value of ${MAX_FEE_BPS} bps`
    );
  }
  if (feeIncrementBps > MAX_FEE_BPS) {
    throw new Error(
      `Fee increment (${feeIncrementBps} bps) exceeds maximum allowed value of ${MAX_FEE_BPS} bps`
    );
  }
  if (feeIncrementNumerator.gte(new BN6(FEE_DENOMINATOR))) {
    throw new Error(
      "Fee increment numerator must be less than FEE_DENOMINATOR"
    );
  }
  const deltaNumerator = new BN6(MAX_FEE_NUMERATOR).sub(cliffFeeNumerator);
  const maxIndex = deltaNumerator.div(feeIncrementNumerator);
  if (maxIndex.lt(new BN6(1))) {
    throw new Error("Fee increment is too large for the given base fee");
  }
  if (cliffFeeNumerator.lt(new BN6(MIN_FEE_NUMERATOR)) || cliffFeeNumerator.gt(new BN6(MAX_FEE_NUMERATOR))) {
    throw new Error("Base fee must be between 0.01% and 99%");
  }
  const maxDuration = activationType === 0 /* Slot */ ? MAX_RATE_LIMITER_DURATION_IN_SLOTS : MAX_RATE_LIMITER_DURATION_IN_SECONDS;
  if (maxLimiterDuration > maxDuration) {
    throw new Error(
      `Max duration exceeds maximum allowed value of ${maxDuration}`
    );
  }
  const referenceAmountInLamports = convertToLamports(
    referenceAmount,
    tokenQuoteDecimal
  );
  return {
    cliffFeeNumerator,
    firstFactor: feeIncrementBps,
    secondFactor: new BN6(maxLimiterDuration),
    thirdFactor: new BN6(referenceAmountInLamports),
    baseFeeMode: 2 /* RateLimiter */
  };
}
function getDynamicFeeParams(baseFeeBps, maxPriceChangeBps = MAX_PRICE_CHANGE_BPS_DEFAULT) {
  if (maxPriceChangeBps > MAX_PRICE_CHANGE_BPS_DEFAULT) {
    throw new Error(
      `maxPriceChangeBps (${maxPriceChangeBps} bps) must be less than or equal to ${MAX_PRICE_CHANGE_BPS_DEFAULT}`
    );
  }
  const priceRatio = maxPriceChangeBps / BASIS_POINT_MAX + 1;
  const sqrtPriceRatioQ64 = new BN6(
    Decimal2.sqrt(priceRatio.toString()).mul(Decimal2.pow(2, 64)).floor().toFixed()
  );
  const deltaBinId = sqrtPriceRatioQ64.sub(ONE_Q64).div(BIN_STEP_BPS_U128_DEFAULT).muln(2);
  const maxVolatilityAccumulator = new BN6(deltaBinId.muln(BASIS_POINT_MAX));
  const squareVfaBin = maxVolatilityAccumulator.mul(new BN6(BIN_STEP_BPS_DEFAULT)).pow(new BN6(2));
  const baseFeeNumerator = new BN6(bpsToFeeNumerator(baseFeeBps));
  const maxDynamicFeeNumerator = baseFeeNumerator.muln(20).divn(100);
  const vFee = maxDynamicFeeNumerator.mul(new BN6(1e11)).sub(new BN6(99999999999));
  const variableFeeControl = vFee.div(squareVfaBin);
  return {
    binStep: BIN_STEP_BPS_DEFAULT,
    binStepU128: BIN_STEP_BPS_U128_DEFAULT,
    filterPeriod: DYNAMIC_FEE_FILTER_PERIOD_DEFAULT,
    decayPeriod: DYNAMIC_FEE_DECAY_PERIOD_DEFAULT,
    reductionFactor: DYNAMIC_FEE_REDUCTION_FACTOR_DEFAULT,
    maxVolatilityAccumulator: maxVolatilityAccumulator.toNumber(),
    variableFeeControl: variableFeeControl.toNumber()
  };
}
function getLockedVestingParams(totalLockedVestingAmount, numberOfVestingPeriod, cliffUnlockAmount, totalVestingDuration, cliffDurationFromMigrationTime, tokenBaseDecimal) {
  if (totalLockedVestingAmount == 0) {
    return {
      amountPerPeriod: new BN6(0),
      cliffDurationFromMigrationTime: new BN6(0),
      frequency: new BN6(0),
      numberOfPeriod: new BN6(0),
      cliffUnlockAmount: new BN6(0)
    };
  }
  if (totalLockedVestingAmount == cliffUnlockAmount) {
    return {
      amountPerPeriod: convertToLamports(1, tokenBaseDecimal),
      cliffDurationFromMigrationTime: new BN6(
        cliffDurationFromMigrationTime
      ),
      frequency: new BN6(1),
      numberOfPeriod: new BN6(1),
      cliffUnlockAmount: convertToLamports(
        totalLockedVestingAmount - 1,
        tokenBaseDecimal
      )
    };
  }
  if (numberOfVestingPeriod <= 0) {
    throw new Error("Total periods must be greater than zero");
  }
  if (numberOfVestingPeriod == 0 || totalVestingDuration == 0) {
    throw new Error(
      "numberOfPeriod and totalVestingDuration must both be greater than zero"
    );
  }
  if (cliffUnlockAmount > totalLockedVestingAmount) {
    throw new Error(
      "Cliff unlock amount cannot be greater than total locked vesting amount"
    );
  }
  const amountPerPeriod = (totalLockedVestingAmount - cliffUnlockAmount) / numberOfVestingPeriod;
  const roundedAmountPerPeriod = Math.floor(amountPerPeriod);
  const totalPeriodicAmount = roundedAmountPerPeriod * numberOfVestingPeriod;
  const remainder = totalLockedVestingAmount - (cliffUnlockAmount + totalPeriodicAmount);
  const adjustedCliffUnlockAmount = cliffUnlockAmount + remainder;
  const periodFrequency = new BN6(totalVestingDuration / numberOfVestingPeriod);
  return {
    amountPerPeriod: convertToLamports(
      roundedAmountPerPeriod,
      tokenBaseDecimal
    ),
    cliffDurationFromMigrationTime: new BN6(cliffDurationFromMigrationTime),
    frequency: periodFrequency,
    numberOfPeriod: new BN6(numberOfVestingPeriod),
    cliffUnlockAmount: convertToLamports(
      adjustedCliffUnlockAmount,
      tokenBaseDecimal
    )
  };
}
var getTwoCurve = (migrationSqrtPrice, midSqrtPrice, initialSqrtPrice, swapAmount, migrationQuoteThreshold) => {
  let p0 = new Decimal2(initialSqrtPrice.toString());
  let p1 = new Decimal2(midSqrtPrice.toString());
  let p2 = new Decimal2(migrationSqrtPrice.toString());
  let a1 = new Decimal2(1).div(p0).sub(new Decimal2(1).div(p1));
  let b1 = new Decimal2(1).div(p1).sub(new Decimal2(1).div(p2));
  let c1 = new Decimal2(swapAmount.toString());
  let a2 = p1.sub(p0);
  let b2 = p2.sub(p1);
  let c2 = new Decimal2(migrationQuoteThreshold.toString()).mul(
    Decimal2.pow(2, 128)
  );
  let l0 = c1.mul(b2).sub(c2.mul(b1)).div(a1.mul(b2).sub(a2.mul(b1)));
  let l1 = c1.mul(a2).sub(c2.mul(a1)).div(b1.mul(a2).sub(b2.mul(a1)));
  if (l0.isNeg() || l1.isNeg()) {
    return {
      isOk: false,
      sqrtStartPrice: new BN6(0),
      curve: []
    };
  }
  return {
    isOk: true,
    sqrtStartPrice: initialSqrtPrice,
    curve: [
      {
        sqrtPrice: midSqrtPrice,
        liquidity: new BN6(l0.floor().toFixed())
      },
      {
        sqrtPrice: migrationSqrtPrice,
        liquidity: new BN6(l1.floor().toFixed())
      }
    ]
  };
};
function checkRateLimiterApplied(baseFeeMode, swapBaseForQuote, currentPoint, activationPoint, maxLimiterDuration) {
  return baseFeeMode === 2 /* RateLimiter */ && !swapBaseForQuote && currentPoint.gte(activationPoint) && currentPoint.lte(activationPoint.add(maxLimiterDuration));
}
function getBaseFeeParams(baseFeeParams, tokenQuoteDecimal, activationType) {
  if (baseFeeParams.baseFeeMode === 2 /* RateLimiter */) {
    if (!baseFeeParams.rateLimiterParam) {
      throw new Error(
        "Rate limiter parameters are required for RateLimiter mode"
      );
    }
    const {
      baseFeeBps,
      feeIncrementBps,
      referenceAmount,
      maxLimiterDuration
    } = baseFeeParams.rateLimiterParam;
    return getRateLimiterParams(
      baseFeeBps,
      feeIncrementBps,
      referenceAmount,
      maxLimiterDuration,
      tokenQuoteDecimal,
      activationType
    );
  } else {
    if (!baseFeeParams.feeSchedulerParam) {
      throw new Error(
        "Fee scheduler parameters are required for FeeScheduler mode"
      );
    }
    const { startingFeeBps, endingFeeBps, numberOfPeriod, totalDuration } = baseFeeParams.feeSchedulerParam;
    return getFeeSchedulerParams(
      startingFeeBps,
      endingFeeBps,
      baseFeeParams.baseFeeMode,
      numberOfPeriod,
      totalDuration
    );
  }
}

// src/helpers/accounts.ts
import { PublicKey as PublicKey4 } from "@solana/web3.js";
var SEED = Object.freeze({
  POOL_AUTHORITY: "pool_authority",
  EVENT_AUTHORITY: "__event_authority",
  POOL: "pool",
  TOKEN_VAULT: "token_vault",
  METADATA: "metadata",
  PARTNER_METADATA: "partner_metadata",
  CLAIM_FEE_OPERATOR: "cf_operator",
  DAMM_V1_MIGRATION_METADATA: "meteora",
  DAMM_V2_MIGRATION_METADATA: "damm_v2",
  LP_MINT: "lp_mint",
  FEE: "fee",
  POSITION: "position",
  POSITION_NFT_ACCOUNT: "position_nft_account",
  LOCK_ESCROW: "lock_escrow",
  VIRTUAL_POOL_METADATA: "virtual_pool_metadata",
  ESCROW: "escrow",
  BASE_LOCKER: "base_locker",
  VAULT: "vault"
});
function deriveDbcEventAuthority() {
  const [eventAuthority] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.EVENT_AUTHORITY)],
    DYNAMIC_BONDING_CURVE_PROGRAM_ID
  );
  return eventAuthority;
}
function deriveDammV1EventAuthority() {
  const [eventAuthority] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.EVENT_AUTHORITY)],
    DAMM_V1_PROGRAM_ID
  );
  return eventAuthority;
}
function deriveDammV2EventAuthority() {
  const [eventAuthority] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.EVENT_AUTHORITY)],
    DAMM_V2_PROGRAM_ID
  );
  return eventAuthority;
}
function deriveLockerEventAuthority() {
  const [eventAuthority] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.EVENT_AUTHORITY)],
    LOCKER_PROGRAM_ID
  );
  return eventAuthority;
}
function deriveDbcPoolAuthority() {
  const [poolAuthority] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.POOL_AUTHORITY)],
    DYNAMIC_BONDING_CURVE_PROGRAM_ID
  );
  return poolAuthority;
}
function deriveDammV1PoolAuthority() {
  const [poolAuthority] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.POOL_AUTHORITY)],
    DAMM_V1_PROGRAM_ID
  );
  return poolAuthority;
}
function deriveDammV2PoolAuthority() {
  const [poolAuthority] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.POOL_AUTHORITY)],
    DAMM_V2_PROGRAM_ID
  );
  return poolAuthority;
}
function deriveDbcPoolAddress(quoteMint, baseMint, config) {
  const isQuoteMintBiggerThanBaseMint = new PublicKey4(quoteMint).toBuffer().compare(new Uint8Array(new PublicKey4(baseMint).toBuffer())) > 0;
  const [pool] = PublicKey4.findProgramAddressSync(
    [
      Buffer.from(SEED.POOL),
      new PublicKey4(config).toBuffer(),
      isQuoteMintBiggerThanBaseMint ? new PublicKey4(quoteMint).toBuffer() : new PublicKey4(baseMint).toBuffer(),
      isQuoteMintBiggerThanBaseMint ? new PublicKey4(baseMint).toBuffer() : new PublicKey4(quoteMint).toBuffer()
    ],
    DYNAMIC_BONDING_CURVE_PROGRAM_ID
  );
  return pool;
}
function deriveDammV1PoolAddress(config, tokenAMint, tokenBMint) {
  return PublicKey4.findProgramAddressSync(
    [
      getFirstKey(tokenAMint, tokenBMint),
      getSecondKey(tokenAMint, tokenBMint),
      config.toBuffer()
    ],
    DAMM_V1_PROGRAM_ID
  )[0];
}
function deriveDammV2PoolAddress(config, tokenAMint, tokenBMint) {
  return PublicKey4.findProgramAddressSync(
    [
      Buffer.from(SEED.POOL),
      config.toBuffer(),
      getFirstKey(tokenAMint, tokenBMint),
      getSecondKey(tokenAMint, tokenBMint)
    ],
    DAMM_V2_PROGRAM_ID
  )[0];
}
function deriveMintMetadata(mint) {
  const [metadata] = PublicKey4.findProgramAddressSync(
    [
      Buffer.from(SEED.METADATA),
      METAPLEX_PROGRAM_ID.toBuffer(),
      mint.toBuffer()
    ],
    METAPLEX_PROGRAM_ID
  );
  return metadata;
}
function derivePartnerMetadata(feeClaimer) {
  const [partnerMetadata] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.PARTNER_METADATA), feeClaimer.toBuffer()],
    DYNAMIC_BONDING_CURVE_PROGRAM_ID
  );
  return partnerMetadata;
}
function deriveDbcPoolMetadata(pool) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.VIRTUAL_POOL_METADATA), pool.toBuffer()],
    DYNAMIC_BONDING_CURVE_PROGRAM_ID
  )[0];
}
function deriveDammV1MigrationMetadataAddress(virtual_pool) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.DAMM_V1_MIGRATION_METADATA), virtual_pool.toBuffer()],
    DYNAMIC_BONDING_CURVE_PROGRAM_ID
  )[0];
}
function deriveDammV2MigrationMetadataAddress(virtual_pool) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.DAMM_V2_MIGRATION_METADATA), virtual_pool.toBuffer()],
    DYNAMIC_BONDING_CURVE_PROGRAM_ID
  )[0];
}
function deriveDbcTokenVaultAddress(pool, mint) {
  const [tokenVault] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.TOKEN_VAULT), mint.toBuffer(), pool.toBuffer()],
    DYNAMIC_BONDING_CURVE_PROGRAM_ID
  );
  return tokenVault;
}
function deriveDammV1VaultLPAddress(vault, pool) {
  return PublicKey4.findProgramAddressSync(
    [vault.toBuffer(), pool.toBuffer()],
    DAMM_V1_PROGRAM_ID
  )[0];
}
function deriveDammV2TokenVaultAddress(pool, mint) {
  const [tokenVault] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.TOKEN_VAULT), mint.toBuffer(), pool.toBuffer()],
    DAMM_V2_PROGRAM_ID
  );
  return tokenVault;
}
function deriveVaultAddress(mint, payer) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.VAULT), mint.toBuffer(), payer.toBuffer()],
    VAULT_PROGRAM_ID
  )[0];
}
var deriveVaultPdas = (tokenMint, seedBaseKey) => {
  const [vault] = PublicKey4.findProgramAddressSync(
    [
      Buffer.from(SEED.VAULT),
      tokenMint.toBuffer(),
      (seedBaseKey ?? BASE_ADDRESS).toBuffer()
    ],
    VAULT_PROGRAM_ID
  );
  const [tokenVault] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.TOKEN_VAULT), vault.toBuffer()],
    VAULT_PROGRAM_ID
  );
  const [lpMint] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.LP_MINT), vault.toBuffer()],
    VAULT_PROGRAM_ID
  );
  return {
    vaultPda: vault,
    tokenVaultPda: tokenVault,
    lpMintPda: lpMint
  };
};
function deriveTokenVaultKey(vaultKey) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.TOKEN_VAULT), vaultKey.toBuffer()],
    VAULT_PROGRAM_ID
  )[0];
}
function deriveVaultLpMintAddress(pool) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.LP_MINT), pool.toBuffer()],
    VAULT_PROGRAM_ID
  )[0];
}
function deriveDammV1LpMintAddress(pool) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.LP_MINT), pool.toBuffer()],
    DAMM_V1_PROGRAM_ID
  )[0];
}
function derivePositionAddress(positionNft) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.POSITION), positionNft.toBuffer()],
    DAMM_V2_PROGRAM_ID
  )[0];
}
function derivePositionNftAccount(positionNftMint) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.POSITION_NFT_ACCOUNT), positionNftMint.toBuffer()],
    DAMM_V2_PROGRAM_ID
  )[0];
}
function deriveDammV1LockEscrowAddress(dammPool, creator) {
  return PublicKey4.findProgramAddressSync(
    [
      Buffer.from(SEED.LOCK_ESCROW),
      dammPool.toBuffer(),
      creator.toBuffer()
    ],
    DAMM_V1_PROGRAM_ID
  )[0];
}
function deriveDammV2LockEscrowAddress(dammPool, creator) {
  return PublicKey4.findProgramAddressSync(
    [
      Buffer.from(SEED.LOCK_ESCROW),
      dammPool.toBuffer(),
      creator.toBuffer()
    ],
    DAMM_V2_PROGRAM_ID
  )[0];
}
function deriveEscrow(base) {
  const [escrow] = PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.ESCROW), base.toBuffer()],
    LOCKER_PROGRAM_ID
  );
  return escrow;
}
function deriveDammV1ProtocolFeeAddress(mint, pool) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.FEE), mint.toBuffer(), pool.toBuffer()],
    DAMM_V1_PROGRAM_ID
  )[0];
}
function deriveBaseKeyForLocker(virtualPool) {
  return PublicKey4.findProgramAddressSync(
    [Buffer.from(SEED.BASE_LOCKER), virtualPool.toBuffer()],
    DYNAMIC_BONDING_CURVE_PROGRAM_ID
  )[0];
}

// src/helpers/validation.ts
import BN8 from "bn.js";
import { PublicKey as PublicKey5 } from "@solana/web3.js";
import Decimal3 from "decimal.js";

// src/math/rateLimiter.ts
import BN7 from "bn.js";
function getMaxIndex(cliffFeeNumerator, feeIncrementBps) {
  const deltaNumerator = new BN7(MAX_FEE_NUMERATOR).sub(cliffFeeNumerator);
  const feeIncrementNumerator = mulDiv(
    new BN7(feeIncrementBps),
    new BN7(FEE_DENOMINATOR),
    new BN7(BASIS_POINT_MAX),
    1 /* Down */
  );
  return deltaNumerator.div(feeIncrementNumerator);
}
function getFeeNumeratorOnRateLimiter(cliffFeeNumerator, referenceAmount, feeIncrementBps, inputAmount) {
  if (inputAmount.lte(referenceAmount)) {
    return cliffFeeNumerator;
  }
  const c = new BN7(cliffFeeNumerator);
  const diff = inputAmount.sub(referenceAmount);
  const a = new BN7(diff.div(referenceAmount));
  const b = new BN7(diff.mod(referenceAmount));
  const maxIndex = new BN7(getMaxIndex(cliffFeeNumerator, feeIncrementBps));
  const i = mulDiv(
    new BN7(feeIncrementBps),
    new BN7(FEE_DENOMINATOR),
    new BN7(BASIS_POINT_MAX),
    1 /* Down */
  );
  const x0 = new BN7(referenceAmount);
  const one = new BN7(1);
  const two = new BN7(2);
  let tradingFeeNumerator;
  if (a.lt(maxIndex)) {
    let numerator1 = c.add(c.mul(a)).add(i.mul(a).mul(a.add(one)).div(two));
    let numerator2 = c.add(i.mul(a.add(one)));
    let firstFee = x0.mul(numerator1);
    let secondFee = b.mul(numerator2);
    tradingFeeNumerator = firstFee.add(secondFee);
  } else {
    let numerator1 = c.add(c.mul(maxIndex)).add(i.mul(maxIndex).mul(maxIndex.add(one)).div(two));
    let numerator2 = new BN7(MAX_FEE_NUMERATOR);
    let firstFee = x0.mul(numerator1);
    let d = a.sub(maxIndex);
    let leftAmount = d.mul(x0).add(b);
    let secondFee = leftAmount.mul(numerator2);
    tradingFeeNumerator = firstFee.add(secondFee);
  }
  const denominator = new BN7(FEE_DENOMINATOR);
  const tradingFee = tradingFeeNumerator.add(denominator).sub(one).div(denominator);
  const feeNumerator = mulDiv(
    tradingFee,
    new BN7(FEE_DENOMINATOR),
    inputAmount,
    0 /* Up */
  );
  return BN7.min(feeNumerator, new BN7(MAX_FEE_NUMERATOR));
}

// src/helpers/validation.ts
function validatePoolFees(poolFees, collectFeeMode, activationType) {
  if (!poolFees) return false;
  if (poolFees.baseFee) {
    if (poolFees.baseFee.cliffFeeNumerator.lte(new BN8(0))) {
      return false;
    }
    if (poolFees.baseFee.baseFeeMode === 0 /* FeeSchedulerLinear */ || poolFees.baseFee.baseFeeMode === 1 /* FeeSchedulerExponential */) {
      if (!validateFeeScheduler(poolFees.baseFee)) {
        return false;
      }
    }
    if (poolFees.baseFee.baseFeeMode === 2 /* RateLimiter */) {
      if (!validateFeeRateLimiter(
        poolFees.baseFee,
        collectFeeMode,
        activationType
      )) {
        return false;
      }
    }
  }
  return true;
}
function validateFeeScheduler(feeScheduler) {
  if (!feeScheduler) return true;
  if (feeScheduler.firstFactor !== 0 || feeScheduler.secondFactor.gt(new BN8(0)) || feeScheduler.thirdFactor.gt(new BN8(0))) {
    if (feeScheduler.firstFactor === 0 || feeScheduler.secondFactor.eq(new BN8(0)) || feeScheduler.thirdFactor.eq(new BN8(0))) {
      return false;
    }
  }
  if (feeScheduler.cliffFeeNumerator.lte(new BN8(0))) {
    return false;
  }
  if (feeScheduler.baseFeeMode !== 0 /* FeeSchedulerLinear */ && feeScheduler.baseFeeMode !== 1 /* FeeSchedulerExponential */) {
    return false;
  }
  if (feeScheduler.baseFeeMode === 0 /* FeeSchedulerLinear */) {
    const finalFee = feeScheduler.cliffFeeNumerator.sub(
      feeScheduler.secondFactor.mul(new BN8(feeScheduler.firstFactor))
    );
    if (finalFee.lt(new BN8(0))) {
      return false;
    }
  }
  const minFeeNumerator = feeScheduler.cliffFeeNumerator.sub(
    feeScheduler.secondFactor.mul(new BN8(feeScheduler.firstFactor))
  );
  const maxFeeNumerator = feeScheduler.cliffFeeNumerator;
  if (minFeeNumerator.gte(new BN8(FEE_DENOMINATOR)) || maxFeeNumerator.gte(new BN8(FEE_DENOMINATOR))) {
    return false;
  }
  if (minFeeNumerator.lt(new BN8(MIN_FEE_NUMERATOR)) || maxFeeNumerator.gt(new BN8(MAX_FEE_NUMERATOR))) {
    return false;
  }
  return true;
}
function validateFeeRateLimiter(feeRateLimiter, collectFeeMode, activationType) {
  if (!feeRateLimiter) return true;
  if (collectFeeMode !== 0 /* OnlyQuote */) {
    return false;
  }
  if (!feeRateLimiter.firstFactor && !feeRateLimiter.secondFactor && !feeRateLimiter.thirdFactor) {
    return true;
  }
  if (!feeRateLimiter.firstFactor || !feeRateLimiter.secondFactor || !feeRateLimiter.thirdFactor) {
    return false;
  }
  const maxDuration = activationType === 0 /* Slot */ ? MAX_RATE_LIMITER_DURATION_IN_SLOTS : MAX_RATE_LIMITER_DURATION_IN_SECONDS;
  if (feeRateLimiter.secondFactor.gt(new BN8(maxDuration))) {
    return false;
  }
  const feeIncrementNumerator = bpsToFeeNumerator(feeRateLimiter.firstFactor);
  if (feeIncrementNumerator.gte(new BN8(FEE_DENOMINATOR))) {
    return false;
  }
  if (feeRateLimiter.cliffFeeNumerator.lt(new BN8(MIN_FEE_NUMERATOR)) || feeRateLimiter.cliffFeeNumerator.gt(new BN8(MAX_FEE_NUMERATOR))) {
    return false;
  }
  const minFeeNumerator = getFeeNumeratorOnRateLimiter(
    feeRateLimiter.cliffFeeNumerator,
    feeRateLimiter.thirdFactor,
    new BN8(feeRateLimiter.firstFactor),
    new BN8(0)
  );
  const maxFeeNumerator = getFeeNumeratorOnRateLimiter(
    feeRateLimiter.cliffFeeNumerator,
    feeRateLimiter.thirdFactor,
    new BN8(feeRateLimiter.firstFactor),
    new BN8(Number.MAX_SAFE_INTEGER)
  );
  if (minFeeNumerator.lt(new BN8(MIN_FEE_NUMERATOR)) || maxFeeNumerator.gt(new BN8(MAX_FEE_NUMERATOR))) {
    return false;
  }
  return true;
}
function validateCollectFeeMode(collectFeeMode) {
  return [0 /* OnlyQuote */, 1 /* Both */].includes(
    collectFeeMode
  );
}
function validateMigrationAndTokenType(migrationOption, tokenType) {
  if (migrationOption === 0 /* MET_DAMM */) {
    return tokenType === 0 /* SPL */;
  }
  return true;
}
function validateActivationType(activationType) {
  return [0 /* Slot */, 1 /* Timestamp */].includes(
    activationType
  );
}
function validateMigrationFeeOption(migrationFeeOption) {
  return [
    0 /* FixedBps25 */,
    1 /* FixedBps30 */,
    2 /* FixedBps100 */,
    3 /* FixedBps200 */,
    4 /* FixedBps400 */,
    5 /* FixedBps600 */
  ].includes(migrationFeeOption);
}
function validateTokenDecimals(tokenDecimal) {
  return tokenDecimal >= 6 /* SIX */ && tokenDecimal <= 9 /* NINE */;
}
function validateLPPercentages(partnerLpPercentage, partnerLockedLpPercentage, creatorLpPercentage, creatorLockedLpPercentage) {
  const totalLPPercentage = partnerLpPercentage + partnerLockedLpPercentage + creatorLpPercentage + creatorLockedLpPercentage;
  return totalLPPercentage === 100;
}
function validateCurve(curve, sqrtStartPrice) {
  if (!curve || curve.length === 0 || curve.length > MAX_CURVE_POINT) {
    return false;
  }
  if (curve[0]?.sqrtPrice.lte(sqrtStartPrice) || curve[0]?.liquidity.lte(new BN8(0)) || curve[0]?.sqrtPrice.gt(new BN8(MAX_SQRT_PRICE))) {
    return false;
  }
  for (let i = 1; i < curve.length; i++) {
    const currentPoint = curve[i];
    const previousPoint = curve[i - 1];
    if (!currentPoint || !previousPoint) {
      return false;
    }
    if (currentPoint.sqrtPrice.lte(previousPoint.sqrtPrice) || currentPoint.liquidity.lte(new BN8(0))) {
      return false;
    }
  }
  return !curve[curve.length - 1]?.sqrtPrice.gt(new BN8(MAX_SQRT_PRICE));
}
function validateTokenSupply(tokenSupply, leftoverReceiver, swapBaseAmount, migrationBaseAmount, lockedVesting, swapBaseAmountBuffer) {
  if (!tokenSupply) return true;
  if (!leftoverReceiver) {
    return false;
  }
  if (!(leftoverReceiver instanceof PublicKey5)) {
    return false;
  }
  if (leftoverReceiver.equals(PublicKey5.default)) {
    return false;
  }
  const minimumBaseSupplyWithBuffer = getTotalTokenSupply(
    swapBaseAmountBuffer,
    migrationBaseAmount,
    lockedVesting
  );
  const minimumBaseSupplyWithoutBuffer = getTotalTokenSupply(
    swapBaseAmount,
    migrationBaseAmount,
    lockedVesting
  );
  return !(minimumBaseSupplyWithoutBuffer.gt(
    new BN8(tokenSupply.postMigrationTokenSupply)
  ) || new BN8(tokenSupply.postMigrationTokenSupply).gt(
    new BN8(tokenSupply.preMigrationTokenSupply)
  ) || minimumBaseSupplyWithBuffer.gt(
    new BN8(tokenSupply.preMigrationTokenSupply)
  ));
}
function validateTokenUpdateAuthorityOptions(option) {
  return [
    0 /* Mutable */,
    1 /* Immutable */
  ].includes(option);
}
function validateConfigParameters(configParam) {
  if (!configParam.poolFees) {
    throw new Error("Pool fees are required");
  }
  if (!validatePoolFees(
    configParam.poolFees,
    configParam.collectFeeMode,
    configParam.activationType
  )) {
    throw new Error("Invalid pool fees");
  }
  if (!validateCollectFeeMode(configParam.collectFeeMode)) {
    throw new Error("Invalid collect fee mode");
  }
  if (!validateTokenUpdateAuthorityOptions(configParam.tokenUpdateAuthority)) {
    throw new Error("Invalid option for token update authority");
  }
  if (!validateMigrationAndTokenType(
    configParam.migrationOption,
    configParam.tokenType
  )) {
    throw new Error("Token type must be SPL for MeteoraDamm migration");
  }
  if (!validateActivationType(configParam.activationType)) {
    throw new Error("Invalid activation type");
  }
  if (!validateMigrationFeeOption(configParam.migrationFeeOption)) {
    throw new Error("Invalid migration fee option");
  }
  if (configParam.migrationFee.feePercentage < 0 || configParam.migrationFee.feePercentage > MAX_MIGRATION_FEE_PERCENTAGE) {
    throw new Error(
      `Migration fee percentage must be between 0 and ${MAX_MIGRATION_FEE_PERCENTAGE}`
    );
  }
  if (configParam.migrationFee.creatorFeePercentage < 0 || configParam.migrationFee.creatorFeePercentage > MAX_CREATOR_MIGRATION_FEE_PERCENTAGE) {
    throw new Error(
      `Creator fee percentage must be between 0 and ${MAX_CREATOR_MIGRATION_FEE_PERCENTAGE}`
    );
  }
  if (!validateTokenDecimals(configParam.tokenDecimal)) {
    throw new Error("Token decimal must be between 6 and 9");
  }
  if (!validateLPPercentages(
    configParam.partnerLpPercentage,
    configParam.partnerLockedLpPercentage,
    configParam.creatorLpPercentage,
    configParam.creatorLockedLpPercentage
  )) {
    throw new Error("Sum of LP percentages must equal 100");
  }
  if (configParam.migrationQuoteThreshold.lte(new BN8(0))) {
    throw new Error("Migration quote threshold must be greater than 0");
  }
  if (new BN8(configParam.sqrtStartPrice).lt(new BN8(MIN_SQRT_PRICE)) || new BN8(configParam.sqrtStartPrice).gte(new BN8(MAX_SQRT_PRICE))) {
    throw new Error("Invalid sqrt start price");
  }
  if (!validateCurve(configParam.curve, configParam.sqrtStartPrice)) {
    throw new Error("Invalid curve");
  }
  if (!isDefaultLockedVesting(configParam.lockedVesting)) {
    try {
      const totalAmount = configParam.lockedVesting.cliffUnlockAmount.add(
        configParam.lockedVesting.amountPerPeriod.mul(
          new BN8(configParam.lockedVesting.numberOfPeriod)
        )
      );
      if (configParam.lockedVesting.frequency.eq(new BN8(0)) || totalAmount.eq(new BN8(0))) {
        throw new Error("Invalid vesting parameters");
      }
    } catch (error) {
      throw new Error("Invalid vesting parameters");
    }
  }
  if (configParam.tokenSupply) {
    const sqrtMigrationPrice = getMigrationThresholdPrice(
      configParam.migrationQuoteThreshold,
      configParam.sqrtStartPrice,
      configParam.curve
    );
    const swapBaseAmount = getBaseTokenForSwap(
      configParam.sqrtStartPrice,
      sqrtMigrationPrice,
      configParam.curve
    );
    const migrationBaseAmount = getMigrationBaseToken(
      convertDecimalToBN(
        getMigrationQuoteAmountFromMigrationQuoteThreshold(
          new Decimal3(configParam.migrationQuoteThreshold.toString()),
          configParam.migrationFee.feePercentage
        )
      ),
      sqrtMigrationPrice,
      configParam.migrationOption
    );
    const swapBaseAmountBuffer = getSwapAmountWithBuffer(
      swapBaseAmount,
      configParam.sqrtStartPrice,
      configParam.curve
    );
    if (!validateTokenSupply(
      configParam.tokenSupply,
      new PublicKey5(configParam.leftoverReceiver),
      swapBaseAmount,
      migrationBaseAmount,
      configParam.lockedVesting,
      swapBaseAmountBuffer
    )) {
      throw new Error("Invalid token supply");
    }
  }
}
function validateBaseTokenType(baseTokenType, poolConfig) {
  return baseTokenType === poolConfig.tokenType;
}
async function validateBalance(connection, owner, inputMint, amountIn, inputTokenAccount) {
  const isSOLInput = isNativeSol(inputMint);
  if (isSOLInput) {
    const balance = await connection.getBalance(owner);
    const requiredBalance = BigInt(amountIn.toString()) + BigInt(1e7);
    if (balance < Number(requiredBalance)) {
      throw new Error(
        `Insufficient SOL balance. Required: ${requiredBalance.toString()} lamports, Found: ${balance} lamports`
      );
    }
  } else {
    try {
      const tokenBalance = await connection.getTokenAccountBalance(inputTokenAccount);
      const balance = new BN8(tokenBalance.value.amount);
      if (balance.lt(amountIn)) {
        throw new Error(
          `Insufficient token balance. Required: ${amountIn.toString()}, Found: ${balance.toString()}`
        );
      }
    } catch (error) {
      throw new Error(
        `Failed to fetch token balance or token account doesn't exist`
      );
    }
  }
  return true;
}
function validateSwapAmount(amountIn) {
  if (amountIn.lte(new BN8(0))) {
    throw new Error("Swap amount must be greater than 0");
  }
  return true;
}

// src/helpers/buildCurve.ts
import Decimal4 from "decimal.js";
import BN9 from "bn.js";
function buildCurve(buildCurveParam) {
  let {
    totalTokenSupply,
    percentageSupplyOnMigration,
    migrationQuoteThreshold,
    migrationOption,
    tokenBaseDecimal,
    tokenQuoteDecimal,
    dynamicFeeEnabled,
    activationType,
    collectFeeMode,
    migrationFeeOption,
    tokenType,
    partnerLpPercentage,
    creatorLpPercentage,
    partnerLockedLpPercentage,
    creatorLockedLpPercentage,
    creatorTradingFeePercentage,
    leftover,
    tokenUpdateAuthority,
    migrationFee,
    baseFeeParams
  } = buildCurveParam;
  const baseFee = getBaseFeeParams(
    baseFeeParams,
    tokenQuoteDecimal,
    activationType
  );
  const {
    totalLockedVestingAmount,
    numberOfVestingPeriod,
    cliffUnlockAmount,
    totalVestingDuration,
    cliffDurationFromMigrationTime
  } = buildCurveParam.lockedVestingParam;
  const lockedVesting = getLockedVestingParams(
    totalLockedVestingAmount,
    numberOfVestingPeriod,
    cliffUnlockAmount,
    totalVestingDuration,
    cliffDurationFromMigrationTime,
    tokenBaseDecimal
  );
  const migrationBaseSupply = new Decimal4(totalTokenSupply).mul(new Decimal4(percentageSupplyOnMigration)).div(new Decimal4(100));
  const totalSupply = convertToLamports(totalTokenSupply, tokenBaseDecimal);
  const migrationQuoteAmount = getMigrationQuoteAmountFromMigrationQuoteThreshold(
    new Decimal4(migrationQuoteThreshold),
    migrationFee.feePercentage
  );
  const migrationPrice = new Decimal4(migrationQuoteAmount.toString()).div(
    new Decimal4(migrationBaseSupply.toString())
  );
  let migrationQuoteThresholdInLamport = convertToLamports(
    migrationQuoteThreshold,
    tokenQuoteDecimal
  );
  const totalLeftover = convertToLamports(leftover, tokenBaseDecimal);
  const migrateSqrtPrice = getSqrtPriceFromPrice(
    migrationPrice.toString(),
    tokenBaseDecimal,
    tokenQuoteDecimal
  );
  let migrationQuoteAmountInLamport = fromDecimalToBN(
    migrationQuoteAmount.mul(new Decimal4(10 ** tokenQuoteDecimal))
  );
  const migrationBaseAmount = getMigrationBaseToken(
    migrationQuoteAmountInLamport,
    migrateSqrtPrice,
    migrationOption
  );
  const totalVestingAmount = getTotalVestingAmount(lockedVesting);
  const swapAmount = totalSupply.sub(migrationBaseAmount).sub(totalVestingAmount).sub(totalLeftover);
  const { sqrtStartPrice, curve } = getFirstCurve(
    migrateSqrtPrice,
    migrationBaseAmount,
    swapAmount,
    migrationQuoteThresholdInLamport,
    migrationFee.feePercentage
  );
  const totalDynamicSupply = getTotalSupplyFromCurve(
    migrationQuoteThresholdInLamport,
    sqrtStartPrice,
    curve,
    lockedVesting,
    migrationOption,
    totalLeftover,
    migrationFee.feePercentage
  );
  const remainingAmount = totalSupply.sub(totalDynamicSupply);
  const lastLiquidity = getInitialLiquidityFromDeltaBase(
    remainingAmount,
    MAX_SQRT_PRICE,
    migrateSqrtPrice
  );
  if (!lastLiquidity.isZero()) {
    curve.push({
      sqrtPrice: MAX_SQRT_PRICE,
      liquidity: lastLiquidity
    });
  }
  const instructionParams = {
    poolFees: {
      baseFee: {
        ...baseFee
      },
      dynamicFee: dynamicFeeEnabled ? getDynamicFeeParams(
        baseFeeParams.baseFeeMode === 2 /* RateLimiter */ ? baseFeeParams.rateLimiterParam.baseFeeBps : baseFeeParams.feeSchedulerParam.endingFeeBps
      ) : null
    },
    activationType,
    collectFeeMode,
    migrationOption,
    tokenType,
    tokenDecimal: tokenBaseDecimal,
    migrationQuoteThreshold: migrationQuoteThresholdInLamport,
    partnerLpPercentage,
    creatorLpPercentage,
    partnerLockedLpPercentage,
    creatorLockedLpPercentage,
    sqrtStartPrice,
    lockedVesting,
    migrationFeeOption,
    tokenSupply: {
      preMigrationTokenSupply: totalSupply,
      postMigrationTokenSupply: totalSupply
    },
    creatorTradingFeePercentage,
    tokenUpdateAuthority,
    migrationFee,
    padding0: [],
    padding1: [],
    curve
  };
  return instructionParams;
}
function buildCurveWithMarketCap(buildCurveWithMarketCapParam) {
  const {
    initialMarketCap,
    migrationMarketCap,
    totalTokenSupply,
    tokenBaseDecimal,
    migrationFee,
    leftover
  } = buildCurveWithMarketCapParam;
  const {
    totalLockedVestingAmount,
    numberOfVestingPeriod,
    cliffUnlockAmount,
    totalVestingDuration,
    cliffDurationFromMigrationTime
  } = buildCurveWithMarketCapParam.lockedVestingParam;
  const lockedVesting = getLockedVestingParams(
    totalLockedVestingAmount,
    numberOfVestingPeriod,
    cliffUnlockAmount,
    totalVestingDuration,
    cliffDurationFromMigrationTime,
    tokenBaseDecimal
  );
  const totalLeftover = convertToLamports(leftover, tokenBaseDecimal);
  const totalSupply = convertToLamports(totalTokenSupply, tokenBaseDecimal);
  const percentageSupplyOnMigration = getPercentageSupplyOnMigration(
    new Decimal4(initialMarketCap),
    new Decimal4(migrationMarketCap),
    lockedVesting,
    totalLeftover,
    totalSupply
  );
  const migrationQuoteAmount = getMigrationQuoteAmount(
    new Decimal4(migrationMarketCap),
    new Decimal4(percentageSupplyOnMigration)
  );
  const migrationQuoteThreshold = getMigrationQuoteThresholdFromMigrationQuoteAmount(
    migrationQuoteAmount,
    new Decimal4(migrationFee.feePercentage)
  ).toNumber();
  return buildCurve({
    ...buildCurveWithMarketCapParam,
    percentageSupplyOnMigration,
    migrationQuoteThreshold
  });
}
function buildCurveWithTwoSegments(buildCurveWithTwoSegmentsParam) {
  const {
    totalTokenSupply,
    initialMarketCap,
    migrationMarketCap,
    percentageSupplyOnMigration,
    migrationOption,
    tokenBaseDecimal,
    tokenQuoteDecimal,
    creatorTradingFeePercentage,
    collectFeeMode,
    leftover,
    tokenType,
    partnerLpPercentage,
    creatorLpPercentage,
    partnerLockedLpPercentage,
    creatorLockedLpPercentage,
    activationType,
    dynamicFeeEnabled,
    migrationFeeOption,
    migrationFee,
    tokenUpdateAuthority,
    baseFeeParams
  } = buildCurveWithTwoSegmentsParam;
  const baseFee = getBaseFeeParams(
    baseFeeParams,
    tokenQuoteDecimal,
    activationType
  );
  const {
    totalLockedVestingAmount,
    numberOfVestingPeriod,
    cliffUnlockAmount,
    totalVestingDuration,
    cliffDurationFromMigrationTime
  } = buildCurveWithTwoSegmentsParam.lockedVestingParam;
  const lockedVesting = getLockedVestingParams(
    totalLockedVestingAmount,
    numberOfVestingPeriod,
    cliffUnlockAmount,
    totalVestingDuration,
    cliffDurationFromMigrationTime,
    tokenBaseDecimal
  );
  let migrationBaseSupply = new BN9(totalTokenSupply).mul(new BN9(percentageSupplyOnMigration)).div(new BN9(100));
  let totalSupply = convertToLamports(totalTokenSupply, tokenBaseDecimal);
  let migrationQuoteAmount = getMigrationQuoteAmount(
    new Decimal4(migrationMarketCap),
    new Decimal4(percentageSupplyOnMigration)
  );
  let migrationQuoteThreshold = getMigrationQuoteThresholdFromMigrationQuoteAmount(
    migrationQuoteAmount,
    new Decimal4(migrationFee.feePercentage)
  );
  let migrationPrice = migrationQuoteAmount.div(
    new Decimal4(migrationBaseSupply.toString())
  );
  let migrationQuoteThresholdInLamport = fromDecimalToBN(
    migrationQuoteThreshold.mul(new Decimal4(10 ** tokenQuoteDecimal))
  );
  let migrationQuoteAmountInLamport = fromDecimalToBN(
    migrationQuoteAmount.mul(new Decimal4(10 ** tokenQuoteDecimal))
  );
  let migrateSqrtPrice = getSqrtPriceFromPrice(
    migrationPrice.toString(),
    tokenBaseDecimal,
    tokenQuoteDecimal
  );
  let migrationBaseAmount = getMigrationBaseToken(
    migrationQuoteAmountInLamport,
    migrateSqrtPrice,
    migrationOption
  );
  let totalVestingAmount = getTotalVestingAmount(lockedVesting);
  let totalLeftover = convertToLamports(leftover, tokenBaseDecimal);
  let swapAmount = totalSupply.sub(migrationBaseAmount).sub(totalVestingAmount).sub(totalLeftover);
  let initialSqrtPrice = getSqrtPriceFromMarketCap(
    initialMarketCap,
    totalTokenSupply,
    tokenBaseDecimal,
    tokenQuoteDecimal
  );
  let midSqrtPriceDecimal1 = new Decimal4(migrateSqrtPrice.toString()).mul(new Decimal4(initialSqrtPrice.toString())).sqrt();
  let midSqrtPrice1 = new BN9(midSqrtPriceDecimal1.floor().toFixed());
  let numerator1 = new Decimal4(initialSqrtPrice.toString());
  let numerator2 = Decimal4.pow(migrateSqrtPrice.toString(), 3);
  let product1 = numerator1.mul(numerator2);
  let midSqrtPriceDecimal2 = Decimal4.pow(product1, 0.25);
  let midSqrtPrice2 = new BN9(midSqrtPriceDecimal2.floor().toFixed());
  let numerator3 = Decimal4.pow(initialSqrtPrice.toString(), 3);
  let numerator4 = new Decimal4(migrateSqrtPrice.toString());
  let product2 = numerator3.mul(numerator4);
  let midSqrtPriceDecimal3 = Decimal4.pow(product2, 0.25);
  let midSqrtPrice3 = new BN9(midSqrtPriceDecimal3.floor().toFixed());
  let midPrices = [midSqrtPrice1, midSqrtPrice2, midSqrtPrice3];
  let sqrtStartPrice = new BN9(0);
  let curve = [];
  for (let i = 0; i < midPrices.length; i++) {
    const result = getTwoCurve(
      migrateSqrtPrice,
      midPrices[i],
      initialSqrtPrice,
      swapAmount,
      migrationQuoteThresholdInLamport
    );
    if (result.isOk) {
      curve = result.curve;
      sqrtStartPrice = result.sqrtStartPrice;
      break;
    }
  }
  let totalDynamicSupply = getTotalSupplyFromCurve(
    migrationQuoteThresholdInLamport,
    sqrtStartPrice,
    curve,
    lockedVesting,
    migrationOption,
    totalLeftover,
    migrationFee.feePercentage
  );
  if (totalDynamicSupply.gt(totalSupply)) {
    let leftOverDelta = totalDynamicSupply.sub(totalSupply);
    if (!leftOverDelta.lt(totalLeftover)) {
      throw new Error("leftOverDelta must be less than totalLeftover");
    }
  }
  const instructionParams = {
    poolFees: {
      baseFee: {
        ...baseFee
      },
      dynamicFee: dynamicFeeEnabled ? getDynamicFeeParams(
        baseFeeParams.baseFeeMode === 2 /* RateLimiter */ ? baseFeeParams.rateLimiterParam.baseFeeBps : baseFeeParams.feeSchedulerParam.endingFeeBps
      ) : null
    },
    activationType,
    collectFeeMode,
    migrationOption,
    tokenType,
    tokenDecimal: tokenBaseDecimal,
    migrationQuoteThreshold: migrationQuoteThresholdInLamport,
    partnerLpPercentage,
    creatorLpPercentage,
    partnerLockedLpPercentage,
    creatorLockedLpPercentage,
    sqrtStartPrice,
    lockedVesting,
    migrationFeeOption,
    tokenSupply: {
      preMigrationTokenSupply: totalSupply,
      postMigrationTokenSupply: totalSupply
    },
    creatorTradingFeePercentage,
    padding0: [],
    padding1: [],
    curve,
    tokenUpdateAuthority,
    migrationFee
  };
  return instructionParams;
}
function buildCurveWithLiquidityWeights(buildCurveWithLiquidityWeightsParam) {
  let {
    totalTokenSupply,
    migrationOption,
    tokenBaseDecimal,
    tokenQuoteDecimal,
    dynamicFeeEnabled,
    activationType,
    collectFeeMode,
    migrationFeeOption,
    tokenType,
    partnerLpPercentage,
    creatorLpPercentage,
    partnerLockedLpPercentage,
    creatorLockedLpPercentage,
    creatorTradingFeePercentage,
    leftover,
    initialMarketCap,
    migrationMarketCap,
    liquidityWeights,
    migrationFee,
    tokenUpdateAuthority,
    baseFeeParams
  } = buildCurveWithLiquidityWeightsParam;
  const baseFee = getBaseFeeParams(
    baseFeeParams,
    tokenQuoteDecimal,
    activationType
  );
  const {
    totalLockedVestingAmount,
    numberOfVestingPeriod,
    cliffUnlockAmount,
    totalVestingDuration,
    cliffDurationFromMigrationTime
  } = buildCurveWithLiquidityWeightsParam.lockedVestingParam;
  const lockedVesting = getLockedVestingParams(
    totalLockedVestingAmount,
    numberOfVestingPeriod,
    cliffUnlockAmount,
    totalVestingDuration,
    cliffDurationFromMigrationTime,
    tokenBaseDecimal
  );
  let pMin = getSqrtPriceFromMarketCap(
    initialMarketCap,
    totalTokenSupply,
    tokenBaseDecimal,
    tokenQuoteDecimal
  );
  let pMax = getSqrtPriceFromMarketCap(
    migrationMarketCap,
    totalTokenSupply,
    tokenBaseDecimal,
    tokenQuoteDecimal
  );
  let priceRatio = new Decimal4(pMax.toString()).div(
    new Decimal4(pMin.toString())
  );
  let qDecimal = priceRatio.pow(new Decimal4(1).div(new Decimal4(16)));
  let sqrtPrices = [];
  let currentPrice = pMin;
  for (let i = 0; i < 17; i++) {
    sqrtPrices.push(currentPrice);
    currentPrice = convertDecimalToBN(
      qDecimal.mul(new Decimal4(currentPrice.toString()))
    );
  }
  let totalSupply = convertToLamports(totalTokenSupply, tokenBaseDecimal);
  let totalLeftover = convertToLamports(leftover, tokenBaseDecimal);
  let totalVestingAmount = getTotalVestingAmount(lockedVesting);
  let totalSwapAndMigrationAmount = totalSupply.sub(totalVestingAmount).sub(totalLeftover);
  let sumFactor = new Decimal4(0);
  let pmaxWeight = new Decimal4(pMax.toString());
  let migrationFeeFactor = new Decimal4(100).sub(new Decimal4(migrationFee.feePercentage)).div(new Decimal4(100));
  for (let i = 1; i < 17; i++) {
    let pi = new Decimal4(sqrtPrices[i].toString());
    let piMinus = new Decimal4(sqrtPrices[i - 1].toString());
    let k = new Decimal4(liquidityWeights[i - 1]);
    let w1 = pi.sub(piMinus).div(pi.mul(piMinus));
    let w2 = pi.sub(piMinus).mul(migrationFeeFactor).div(pmaxWeight.mul(pmaxWeight));
    let weight = k.mul(w1.add(w2));
    sumFactor = sumFactor.add(weight);
  }
  let l1 = new Decimal4(totalSwapAndMigrationAmount.toString()).div(sumFactor);
  let curve = [];
  for (let i = 0; i < 16; i++) {
    let k = new Decimal4(liquidityWeights[i]);
    let liquidity = convertDecimalToBN(l1.mul(k));
    let sqrtPrice = i < 15 ? sqrtPrices[i + 1] : pMax;
    curve.push({
      sqrtPrice,
      liquidity
    });
  }
  let swapBaseAmount = getBaseTokenForSwap(pMin, pMax, curve);
  let swapBaseAmountBuffer = getSwapAmountWithBuffer(
    swapBaseAmount,
    pMin,
    curve
  );
  let migrationAmount = totalSwapAndMigrationAmount.sub(swapBaseAmountBuffer);
  let migrationQuoteAmount = migrationAmount.mul(pMax).mul(pMax).shrn(128);
  let migrationQuoteThreshold = getMigrationQuoteThresholdFromMigrationQuoteAmount(
    new Decimal4(migrationQuoteAmount.toString()),
    new Decimal4(migrationFee.feePercentage)
  );
  let migrationQuoteThresholdInLamport = fromDecimalToBN(
    migrationQuoteThreshold
  );
  let totalDynamicSupply = getTotalSupplyFromCurve(
    migrationQuoteThresholdInLamport,
    pMin,
    curve,
    lockedVesting,
    migrationOption,
    totalLeftover,
    migrationFee.feePercentage
  );
  if (totalDynamicSupply.gt(totalSupply)) {
    let leftOverDelta = totalDynamicSupply.sub(totalSupply);
    if (!leftOverDelta.lt(totalLeftover)) {
      throw new Error("leftOverDelta must be less than totalLeftover");
    }
  }
  const instructionParams = {
    poolFees: {
      baseFee: {
        ...baseFee
      },
      dynamicFee: dynamicFeeEnabled ? getDynamicFeeParams(
        baseFeeParams.baseFeeMode === 2 /* RateLimiter */ ? baseFeeParams.rateLimiterParam.baseFeeBps : baseFeeParams.feeSchedulerParam.endingFeeBps
      ) : null
    },
    activationType,
    collectFeeMode,
    migrationOption,
    tokenType,
    tokenDecimal: tokenBaseDecimal,
    migrationQuoteThreshold: migrationQuoteThresholdInLamport,
    partnerLpPercentage,
    creatorLpPercentage,
    partnerLockedLpPercentage,
    creatorLockedLpPercentage,
    sqrtStartPrice: pMin,
    lockedVesting,
    migrationFeeOption,
    tokenSupply: {
      preMigrationTokenSupply: totalSupply,
      postMigrationTokenSupply: totalSupply
    },
    creatorTradingFeePercentage,
    padding0: [],
    padding1: [],
    curve,
    migrationFee,
    tokenUpdateAuthority
  };
  return instructionParams;
}

// src/helpers/createProgram.ts
import { AnchorProvider, Program } from "@coral-xyz/anchor";

// src/idl/dynamic-bonding-curve/idl.json
var idl_default = {
  address: "dbcij3LWUppWqq96dh6gJWwBifmcGfLSB5D4DuSMaqN",
  metadata: {
    name: "dynamic_bonding_curve",
    version: "0.1.2",
    spec: "0.1.0",
    description: "Created with Anchor"
  },
  instructions: [
    {
      name: "claim_creator_trading_fee",
      discriminator: [
        82,
        220,
        250,
        189,
        3,
        85,
        107,
        45
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The treasury token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The treasury token b account"
          ],
          writable: true
        },
        {
          name: "base_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "quote_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "base_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of token b"
          ]
        },
        {
          name: "creator",
          signer: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_base_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_quote_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "max_base_amount",
          type: "u64"
        },
        {
          name: "max_quote_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "claim_protocol_fee",
      discriminator: [
        165,
        228,
        133,
        48,
        99,
        249,
        255,
        33
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "config",
          relations: [
            "pool"
          ]
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "base_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "quote_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "base_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "config"
          ]
        },
        {
          name: "token_base_account",
          docs: [
            "The treasury token a account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  48,
                  9,
                  89,
                  123,
                  106,
                  114,
                  131,
                  251,
                  50,
                  173,
                  254,
                  250,
                  10,
                  80,
                  160,
                  84,
                  143,
                  100,
                  81,
                  249,
                  134,
                  112,
                  30,
                  213,
                  50,
                  166,
                  239,
                  78,
                  53,
                  175,
                  188,
                  85
                ]
              },
              {
                kind: "account",
                path: "token_base_program"
              },
              {
                kind: "account",
                path: "base_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "token_quote_account",
          docs: [
            "The treasury token b account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  48,
                  9,
                  89,
                  123,
                  106,
                  114,
                  131,
                  251,
                  50,
                  173,
                  254,
                  250,
                  10,
                  80,
                  160,
                  84,
                  143,
                  100,
                  81,
                  249,
                  134,
                  112,
                  30,
                  213,
                  50,
                  166,
                  239,
                  78,
                  53,
                  175,
                  188,
                  85
                ]
              },
              {
                kind: "account",
                path: "token_quote_program"
              },
              {
                kind: "account",
                path: "quote_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "claim_fee_operator",
          docs: [
            "Claim fee operator"
          ]
        },
        {
          name: "operator",
          docs: [
            "Operator"
          ],
          signer: true,
          relations: [
            "claim_fee_operator"
          ]
        },
        {
          name: "token_base_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_quote_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "claim_trading_fee",
      discriminator: [
        8,
        236,
        89,
        49,
        152,
        125,
        177,
        81
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "config",
          relations: [
            "pool"
          ]
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The treasury token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The treasury token b account"
          ],
          writable: true
        },
        {
          name: "base_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "quote_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "base_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "config"
          ]
        },
        {
          name: "fee_claimer",
          signer: true,
          relations: [
            "config"
          ]
        },
        {
          name: "token_base_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_quote_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "max_amount_a",
          type: "u64"
        },
        {
          name: "max_amount_b",
          type: "u64"
        }
      ]
    },
    {
      name: "close_claim_fee_operator",
      discriminator: [
        38,
        134,
        82,
        216,
        95,
        124,
        17,
        99
      ],
      accounts: [
        {
          name: "claim_fee_operator",
          writable: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "create_claim_fee_operator",
      docs: [
        "ADMIN FUNCTIONS ///"
      ],
      discriminator: [
        169,
        62,
        207,
        107,
        58,
        187,
        162,
        109
      ],
      accounts: [
        {
          name: "claim_fee_operator",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  102,
                  95,
                  111,
                  112,
                  101,
                  114,
                  97,
                  116,
                  111,
                  114
                ]
              },
              {
                kind: "account",
                path: "operator"
              }
            ]
          }
        },
        {
          name: "operator"
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "create_config",
      discriminator: [
        201,
        207,
        243,
        114,
        75,
        111,
        47,
        189
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          signer: true
        },
        {
          name: "fee_claimer"
        },
        {
          name: "leftover_receiver"
        },
        {
          name: "quote_mint",
          docs: [
            "quote mint"
          ]
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "config_parameters",
          type: {
            defined: {
              name: "ConfigParameters"
            }
          }
        }
      ]
    },
    {
      name: "create_locker",
      docs: [
        "PERMISSIONLESS FUNCTIONS ///",
        "create locker"
      ],
      discriminator: [
        167,
        90,
        137,
        154,
        75,
        47,
        17,
        84
      ],
      accounts: [
        {
          name: "virtual_pool",
          docs: [
            "Virtual pool"
          ],
          writable: true
        },
        {
          name: "config",
          docs: [
            "Config"
          ],
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "pool_authority",
          writable: true,
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "base_vault",
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "base_mint",
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "base",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  98,
                  97,
                  115,
                  101,
                  95,
                  108,
                  111,
                  99,
                  107,
                  101,
                  114
                ]
              },
              {
                kind: "account",
                path: "virtual_pool"
              }
            ]
          }
        },
        {
          name: "creator",
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "escrow",
          writable: true
        },
        {
          name: "escrow_token",
          writable: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "locker_program",
          address: "LocpQgucEQHbqNABEYvBvwoxCPsSbG91A1QaQhQQqjn"
        },
        {
          name: "locker_event_authority"
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "create_partner_metadata",
      docs: [
        "PARTNER FUNCTIONS ////"
      ],
      discriminator: [
        192,
        168,
        234,
        191,
        188,
        226,
        227,
        255
      ],
      accounts: [
        {
          name: "partner_metadata",
          docs: [
            "Partner metadata"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  97,
                  114,
                  116,
                  110,
                  101,
                  114,
                  95,
                  109,
                  101,
                  116,
                  97,
                  100,
                  97,
                  116,
                  97
                ]
              },
              {
                kind: "account",
                path: "fee_claimer"
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Payer of the partner metadata."
          ],
          writable: true,
          signer: true
        },
        {
          name: "fee_claimer",
          docs: [
            "Fee claimer for partner"
          ],
          signer: true
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "metadata",
          type: {
            defined: {
              name: "CreatePartnerMetadataParameters"
            }
          }
        }
      ]
    },
    {
      name: "create_virtual_pool_metadata",
      discriminator: [
        45,
        97,
        187,
        103,
        254,
        109,
        124,
        134
      ],
      accounts: [
        {
          name: "virtual_pool",
          writable: true
        },
        {
          name: "virtual_pool_metadata",
          docs: [
            "Virtual pool metadata"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  118,
                  105,
                  114,
                  116,
                  117,
                  97,
                  108,
                  95,
                  112,
                  111,
                  111,
                  108,
                  95,
                  109,
                  101,
                  116,
                  97,
                  100,
                  97,
                  116,
                  97
                ]
              },
              {
                kind: "account",
                path: "virtual_pool"
              }
            ]
          }
        },
        {
          name: "creator",
          signer: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "payer",
          docs: [
            "Payer of the virtual pool metadata."
          ],
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "metadata",
          type: {
            defined: {
              name: "CreateVirtualPoolMetadataParameters"
            }
          }
        }
      ]
    },
    {
      name: "creator_withdraw_surplus",
      discriminator: [
        165,
        3,
        137,
        7,
        28,
        134,
        76,
        80
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "config",
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "virtual_pool",
          writable: true
        },
        {
          name: "token_quote_account",
          docs: [
            "The receiver token account"
          ],
          writable: true
        },
        {
          name: "quote_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of quote token"
          ],
          relations: [
            "config"
          ]
        },
        {
          name: "creator",
          signer: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "token_quote_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "initialize_virtual_pool_with_spl_token",
      docs: [
        "POOL CREATOR FUNCTIONS ////"
      ],
      discriminator: [
        140,
        85,
        215,
        176,
        102,
        54,
        104,
        79
      ],
      accounts: [
        {
          name: "config",
          docs: [
            "Which config the pool belongs to."
          ]
        },
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "creator",
          signer: true
        },
        {
          name: "base_mint",
          writable: true,
          signer: true
        },
        {
          name: "quote_mint",
          relations: [
            "config"
          ]
        },
        {
          name: "pool",
          docs: [
            "Initialize an account to store the pool state"
          ],
          writable: true
        },
        {
          name: "base_vault",
          docs: [
            "Token a vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "base_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "quote_vault",
          docs: [
            "Token b vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "quote_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "mint_metadata",
          writable: true
        },
        {
          name: "metadata_program",
          address: "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the pool. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "token_quote_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_program",
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializePoolParameters"
            }
          }
        }
      ]
    },
    {
      name: "initialize_virtual_pool_with_token2022",
      discriminator: [
        169,
        118,
        51,
        78,
        145,
        110,
        220,
        155
      ],
      accounts: [
        {
          name: "config",
          docs: [
            "Which config the pool belongs to."
          ]
        },
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "creator",
          signer: true
        },
        {
          name: "base_mint",
          docs: [
            "Unique token mint address, initialize in contract"
          ],
          writable: true,
          signer: true
        },
        {
          name: "quote_mint",
          relations: [
            "config"
          ]
        },
        {
          name: "pool",
          docs: [
            "Initialize an account to store the pool state"
          ],
          writable: true
        },
        {
          name: "base_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "base_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "quote_vault",
          docs: [
            "Token quote vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "quote_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the pool. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "token_quote_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_program",
          docs: [
            "token program for base mint"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializePoolParameters"
            }
          }
        }
      ]
    },
    {
      name: "migrate_meteora_damm",
      discriminator: [
        27,
        1,
        48,
        22,
        180,
        63,
        118,
        217
      ],
      accounts: [
        {
          name: "virtual_pool",
          docs: [
            "virtual pool"
          ],
          writable: true,
          relations: [
            "migration_metadata"
          ]
        },
        {
          name: "migration_metadata",
          writable: true
        },
        {
          name: "config",
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "pool_authority",
          writable: true,
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "damm_config",
          docs: [
            "pool config"
          ]
        },
        {
          name: "lp_mint",
          writable: true
        },
        {
          name: "token_a_mint",
          writable: true
        },
        {
          name: "token_b_mint"
        },
        {
          name: "a_vault",
          writable: true
        },
        {
          name: "b_vault",
          writable: true
        },
        {
          name: "a_token_vault",
          writable: true
        },
        {
          name: "b_token_vault",
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          writable: true
        },
        {
          name: "a_vault_lp",
          writable: true
        },
        {
          name: "b_vault_lp",
          writable: true
        },
        {
          name: "base_vault",
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "quote_vault",
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "virtual_pool_lp",
          writable: true
        },
        {
          name: "protocol_token_a_fee",
          writable: true
        },
        {
          name: "protocol_token_b_fee",
          writable: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "rent"
        },
        {
          name: "mint_metadata",
          writable: true
        },
        {
          name: "metadata_program"
        },
        {
          name: "amm_program",
          address: "Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"
        },
        {
          name: "vault_program"
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "associated_token_program"
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "migrate_meteora_damm_claim_lp_token",
      discriminator: [
        139,
        133,
        2,
        30,
        91,
        145,
        127,
        154
      ],
      accounts: [
        {
          name: "virtual_pool",
          relations: [
            "migration_metadata"
          ]
        },
        {
          name: "migration_metadata",
          docs: [
            "migration metadata"
          ],
          writable: true
        },
        {
          name: "pool_authority",
          writable: true,
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "lp_mint",
          relations: [
            "migration_metadata"
          ]
        },
        {
          name: "source_token",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "pool_authority"
              },
              {
                kind: "const",
                value: [
                  6,
                  221,
                  246,
                  225,
                  215,
                  101,
                  161,
                  147,
                  217,
                  203,
                  225,
                  70,
                  206,
                  235,
                  121,
                  172,
                  28,
                  180,
                  133,
                  237,
                  95,
                  91,
                  55,
                  145,
                  58,
                  140,
                  245,
                  133,
                  126,
                  255,
                  0,
                  169
                ]
              },
              {
                kind: "account",
                path: "migration_metadata"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "destination_token",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "owner"
              },
              {
                kind: "const",
                value: [
                  6,
                  221,
                  246,
                  225,
                  215,
                  101,
                  161,
                  147,
                  217,
                  203,
                  225,
                  70,
                  206,
                  235,
                  121,
                  172,
                  28,
                  180,
                  133,
                  237,
                  95,
                  91,
                  55,
                  145,
                  58,
                  140,
                  245,
                  133,
                  126,
                  255,
                  0,
                  169
                ]
              },
              {
                kind: "account",
                path: "migration_metadata"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "owner"
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      args: []
    },
    {
      name: "migrate_meteora_damm_lock_lp_token",
      discriminator: [
        177,
        55,
        238,
        157,
        251,
        88,
        165,
        42
      ],
      accounts: [
        {
          name: "virtual_pool",
          relations: [
            "migration_metadata"
          ]
        },
        {
          name: "migration_metadata",
          docs: [
            "migration_metadata"
          ],
          writable: true
        },
        {
          name: "pool_authority",
          writable: true,
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "lock_escrow"
          ]
        },
        {
          name: "lp_mint",
          relations: [
            "migration_metadata"
          ]
        },
        {
          name: "lock_escrow",
          writable: true
        },
        {
          name: "owner",
          relations: [
            "lock_escrow"
          ]
        },
        {
          name: "source_tokens",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "pool_authority"
              },
              {
                kind: "const",
                value: [
                  6,
                  221,
                  246,
                  225,
                  215,
                  101,
                  161,
                  147,
                  217,
                  203,
                  225,
                  70,
                  206,
                  235,
                  121,
                  172,
                  28,
                  180,
                  133,
                  237,
                  95,
                  91,
                  55,
                  145,
                  58,
                  140,
                  245,
                  133,
                  126,
                  255,
                  0,
                  169
                ]
              },
              {
                kind: "account",
                path: "migration_metadata"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "escrow_vault",
          writable: true
        },
        {
          name: "amm_program",
          address: "Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB"
        },
        {
          name: "a_vault"
        },
        {
          name: "b_vault"
        },
        {
          name: "a_vault_lp"
        },
        {
          name: "b_vault_lp"
        },
        {
          name: "a_vault_lp_mint"
        },
        {
          name: "b_vault_lp_mint"
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      args: []
    },
    {
      name: "migration_damm_v2",
      discriminator: [
        156,
        169,
        230,
        103,
        53,
        228,
        80,
        64
      ],
      accounts: [
        {
          name: "virtual_pool",
          docs: [
            "virtual pool"
          ],
          writable: true,
          relations: [
            "migration_metadata"
          ]
        },
        {
          name: "migration_metadata",
          docs: [
            "migration metadata"
          ]
        },
        {
          name: "config",
          docs: [
            "virtual pool config key"
          ],
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "pool_authority",
          writable: true,
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "first_position_nft_mint",
          writable: true
        },
        {
          name: "first_position_nft_account",
          writable: true
        },
        {
          name: "first_position",
          writable: true
        },
        {
          name: "second_position_nft_mint",
          writable: true,
          optional: true
        },
        {
          name: "second_position_nft_account",
          writable: true,
          optional: true
        },
        {
          name: "second_position",
          writable: true,
          optional: true
        },
        {
          name: "damm_pool_authority"
        },
        {
          name: "amm_program",
          address: "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG"
        },
        {
          name: "base_mint",
          writable: true
        },
        {
          name: "quote_mint",
          writable: true
        },
        {
          name: "token_a_vault",
          writable: true
        },
        {
          name: "token_b_vault",
          writable: true
        },
        {
          name: "base_vault",
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "quote_vault",
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "token_base_program"
        },
        {
          name: "token_quote_program"
        },
        {
          name: "token_2022_program"
        },
        {
          name: "damm_event_authority"
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      args: []
    },
    {
      name: "migration_damm_v2_create_metadata",
      discriminator: [
        109,
        189,
        19,
        36,
        195,
        183,
        222,
        82
      ],
      accounts: [
        {
          name: "virtual_pool"
        },
        {
          name: "config",
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "migration_metadata",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  100,
                  97,
                  109,
                  109,
                  95,
                  118,
                  50
                ]
              },
              {
                kind: "account",
                path: "virtual_pool"
              }
            ]
          }
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "migration_meteora_damm_create_metadata",
      docs: [
        "migrate damm v1"
      ],
      discriminator: [
        47,
        94,
        126,
        115,
        221,
        226,
        194,
        133
      ],
      accounts: [
        {
          name: "virtual_pool"
        },
        {
          name: "config",
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "migration_metadata",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  101,
                  116,
                  101,
                  111,
                  114,
                  97
                ]
              },
              {
                kind: "account",
                path: "virtual_pool"
              }
            ]
          }
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "partner_withdraw_surplus",
      discriminator: [
        168,
        173,
        72,
        100,
        201,
        98,
        38,
        92
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "config",
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "virtual_pool",
          writable: true
        },
        {
          name: "token_quote_account",
          docs: [
            "The receiver token account"
          ],
          writable: true
        },
        {
          name: "quote_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of quote token"
          ],
          relations: [
            "config"
          ]
        },
        {
          name: "fee_claimer",
          signer: true,
          relations: [
            "config"
          ]
        },
        {
          name: "token_quote_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "protocol_withdraw_surplus",
      discriminator: [
        54,
        136,
        225,
        138,
        172,
        182,
        214,
        167
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "config",
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "virtual_pool",
          writable: true
        },
        {
          name: "token_quote_account",
          docs: [
            "The treasury quote token account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  48,
                  9,
                  89,
                  123,
                  106,
                  114,
                  131,
                  251,
                  50,
                  173,
                  254,
                  250,
                  10,
                  80,
                  160,
                  84,
                  143,
                  100,
                  81,
                  249,
                  134,
                  112,
                  30,
                  213,
                  50,
                  166,
                  239,
                  78,
                  53,
                  175,
                  188,
                  85
                ]
              },
              {
                kind: "account",
                path: "token_quote_program"
              },
              {
                kind: "account",
                path: "quote_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "quote_vault",
          docs: [
            "The vault token account for quote token"
          ],
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of of token"
          ],
          relations: [
            "config"
          ]
        },
        {
          name: "token_quote_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "swap",
      docs: [
        "TRADING BOTS FUNCTIONS ////"
      ],
      discriminator: [
        248,
        198,
        158,
        145,
        225,
        117,
        135,
        200
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "config",
          docs: [
            "config key"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "pool",
          docs: [
            "Pool account"
          ],
          writable: true
        },
        {
          name: "input_token_account",
          docs: [
            "The user token account for input token"
          ],
          writable: true
        },
        {
          name: "output_token_account",
          docs: [
            "The user token account for output token"
          ],
          writable: true
        },
        {
          name: "base_vault",
          docs: [
            "The vault token account for base token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "quote_vault",
          docs: [
            "The vault token account for quote token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "base_mint",
          docs: [
            "The mint of base token"
          ]
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of quote token"
          ]
        },
        {
          name: "payer",
          docs: [
            "The user performing the swap"
          ],
          signer: true
        },
        {
          name: "token_base_program",
          docs: [
            "Token base program"
          ]
        },
        {
          name: "token_quote_program",
          docs: [
            "Token quote program"
          ]
        },
        {
          name: "referral_token_account",
          docs: [
            "referral token account"
          ],
          writable: true,
          optional: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "SwapParameters"
            }
          }
        }
      ]
    },
    {
      name: "transfer_pool_creator",
      discriminator: [
        20,
        7,
        169,
        33,
        58,
        147,
        166,
        33
      ],
      accounts: [
        {
          name: "virtual_pool",
          writable: true
        },
        {
          name: "config",
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "creator",
          signer: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "new_creator"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "withdraw_leftover",
      discriminator: [
        20,
        198,
        202,
        237,
        235,
        243,
        183,
        66
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "config",
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "virtual_pool",
          writable: true
        },
        {
          name: "token_base_account",
          docs: [
            "The receiver token account, withdraw to ATA"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "account",
                path: "leftover_receiver"
              },
              {
                kind: "account",
                path: "token_base_program"
              },
              {
                kind: "account",
                path: "base_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "base_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "base_mint",
          docs: [
            "The mint of quote token"
          ],
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "leftover_receiver",
          relations: [
            "config"
          ]
        },
        {
          name: "token_base_program",
          docs: [
            "Token base program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "withdraw_migration_fee",
      docs: [
        "BOTH partner and creator FUNCTIONS ///"
      ],
      discriminator: [
        237,
        142,
        45,
        23,
        129,
        6,
        222,
        162
      ],
      accounts: [
        {
          name: "pool_authority",
          address: "FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM"
        },
        {
          name: "config",
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "virtual_pool",
          writable: true
        },
        {
          name: "token_quote_account",
          docs: [
            "The receiver token account"
          ],
          writable: true
        },
        {
          name: "quote_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "virtual_pool"
          ]
        },
        {
          name: "quote_mint",
          docs: [
            "The mint of quote token"
          ],
          relations: [
            "config"
          ]
        },
        {
          name: "sender",
          signer: true
        },
        {
          name: "token_quote_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "flag",
          type: "u8"
        }
      ]
    }
  ],
  accounts: [
    {
      name: "ClaimFeeOperator",
      discriminator: [
        166,
        48,
        134,
        86,
        34,
        200,
        188,
        150
      ]
    },
    {
      name: "Config",
      discriminator: [
        155,
        12,
        170,
        224,
        30,
        250,
        204,
        130
      ]
    },
    {
      name: "LockEscrow",
      discriminator: [
        190,
        106,
        121,
        6,
        200,
        182,
        21,
        75
      ]
    },
    {
      name: "MeteoraDammMigrationMetadata",
      discriminator: [
        17,
        155,
        141,
        215,
        207,
        4,
        133,
        156
      ]
    },
    {
      name: "MeteoraDammV2Metadata",
      discriminator: [
        104,
        221,
        219,
        203,
        10,
        142,
        250,
        163
      ]
    },
    {
      name: "PartnerMetadata",
      discriminator: [
        68,
        68,
        130,
        19,
        16,
        209,
        98,
        156
      ]
    },
    {
      name: "PoolConfig",
      discriminator: [
        26,
        108,
        14,
        123,
        116,
        230,
        129,
        43
      ]
    },
    {
      name: "VirtualPool",
      discriminator: [
        213,
        224,
        5,
        209,
        98,
        69,
        119,
        92
      ]
    },
    {
      name: "VirtualPoolMetadata",
      discriminator: [
        217,
        37,
        82,
        250,
        43,
        47,
        228,
        254
      ]
    }
  ],
  events: [
    {
      name: "EvtClaimCreatorTradingFee",
      discriminator: [
        154,
        228,
        215,
        202,
        133,
        155,
        214,
        138
      ]
    },
    {
      name: "EvtClaimProtocolFee",
      discriminator: [
        186,
        244,
        75,
        251,
        188,
        13,
        25,
        33
      ]
    },
    {
      name: "EvtClaimTradingFee",
      discriminator: [
        26,
        83,
        117,
        240,
        92,
        202,
        112,
        254
      ]
    },
    {
      name: "EvtCloseClaimFeeOperator",
      discriminator: [
        111,
        39,
        37,
        55,
        110,
        216,
        194,
        23
      ]
    },
    {
      name: "EvtCreateClaimFeeOperator",
      discriminator: [
        21,
        6,
        153,
        120,
        68,
        116,
        28,
        177
      ]
    },
    {
      name: "EvtCreateConfig",
      discriminator: [
        131,
        207,
        180,
        174,
        180,
        73,
        165,
        54
      ]
    },
    {
      name: "EvtCreateDammV2MigrationMetadata",
      discriminator: [
        103,
        111,
        132,
        168,
        140,
        253,
        150,
        114
      ]
    },
    {
      name: "EvtCreateMeteoraMigrationMetadata",
      discriminator: [
        99,
        167,
        133,
        63,
        214,
        143,
        175,
        139
      ]
    },
    {
      name: "EvtCreatorWithdrawSurplus",
      discriminator: [
        152,
        73,
        21,
        15,
        66,
        87,
        53,
        157
      ]
    },
    {
      name: "EvtCurveComplete",
      discriminator: [
        229,
        231,
        86,
        84,
        156,
        134,
        75,
        24
      ]
    },
    {
      name: "EvtInitializePool",
      discriminator: [
        228,
        50,
        246,
        85,
        203,
        66,
        134,
        37
      ]
    },
    {
      name: "EvtPartnerMetadata",
      discriminator: [
        200,
        127,
        6,
        55,
        13,
        32,
        8,
        150
      ]
    },
    {
      name: "EvtPartnerWithdrawMigrationFee",
      discriminator: [
        181,
        105,
        127,
        67,
        8,
        187,
        120,
        57
      ]
    },
    {
      name: "EvtPartnerWithdrawSurplus",
      discriminator: [
        195,
        56,
        152,
        9,
        232,
        72,
        35,
        22
      ]
    },
    {
      name: "EvtProtocolWithdrawSurplus",
      discriminator: [
        109,
        111,
        28,
        221,
        134,
        195,
        230,
        203
      ]
    },
    {
      name: "EvtSwap",
      discriminator: [
        27,
        60,
        21,
        213,
        138,
        170,
        187,
        147
      ]
    },
    {
      name: "EvtUpdatePoolCreator",
      discriminator: [
        107,
        225,
        165,
        237,
        91,
        158,
        213,
        220
      ]
    },
    {
      name: "EvtVirtualPoolMetadata",
      discriminator: [
        188,
        18,
        72,
        76,
        195,
        91,
        38,
        74
      ]
    },
    {
      name: "EvtWithdrawLeftover",
      discriminator: [
        191,
        189,
        104,
        143,
        111,
        156,
        94,
        229
      ]
    },
    {
      name: "EvtWithdrawMigrationFee",
      discriminator: [
        26,
        203,
        84,
        85,
        161,
        23,
        100,
        214
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "MathOverflow",
      msg: "Math operation overflow"
    },
    {
      code: 6001,
      name: "InvalidFee",
      msg: "Invalid fee setup"
    },
    {
      code: 6002,
      name: "ExceededSlippage",
      msg: "Exceeded slippage tolerance"
    },
    {
      code: 6003,
      name: "ExceedMaxFeeBps",
      msg: "Exceeded max fee bps"
    },
    {
      code: 6004,
      name: "InvalidAdmin",
      msg: "Invalid admin"
    },
    {
      code: 6005,
      name: "AmountIsZero",
      msg: "Amount is zero"
    },
    {
      code: 6006,
      name: "TypeCastFailed",
      msg: "Type cast error"
    },
    {
      code: 6007,
      name: "InvalidActivationType",
      msg: "Invalid activation type"
    },
    {
      code: 6008,
      name: "InvalidQuoteMint",
      msg: "Invalid quote mint"
    },
    {
      code: 6009,
      name: "InvalidCollectFeeMode",
      msg: "Invalid collect fee mode"
    },
    {
      code: 6010,
      name: "InvalidMigrationFeeOption",
      msg: "Invalid migration fee option"
    },
    {
      code: 6011,
      name: "InvalidInput",
      msg: "Invalid input"
    },
    {
      code: 6012,
      name: "NotEnoughLiquidity",
      msg: "Not enough liquidity"
    },
    {
      code: 6013,
      name: "PoolIsCompleted",
      msg: "Pool is completed"
    },
    {
      code: 6014,
      name: "PoolIsIncompleted",
      msg: "Pool is incompleted"
    },
    {
      code: 6015,
      name: "InvalidMigrationOption",
      msg: "Invalid migration option"
    },
    {
      code: 6016,
      name: "InvalidTokenDecimals",
      msg: "Invalid activation type"
    },
    {
      code: 6017,
      name: "InvalidTokenType",
      msg: "Invalid token type"
    },
    {
      code: 6018,
      name: "InvalidFeePercentage",
      msg: "Invalid fee percentage"
    },
    {
      code: 6019,
      name: "InvalidQuoteThreshold",
      msg: "Invalid quote threshold"
    },
    {
      code: 6020,
      name: "InvalidTokenSupply",
      msg: "Invalid token supply"
    },
    {
      code: 6021,
      name: "InvalidCurve",
      msg: "Invalid curve"
    },
    {
      code: 6022,
      name: "NotPermitToDoThisAction",
      msg: "Not permit to do this action"
    },
    {
      code: 6023,
      name: "InvalidOwnerAccount",
      msg: "Invalid owner account"
    },
    {
      code: 6024,
      name: "InvalidConfigAccount",
      msg: "Invalid config account"
    },
    {
      code: 6025,
      name: "SurplusHasBeenWithdraw",
      msg: "Surplus has been withdraw"
    },
    {
      code: 6026,
      name: "LeftoverHasBeenWithdraw",
      msg: "Leftover has been withdraw"
    },
    {
      code: 6027,
      name: "TotalBaseTokenExceedMaxSupply",
      msg: "Total base token is exceeded max supply"
    },
    {
      code: 6028,
      name: "UnsupportNativeMintToken2022",
      msg: "Unsupport native mint token 2022"
    },
    {
      code: 6029,
      name: "InsufficientLiquidityForMigration",
      msg: "Insufficient liquidity for migration"
    },
    {
      code: 6030,
      name: "MissingPoolConfigInRemainingAccount",
      msg: "Missing pool config in remaining account"
    },
    {
      code: 6031,
      name: "InvalidVestingParameters",
      msg: "Invalid vesting parameters"
    },
    {
      code: 6032,
      name: "InvalidLeftoverAddress",
      msg: "Invalid leftover address"
    },
    {
      code: 6033,
      name: "SwapAmountIsOverAThreshold",
      msg: "Swap amount is over a threshold"
    },
    {
      code: 6034,
      name: "InvalidFeeScheduler",
      msg: "Invalid fee scheduler"
    },
    {
      code: 6035,
      name: "InvalidCreatorTradingFeePercentage",
      msg: "Invalid creator trading fee percentage"
    },
    {
      code: 6036,
      name: "InvalidNewCreator",
      msg: "Invalid new creator"
    },
    {
      code: 6037,
      name: "InvalidTokenUpdateAuthorityOption",
      msg: "Invalid token update authority option"
    },
    {
      code: 6038,
      name: "InvalidAccount",
      msg: "Invalid account for the instruction"
    },
    {
      code: 6039,
      name: "InvalidMigratorFeePercentage",
      msg: "Invalid migrator fee percentage"
    },
    {
      code: 6040,
      name: "MigrationFeeHasBeenWithdraw",
      msg: "Migration fee has been withdraw"
    },
    {
      code: 6041,
      name: "InvalidBaseFeeMode",
      msg: "Invalid base fee mode"
    },
    {
      code: 6042,
      name: "InvalidFeeRateLimiter",
      msg: "Invalid fee rate limiter"
    },
    {
      code: 6043,
      name: "FailToValidateSingleSwapInstruction",
      msg: "Fail to validate single swap instruction in rate limiter"
    }
  ],
  types: [
    {
      name: "BaseFeeConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "second_factor",
            type: "u64"
          },
          {
            name: "third_factor",
            type: "u64"
          },
          {
            name: "first_factor",
            type: "u16"
          },
          {
            name: "base_fee_mode",
            type: "u8"
          },
          {
            name: "padding_0",
            type: {
              array: [
                "u8",
                5
              ]
            }
          }
        ]
      }
    },
    {
      name: "BaseFeeParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "first_factor",
            type: "u16"
          },
          {
            name: "second_factor",
            type: "u64"
          },
          {
            name: "third_factor",
            type: "u64"
          },
          {
            name: "base_fee_mode",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "ClaimFeeOperator",
      docs: [
        "Parameter that set by the protocol"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "operator",
            docs: [
              "operator"
            ],
            type: "pubkey"
          },
          {
            name: "_padding",
            docs: [
              "Reserve"
            ],
            type: {
              array: [
                "u8",
                128
              ]
            }
          }
        ]
      }
    },
    {
      name: "Config",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFees"
              }
            }
          },
          {
            name: "activation_duration",
            type: "u64"
          },
          {
            name: "vault_config_key",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            type: "pubkey"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "partner_fee_numerator",
            type: "u64"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                219
              ]
            }
          }
        ]
      }
    },
    {
      name: "ConfigParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          },
          {
            name: "migration_option",
            type: "u8"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "token_type",
            type: "u8"
          },
          {
            name: "token_decimal",
            type: "u8"
          },
          {
            name: "partner_lp_percentage",
            type: "u8"
          },
          {
            name: "partner_locked_lp_percentage",
            type: "u8"
          },
          {
            name: "creator_lp_percentage",
            type: "u8"
          },
          {
            name: "creator_locked_lp_percentage",
            type: "u8"
          },
          {
            name: "migration_quote_threshold",
            type: "u64"
          },
          {
            name: "sqrt_start_price",
            type: "u128"
          },
          {
            name: "locked_vesting",
            type: {
              defined: {
                name: "LockedVestingParams"
              }
            }
          },
          {
            name: "migration_fee_option",
            type: "u8"
          },
          {
            name: "token_supply",
            type: {
              option: {
                defined: {
                  name: "TokenSupplyParams"
                }
              }
            }
          },
          {
            name: "creator_trading_fee_percentage",
            type: "u8"
          },
          {
            name: "token_update_authority",
            type: "u8"
          },
          {
            name: "migration_fee",
            type: {
              defined: {
                name: "MigrationFee"
              }
            }
          },
          {
            name: "padding_0",
            type: {
              array: [
                "u8",
                4
              ]
            }
          },
          {
            name: "padding_1",
            docs: [
              "padding for future use"
            ],
            type: {
              array: [
                "u64",
                7
              ]
            }
          },
          {
            name: "curve",
            type: {
              vec: {
                defined: {
                  name: "LiquidityDistributionParameters"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "CreatePartnerMetadataParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "padding",
            type: {
              array: [
                "u8",
                96
              ]
            }
          },
          {
            name: "name",
            type: "string"
          },
          {
            name: "website",
            type: "string"
          },
          {
            name: "logo",
            type: "string"
          }
        ]
      }
    },
    {
      name: "CreateVirtualPoolMetadataParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "padding",
            type: {
              array: [
                "u8",
                96
              ]
            }
          },
          {
            name: "name",
            type: "string"
          },
          {
            name: "website",
            type: "string"
          },
          {
            name: "logo",
            type: "string"
          }
        ]
      }
    },
    {
      name: "DynamicFeeConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "initialized",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                7
              ]
            }
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          },
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "padding2",
            type: {
              array: [
                "u8",
                8
              ]
            }
          },
          {
            name: "bin_step_u128",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "DynamicFeeParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "bin_step_u128",
            type: "u128"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          }
        ]
      }
    },
    {
      name: "EvtClaimCreatorTradingFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_base_amount",
            type: "u64"
          },
          {
            name: "token_quote_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimProtocolFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_base_amount",
            type: "u64"
          },
          {
            name: "token_quote_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimTradingFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_base_amount",
            type: "u64"
          },
          {
            name: "token_quote_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtCloseClaimFeeOperator",
      docs: [
        "Close claim fee operator"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "claim_fee_operator",
            type: "pubkey"
          },
          {
            name: "operator",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateClaimFeeOperator",
      docs: [
        "Create claim fee operator"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "operator",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateConfig",
      docs: [
        "Create config"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "config",
            type: "pubkey"
          },
          {
            name: "quote_mint",
            type: "pubkey"
          },
          {
            name: "fee_claimer",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          },
          {
            name: "migration_option",
            type: "u8"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "token_decimal",
            type: "u8"
          },
          {
            name: "token_type",
            type: "u8"
          },
          {
            name: "partner_locked_lp_percentage",
            type: "u8"
          },
          {
            name: "partner_lp_percentage",
            type: "u8"
          },
          {
            name: "creator_locked_lp_percentage",
            type: "u8"
          },
          {
            name: "creator_lp_percentage",
            type: "u8"
          },
          {
            name: "swap_base_amount",
            type: "u64"
          },
          {
            name: "migration_quote_threshold",
            type: "u64"
          },
          {
            name: "migration_base_amount",
            type: "u64"
          },
          {
            name: "sqrt_start_price",
            type: "u128"
          },
          {
            name: "locked_vesting",
            type: {
              defined: {
                name: "LockedVestingParams"
              }
            }
          },
          {
            name: "migration_fee_option",
            type: "u8"
          },
          {
            name: "fixed_token_supply_flag",
            type: "u8"
          },
          {
            name: "pre_migration_token_supply",
            type: "u64"
          },
          {
            name: "post_migration_token_supply",
            type: "u64"
          },
          {
            name: "curve",
            type: {
              vec: {
                defined: {
                  name: "LiquidityDistributionParameters"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "EvtCreateDammV2MigrationMetadata",
      type: {
        kind: "struct",
        fields: [
          {
            name: "virtual_pool",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateMeteoraMigrationMetadata",
      type: {
        kind: "struct",
        fields: [
          {
            name: "virtual_pool",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreatorWithdrawSurplus",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "surplus_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtCurveComplete",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "config",
            type: "pubkey"
          },
          {
            name: "base_reserve",
            type: "u64"
          },
          {
            name: "quote_reserve",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtInitializePool",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "config",
            type: "pubkey"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "base_mint",
            type: "pubkey"
          },
          {
            name: "pool_type",
            type: "u8"
          },
          {
            name: "activation_point",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtPartnerMetadata",
      docs: [
        "Create partner metadata"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "partner_metadata",
            type: "pubkey"
          },
          {
            name: "fee_claimer",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtPartnerWithdrawMigrationFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtPartnerWithdrawSurplus",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "surplus_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtProtocolWithdrawSurplus",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "surplus_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtSwap",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "config",
            type: "pubkey"
          },
          {
            name: "trade_direction",
            type: "u8"
          },
          {
            name: "has_referral",
            type: "bool"
          },
          {
            name: "params",
            type: {
              defined: {
                name: "SwapParameters"
              }
            }
          },
          {
            name: "swap_result",
            type: {
              defined: {
                name: "SwapResult"
              }
            }
          },
          {
            name: "amount_in",
            type: "u64"
          },
          {
            name: "current_timestamp",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtUpdatePoolCreator",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "new_creator",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtVirtualPoolMetadata",
      docs: [
        "Create virtual pool metadata"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "virtual_pool_metadata",
            type: "pubkey"
          },
          {
            name: "virtual_pool",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtWithdrawLeftover",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "leftover_receiver",
            type: "pubkey"
          },
          {
            name: "leftover_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtWithdrawMigrationFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "fee",
            type: "u64"
          },
          {
            name: "flag",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "InitializePoolParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "name",
            type: "string"
          },
          {
            name: "symbol",
            type: "string"
          },
          {
            name: "uri",
            type: "string"
          }
        ]
      }
    },
    {
      name: "LiquidityDistributionConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "sqrt_price",
            type: "u128"
          },
          {
            name: "liquidity",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "LiquidityDistributionParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "sqrt_price",
            type: "u128"
          },
          {
            name: "liquidity",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "LockEscrow",
      docs: [
        "State of lock escrow account"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "escrow_vault",
            type: "pubkey"
          },
          {
            name: "bump",
            type: "u8"
          },
          {
            name: "total_locked_amount",
            type: "u64"
          },
          {
            name: "lp_per_token",
            type: "u128"
          },
          {
            name: "unclaimed_fee_pending",
            type: "u64"
          },
          {
            name: "a_fee",
            type: "u64"
          },
          {
            name: "b_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "LockedVestingConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_per_period",
            type: "u64"
          },
          {
            name: "cliff_duration_from_migration_time",
            type: "u64"
          },
          {
            name: "frequency",
            type: "u64"
          },
          {
            name: "number_of_period",
            type: "u64"
          },
          {
            name: "cliff_unlock_amount",
            type: "u64"
          },
          {
            name: "_padding",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "LockedVestingParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_per_period",
            type: "u64"
          },
          {
            name: "cliff_duration_from_migration_time",
            type: "u64"
          },
          {
            name: "frequency",
            type: "u64"
          },
          {
            name: "number_of_period",
            type: "u64"
          },
          {
            name: "cliff_unlock_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "MeteoraDammMigrationMetadata",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "virtual_pool",
            docs: [
              "pool"
            ],
            type: "pubkey"
          },
          {
            name: "padding_0",
            docs: [
              "!!! BE CAREFUL to use tomestone field, previous is pool creator"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "partner",
            docs: [
              "partner"
            ],
            type: "pubkey"
          },
          {
            name: "lp_mint",
            docs: [
              "lp mint"
            ],
            type: "pubkey"
          },
          {
            name: "partner_locked_lp",
            docs: [
              "partner locked lp"
            ],
            type: "u64"
          },
          {
            name: "partner_lp",
            docs: [
              "partner lp"
            ],
            type: "u64"
          },
          {
            name: "creator_locked_lp",
            docs: [
              "creator locked lp"
            ],
            type: "u64"
          },
          {
            name: "creator_lp",
            docs: [
              "creator lp"
            ],
            type: "u64"
          },
          {
            name: "_padding_0",
            docs: [
              "padding"
            ],
            type: "u8"
          },
          {
            name: "creator_locked_status",
            docs: [
              "flag to check whether lp is locked for creator"
            ],
            type: "u8"
          },
          {
            name: "partner_locked_status",
            docs: [
              "flag to check whether lp is locked for partner"
            ],
            type: "u8"
          },
          {
            name: "creator_claim_status",
            docs: [
              "flag to check whether creator has claimed lp token"
            ],
            type: "u8"
          },
          {
            name: "partner_claim_status",
            docs: [
              "flag to check whether partner has claimed lp token"
            ],
            type: "u8"
          },
          {
            name: "_padding",
            docs: [
              "Reserve"
            ],
            type: {
              array: [
                "u8",
                107
              ]
            }
          }
        ]
      }
    },
    {
      name: "MeteoraDammV2Metadata",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "virtual_pool",
            docs: [
              "pool"
            ],
            type: "pubkey"
          },
          {
            name: "padding_0",
            docs: [
              "!!! BE CAREFUL to use tomestone field, previous is pool creator"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "partner",
            docs: [
              "partner"
            ],
            type: "pubkey"
          },
          {
            name: "_padding",
            docs: [
              "Reserve"
            ],
            type: {
              array: [
                "u8",
                126
              ]
            }
          }
        ]
      }
    },
    {
      name: "MigrationFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "fee_percentage",
            type: "u8"
          },
          {
            name: "creator_fee_percentage",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "PartnerMetadata",
      docs: [
        "Metadata for a partner."
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "fee_claimer",
            docs: [
              "fee claimer"
            ],
            type: "pubkey"
          },
          {
            name: "padding",
            docs: [
              "padding for future use"
            ],
            type: {
              array: [
                "u128",
                6
              ]
            }
          },
          {
            name: "name",
            docs: [
              "Name of partner."
            ],
            type: "string"
          },
          {
            name: "website",
            docs: [
              "Website of partner."
            ],
            type: "string"
          },
          {
            name: "logo",
            docs: [
              "Logo of partner"
            ],
            type: "string"
          }
        ]
      }
    },
    {
      name: "PoolConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "quote_mint",
            docs: [
              "quote mint"
            ],
            type: "pubkey"
          },
          {
            name: "fee_claimer",
            docs: [
              "Address to get the fee"
            ],
            type: "pubkey"
          },
          {
            name: "leftover_receiver",
            docs: [
              "Address to receive extra base token after migration, in case token is fixed supply"
            ],
            type: "pubkey"
          },
          {
            name: "pool_fees",
            docs: [
              "Pool fee"
            ],
            type: {
              defined: {
                name: "PoolFeesConfig"
              }
            }
          },
          {
            name: "collect_fee_mode",
            docs: [
              "Collect fee mode"
            ],
            type: "u8"
          },
          {
            name: "migration_option",
            docs: [
              "migration option"
            ],
            type: "u8"
          },
          {
            name: "activation_type",
            docs: [
              "whether mode slot or timestamp"
            ],
            type: "u8"
          },
          {
            name: "token_decimal",
            docs: [
              "token decimals"
            ],
            type: "u8"
          },
          {
            name: "version",
            docs: [
              "version"
            ],
            type: "u8"
          },
          {
            name: "token_type",
            docs: [
              "token type of base token"
            ],
            type: "u8"
          },
          {
            name: "quote_token_flag",
            docs: [
              "quote token flag"
            ],
            type: "u8"
          },
          {
            name: "partner_locked_lp_percentage",
            docs: [
              "partner locked lp percentage"
            ],
            type: "u8"
          },
          {
            name: "partner_lp_percentage",
            docs: [
              "partner lp percentage"
            ],
            type: "u8"
          },
          {
            name: "creator_locked_lp_percentage",
            docs: [
              "creator post migration fee percentage"
            ],
            type: "u8"
          },
          {
            name: "creator_lp_percentage",
            docs: [
              "creator lp percentage"
            ],
            type: "u8"
          },
          {
            name: "migration_fee_option",
            docs: [
              "migration fee option"
            ],
            type: "u8"
          },
          {
            name: "fixed_token_supply_flag",
            docs: [
              "flag to indicate whether token is dynamic supply (0) or fixed supply (1)"
            ],
            type: "u8"
          },
          {
            name: "creator_trading_fee_percentage",
            docs: [
              "creator trading fee percentage"
            ],
            type: "u8"
          },
          {
            name: "token_update_authority",
            docs: [
              "token update authority"
            ],
            type: "u8"
          },
          {
            name: "migration_fee_percentage",
            docs: [
              "migration fee percentage"
            ],
            type: "u8"
          },
          {
            name: "creator_migration_fee_percentage",
            docs: [
              "creator migration fee percentage"
            ],
            type: "u8"
          },
          {
            name: "_padding_1",
            docs: [
              "padding 1"
            ],
            type: {
              array: [
                "u8",
                7
              ]
            }
          },
          {
            name: "swap_base_amount",
            docs: [
              "swap base amount"
            ],
            type: "u64"
          },
          {
            name: "migration_quote_threshold",
            docs: [
              "migration quote threshold (in quote token)"
            ],
            type: "u64"
          },
          {
            name: "migration_base_threshold",
            docs: [
              "migration base threshold (in base token)"
            ],
            type: "u64"
          },
          {
            name: "migration_sqrt_price",
            docs: [
              "migration sqrt price"
            ],
            type: "u128"
          },
          {
            name: "locked_vesting_config",
            docs: [
              "locked vesting config"
            ],
            type: {
              defined: {
                name: "LockedVestingConfig"
              }
            }
          },
          {
            name: "pre_migration_token_supply",
            docs: [
              "pre migration token supply"
            ],
            type: "u64"
          },
          {
            name: "post_migration_token_supply",
            docs: [
              "post migration token supply"
            ],
            type: "u64"
          },
          {
            name: "_padding_2",
            docs: [
              "padding 2"
            ],
            type: {
              array: [
                "u128",
                2
              ]
            }
          },
          {
            name: "sqrt_start_price",
            docs: [
              "minimum price"
            ],
            type: "u128"
          },
          {
            name: "curve",
            docs: [
              "curve, only use 20 point firstly, we can extend that latter"
            ],
            type: {
              array: [
                {
                  defined: {
                    name: "LiquidityDistributionConfig"
                  }
                },
                20
              ]
            }
          }
        ]
      }
    },
    {
      name: "PoolFeeParameters",
      docs: [
        "Information regarding fee charges"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            docs: [
              "Base fee"
            ],
            type: {
              defined: {
                name: "BaseFeeParameters"
              }
            }
          },
          {
            name: "dynamic_fee",
            docs: [
              "dynamic fee"
            ],
            type: {
              option: {
                defined: {
                  name: "DynamicFeeParameters"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "PoolFees",
      docs: [
        "Information regarding fee charges"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "trade_fee_numerator",
            type: "u64"
          },
          {
            name: "trade_fee_denominator",
            type: "u64"
          },
          {
            name: "protocol_trade_fee_numerator",
            type: "u64"
          },
          {
            name: "protocol_trade_fee_denominator",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "PoolFeesConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            type: {
              defined: {
                name: "BaseFeeConfig"
              }
            }
          },
          {
            name: "dynamic_fee",
            type: {
              defined: {
                name: "DynamicFeeConfig"
              }
            }
          },
          {
            name: "padding_0",
            type: {
              array: [
                "u64",
                5
              ]
            }
          },
          {
            name: "padding_1",
            type: {
              array: [
                "u8",
                6
              ]
            }
          },
          {
            name: "protocol_fee_percent",
            type: "u8"
          },
          {
            name: "referral_fee_percent",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "PoolMetrics",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "total_protocol_base_fee",
            type: "u64"
          },
          {
            name: "total_protocol_quote_fee",
            type: "u64"
          },
          {
            name: "total_trading_base_fee",
            type: "u64"
          },
          {
            name: "total_trading_quote_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SwapParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_in",
            type: "u64"
          },
          {
            name: "minimum_amount_out",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SwapResult",
      docs: [
        "Encodes all results of swapping"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "actual_input_amount",
            type: "u64"
          },
          {
            name: "output_amount",
            type: "u64"
          },
          {
            name: "next_sqrt_price",
            type: "u128"
          },
          {
            name: "trading_fee",
            type: "u64"
          },
          {
            name: "protocol_fee",
            type: "u64"
          },
          {
            name: "referral_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "TokenSupplyParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pre_migration_token_supply",
            docs: [
              "pre migration token supply"
            ],
            type: "u64"
          },
          {
            name: "post_migration_token_supply",
            docs: [
              "post migration token supply",
              "becase DBC allow user to swap over the migration quote threshold, so in extreme case user may swap more than allowed buffer on curve",
              "that result the total supply in post migration may be increased a bit (between pre_migration_token_supply and post_migration_token_supply)"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "VirtualPool",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "volatility_tracker",
            docs: [
              "volatility tracker"
            ],
            type: {
              defined: {
                name: "VolatilityTracker"
              }
            }
          },
          {
            name: "config",
            docs: [
              "config key"
            ],
            type: "pubkey"
          },
          {
            name: "creator",
            docs: [
              "creator"
            ],
            type: "pubkey"
          },
          {
            name: "base_mint",
            docs: [
              "base mint"
            ],
            type: "pubkey"
          },
          {
            name: "base_vault",
            docs: [
              "base vault"
            ],
            type: "pubkey"
          },
          {
            name: "quote_vault",
            docs: [
              "quote vault"
            ],
            type: "pubkey"
          },
          {
            name: "base_reserve",
            docs: [
              "base reserve"
            ],
            type: "u64"
          },
          {
            name: "quote_reserve",
            docs: [
              "quote reserve"
            ],
            type: "u64"
          },
          {
            name: "protocol_base_fee",
            docs: [
              "protocol base fee"
            ],
            type: "u64"
          },
          {
            name: "protocol_quote_fee",
            docs: [
              "protocol quote fee"
            ],
            type: "u64"
          },
          {
            name: "partner_base_fee",
            docs: [
              "partner base fee"
            ],
            type: "u64"
          },
          {
            name: "partner_quote_fee",
            docs: [
              "trading quote fee"
            ],
            type: "u64"
          },
          {
            name: "sqrt_price",
            docs: [
              "current price"
            ],
            type: "u128"
          },
          {
            name: "activation_point",
            docs: [
              "Activation point"
            ],
            type: "u64"
          },
          {
            name: "pool_type",
            docs: [
              "pool type, spl token or token2022"
            ],
            type: "u8"
          },
          {
            name: "is_migrated",
            docs: [
              "is migrated"
            ],
            type: "u8"
          },
          {
            name: "is_partner_withdraw_surplus",
            docs: [
              "is partner withdraw surplus"
            ],
            type: "u8"
          },
          {
            name: "is_protocol_withdraw_surplus",
            docs: [
              "is protocol withdraw surplus"
            ],
            type: "u8"
          },
          {
            name: "migration_progress",
            docs: [
              "migration progress"
            ],
            type: "u8"
          },
          {
            name: "is_withdraw_leftover",
            docs: [
              "is withdraw leftover"
            ],
            type: "u8"
          },
          {
            name: "is_creator_withdraw_surplus",
            docs: [
              "is creator withdraw surplus"
            ],
            type: "u8"
          },
          {
            name: "migration_fee_withdraw_status",
            docs: [
              "migration fee withdraw status, first bit is for partner, second bit is for creator"
            ],
            type: "u8"
          },
          {
            name: "metrics",
            docs: [
              "pool metrics"
            ],
            type: {
              defined: {
                name: "PoolMetrics"
              }
            }
          },
          {
            name: "finish_curve_timestamp",
            docs: [
              "The time curve is finished"
            ],
            type: "u64"
          },
          {
            name: "creator_base_fee",
            docs: [
              "creator base fee"
            ],
            type: "u64"
          },
          {
            name: "creator_quote_fee",
            docs: [
              "creator quote fee"
            ],
            type: "u64"
          },
          {
            name: "_padding_1",
            docs: [
              "Padding for further use"
            ],
            type: {
              array: [
                "u64",
                7
              ]
            }
          }
        ]
      }
    },
    {
      name: "VirtualPoolMetadata",
      docs: [
        "Metadata for a virtual pool."
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "virtual_pool",
            docs: [
              "virtual pool"
            ],
            type: "pubkey"
          },
          {
            name: "padding",
            docs: [
              "padding for future use"
            ],
            type: {
              array: [
                "u128",
                6
              ]
            }
          },
          {
            name: "name",
            docs: [
              "Name of project."
            ],
            type: "string"
          },
          {
            name: "website",
            docs: [
              "Website of project."
            ],
            type: "string"
          },
          {
            name: "logo",
            docs: [
              "Logo of project"
            ],
            type: "string"
          }
        ]
      }
    },
    {
      name: "VolatilityTracker",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "last_update_timestamp",
            type: "u64"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                8
              ]
            }
          },
          {
            name: "sqrt_price_reference",
            type: "u128"
          },
          {
            name: "volatility_accumulator",
            type: "u128"
          },
          {
            name: "volatility_reference",
            type: "u128"
          }
        ]
      }
    }
  ]
};

// src/idl/dynamic-vault/idl.json
var idl_default2 = {
  address: "24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi",
  metadata: {
    name: "vault",
    version: "0.7.2",
    spec: "0.1.0"
  },
  docs: [
    "Program for vault"
  ],
  instructions: [
    {
      name: "initialize",
      docs: [
        "initialize new vault"
      ],
      discriminator: [
        175,
        175,
        109,
        31,
        13,
        152,
        155,
        237
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "This is base account for all vault",
            "No need base key now because we only allow 1 vault per token now",
            "Vault account"
          ],
          writable: true
        },
        {
          name: "payer",
          docs: [
            "Payer can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "token_vault",
          docs: [
            "Token vault account"
          ],
          writable: true
        },
        {
          name: "token_mint",
          docs: [
            "Token mint account"
          ]
        },
        {
          name: "lp_mint",
          writable: true
        },
        {
          name: "rent",
          docs: [
            "rent"
          ]
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ]
        },
        {
          name: "system_program",
          docs: [
            "system_program"
          ]
        }
      ],
      args: []
    },
    {
      name: "enable_vault",
      docs: [
        "enable vault"
      ],
      discriminator: [
        145,
        82,
        241,
        156,
        26,
        154,
        233,
        211
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "Vault account"
          ],
          writable: true
        },
        {
          name: "admin",
          docs: [
            "Admin account"
          ],
          signer: true
        }
      ],
      args: [
        {
          name: "enabled",
          type: "u8"
        }
      ]
    },
    {
      name: "set_operator",
      docs: [
        "set new operator"
      ],
      discriminator: [
        238,
        153,
        101,
        169,
        243,
        131,
        36,
        1
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "Vault account"
          ],
          writable: true
        },
        {
          name: "operator"
        },
        {
          name: "admin",
          docs: [
            "admin"
          ],
          signer: true
        }
      ],
      args: []
    },
    {
      name: "initialize_strategy",
      docs: [
        "Initialize a strategy and add strategy to vault.strategies index"
      ],
      discriminator: [
        208,
        119,
        144,
        145,
        178,
        57,
        105,
        252
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "Vault account"
          ],
          writable: true
        },
        {
          name: "strategy_program"
        },
        {
          name: "strategy",
          docs: [
            "Strategy account"
          ],
          writable: true
        },
        {
          name: "reserve",
          writable: true
        },
        {
          name: "collateral_vault",
          docs: [
            "Collateral vault account"
          ],
          writable: true
        },
        {
          name: "collateral_mint",
          docs: [
            "Collateral mint account"
          ]
        },
        {
          name: "admin",
          docs: [
            "Admin account"
          ],
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          docs: [
            "System program account"
          ]
        },
        {
          name: "rent",
          docs: [
            "Rent account"
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program account"
          ]
        }
      ],
      args: [
        {
          name: "bumps",
          type: {
            defined: {
              name: "StrategyBumps"
            }
          }
        },
        {
          name: "strategy_type",
          type: {
            defined: {
              name: "StrategyType"
            }
          }
        }
      ]
    },
    {
      name: "remove_strategy",
      docs: [
        "remove a strategy"
      ],
      discriminator: [
        185,
        238,
        33,
        91,
        134,
        210,
        97,
        26
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "Vault account"
          ],
          writable: true
        },
        {
          name: "strategy",
          docs: [
            "Strategy account"
          ],
          writable: true
        },
        {
          name: "strategy_program"
        },
        {
          name: "collateral_vault",
          docs: [
            "Collateral vault account"
          ],
          writable: true
        },
        {
          name: "reserve",
          writable: true
        },
        {
          name: "token_vault",
          docs: [
            "token_vault"
          ],
          writable: true
        },
        {
          name: "fee_vault",
          docs: [
            "fee_vault"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "lp_mint"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ]
        },
        {
          name: "admin",
          docs: [
            "admin"
          ],
          signer: true
        }
      ],
      args: []
    },
    {
      name: "remove_strategy2",
      docs: [
        "remove a strategy by advance payment"
      ],
      discriminator: [
        138,
        104,
        208,
        148,
        126,
        35,
        195,
        14
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "Vault account"
          ],
          writable: true
        },
        {
          name: "strategy",
          docs: [
            "Strategy account"
          ],
          writable: true
        },
        {
          name: "strategy_program"
        },
        {
          name: "collateral_vault",
          docs: [
            "Collateral vault account"
          ],
          writable: true
        },
        {
          name: "reserve",
          writable: true
        },
        {
          name: "token_vault",
          docs: [
            "token_vault"
          ],
          writable: true
        },
        {
          name: "token_admin_advance_payment",
          docs: [
            "token_advance_payemnt",
            "the owner of token_advance_payment must be admin"
          ],
          writable: true
        },
        {
          name: "token_vault_advance_payment",
          docs: [
            "token_vault_advance_payment",
            "the account must be different from token_vault",
            "the owner of token_advance_payment must be vault"
          ],
          writable: true
        },
        {
          name: "fee_vault",
          docs: [
            "fee_vault"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "lp_mint"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ]
        },
        {
          name: "admin",
          docs: [
            "admin"
          ],
          signer: true
        }
      ],
      args: [
        {
          name: "max_admin_pay_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "collect_dust",
      docs: [
        "collect token, that someone send wrongly",
        "also help in case Mango reimbursement"
      ],
      discriminator: [
        246,
        149,
        21,
        82,
        160,
        74,
        254,
        240
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "vault"
          ]
        },
        {
          name: "token_vault",
          docs: [
            "Token vault, must be different from vault.token_vault"
          ],
          writable: true
        },
        {
          name: "token_admin",
          docs: [
            "token admin, enforce owner is admin to avoid mistake"
          ],
          writable: true
        },
        {
          name: "admin",
          docs: [
            "admin"
          ],
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ]
        }
      ],
      args: []
    },
    {
      name: "add_strategy",
      docs: [
        "add a strategy"
      ],
      discriminator: [
        64,
        123,
        127,
        227,
        192,
        234,
        198,
        20
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "vault"
          ],
          writable: true
        },
        {
          name: "strategy",
          docs: [
            "strategy"
          ]
        },
        {
          name: "admin",
          docs: [
            "admin"
          ],
          signer: true
        }
      ],
      args: []
    },
    {
      name: "deposit_strategy",
      docs: [
        "deposit liquidity to a strategy"
      ],
      discriminator: [
        246,
        82,
        57,
        226,
        131,
        222,
        253,
        249
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "vault"
          ],
          writable: true
        },
        {
          name: "strategy",
          docs: [
            "strategy"
          ],
          writable: true
        },
        {
          name: "token_vault",
          docs: [
            "token_vault"
          ],
          writable: true
        },
        {
          name: "fee_vault",
          docs: [
            "fee_vault"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "lp_mint"
          ],
          writable: true
        },
        {
          name: "strategy_program"
        },
        {
          name: "collateral_vault",
          docs: [
            "collateral_vault"
          ],
          writable: true
        },
        {
          name: "reserve",
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ]
        },
        {
          name: "operator",
          docs: [
            "operator"
          ],
          signer: true
        }
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        }
      ]
    },
    {
      name: "withdraw_strategy",
      docs: [
        "withdraw liquidity from a strategy"
      ],
      discriminator: [
        31,
        45,
        162,
        5,
        193,
        217,
        134,
        188
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "vault"
          ],
          writable: true
        },
        {
          name: "strategy",
          docs: [
            "strategy"
          ],
          writable: true
        },
        {
          name: "token_vault",
          docs: [
            "token_vault"
          ],
          writable: true
        },
        {
          name: "fee_vault",
          docs: [
            "fee_vault"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "lp_mint"
          ],
          writable: true
        },
        {
          name: "strategy_program"
        },
        {
          name: "collateral_vault",
          docs: [
            "collateral_vault"
          ],
          writable: true
        },
        {
          name: "reserve",
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ]
        },
        {
          name: "operator",
          docs: [
            "operator"
          ],
          signer: true
        }
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        }
      ]
    },
    {
      name: "withdraw2",
      docs: [
        "Withdraw v2. Withdraw from token vault if no remaining accounts are available. Else, it will attempt to withdraw from strategy and token vault. This method just proxy between 2 methods. Protocol integration should be using withdraw instead of this function."
      ],
      discriminator: [
        80,
        6,
        111,
        73,
        174,
        211,
        66,
        132
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "vault"
          ],
          writable: true
        },
        {
          name: "token_vault",
          docs: [
            "token_vault"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "lp_mint"
          ],
          writable: true
        },
        {
          name: "user_token",
          docs: [
            "user_token"
          ],
          writable: true
        },
        {
          name: "user_lp",
          docs: [
            "user_lp"
          ],
          writable: true
        },
        {
          name: "user",
          docs: [
            "user"
          ],
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ]
        }
      ],
      args: [
        {
          name: "unmint_amount",
          type: "u64"
        },
        {
          name: "min_out_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "deposit",
      docs: [
        "user deposit liquidity to vault"
      ],
      discriminator: [
        242,
        35,
        198,
        137,
        82,
        225,
        242,
        182
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "vault"
          ],
          writable: true
        },
        {
          name: "token_vault",
          docs: [
            "token_vault"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "lp_mint"
          ],
          writable: true
        },
        {
          name: "user_token",
          docs: [
            "user_token"
          ],
          writable: true
        },
        {
          name: "user_lp",
          docs: [
            "user_lp"
          ],
          writable: true
        },
        {
          name: "user",
          docs: [
            "user"
          ],
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ]
        }
      ],
      args: [
        {
          name: "token_amount",
          type: "u64"
        },
        {
          name: "minimum_lp_token_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "withdraw",
      docs: [
        "user withdraw liquidity from vault"
      ],
      discriminator: [
        183,
        18,
        70,
        156,
        148,
        109,
        161,
        34
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "vault"
          ],
          writable: true
        },
        {
          name: "token_vault",
          docs: [
            "token_vault"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "lp_mint"
          ],
          writable: true
        },
        {
          name: "user_token",
          docs: [
            "user_token"
          ],
          writable: true
        },
        {
          name: "user_lp",
          docs: [
            "user_lp"
          ],
          writable: true
        },
        {
          name: "user",
          docs: [
            "user"
          ],
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ]
        }
      ],
      args: [
        {
          name: "unmint_amount",
          type: "u64"
        },
        {
          name: "min_out_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "withdraw_directly_from_strategy",
      docs: [
        "user withdraw liquidity from vault, if vault reserve doesn't have enough liquidity, it will withdraw from the strategy firstly"
      ],
      discriminator: [
        201,
        141,
        146,
        46,
        173,
        116,
        198,
        22
      ],
      accounts: [
        {
          name: "vault",
          docs: [
            "vault"
          ],
          writable: true
        },
        {
          name: "strategy",
          docs: [
            "strategy"
          ],
          writable: true
        },
        {
          name: "reserve",
          writable: true
        },
        {
          name: "strategy_program"
        },
        {
          name: "collateral_vault",
          docs: [
            "collateral_vault"
          ],
          writable: true
        },
        {
          name: "token_vault",
          docs: [
            "token_vault"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "lp_mint"
          ],
          writable: true
        },
        {
          name: "fee_vault",
          docs: [
            "fee_vault"
          ],
          writable: true
        },
        {
          name: "user_token",
          docs: [
            "user_token"
          ],
          writable: true
        },
        {
          name: "user_lp",
          docs: [
            "user_lp"
          ],
          writable: true
        },
        {
          name: "user",
          docs: [
            "user"
          ],
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "token_program"
          ]
        }
      ],
      args: [
        {
          name: "unmint_amount",
          type: "u64"
        },
        {
          name: "min_out_amount",
          type: "u64"
        }
      ]
    }
  ],
  accounts: [
    {
      name: "Vault",
      discriminator: [
        211,
        8,
        232,
        43,
        2,
        152,
        117,
        119
      ]
    },
    {
      name: "Strategy",
      discriminator: [
        174,
        110,
        39,
        119,
        82,
        106,
        169,
        102
      ]
    }
  ],
  events: [
    {
      name: "AddLiquidity",
      discriminator: [
        31,
        94,
        125,
        90,
        227,
        52,
        61,
        186
      ]
    },
    {
      name: "RemoveLiquidity",
      discriminator: [
        116,
        244,
        97,
        232,
        103,
        31,
        152,
        58
      ]
    },
    {
      name: "StrategyDeposit",
      discriminator: [
        205,
        53,
        91,
        239,
        34,
        136,
        73,
        47
      ]
    },
    {
      name: "StrategyWithdraw",
      discriminator: [
        120,
        76,
        208,
        95,
        221,
        210,
        229,
        189
      ]
    },
    {
      name: "ClaimReward",
      discriminator: [
        148,
        116,
        134,
        204,
        22,
        171,
        85,
        95
      ]
    },
    {
      name: "PerformanceFee",
      discriminator: [
        28,
        70,
        231,
        223,
        81,
        109,
        239,
        167
      ]
    },
    {
      name: "ReportLoss",
      discriminator: [
        154,
        36,
        158,
        196,
        32,
        163,
        123,
        126
      ]
    },
    {
      name: "TotalAmount",
      discriminator: [
        92,
        200,
        122,
        145,
        211,
        203,
        49,
        205
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "VaultIsDisabled",
      msg: "Vault is disabled"
    },
    {
      code: 6001,
      name: "ExceededSlippage",
      msg: "Exceeded slippage tolerance"
    },
    {
      code: 6002,
      name: "StrategyIsNotExisted",
      msg: "Strategy is not existed"
    },
    {
      code: 6003,
      name: "UnAuthorized",
      msg: "UnAuthorized"
    },
    {
      code: 6004,
      name: "MathOverflow",
      msg: "Math operation overflow"
    },
    {
      code: 6005,
      name: "ProtocolIsNotSupported",
      msg: "Protocol is not supported"
    },
    {
      code: 6006,
      name: "UnMatchReserve",
      msg: "Reserve does not support token mint"
    },
    {
      code: 6007,
      name: "InvalidLockedProfitDegradation",
      msg: "lockedProfitDegradation is invalid"
    },
    {
      code: 6008,
      name: "MaxStrategyReached",
      msg: "Maximum number of strategies have been reached"
    },
    {
      code: 6009,
      name: "StrategyExisted",
      msg: "Strategy existed"
    },
    {
      code: 6010,
      name: "InvalidUnmintAmount",
      msg: "Invalid unmint amount"
    },
    {
      code: 6011,
      name: "InvalidAccountsForStrategy",
      msg: "Invalid accounts for strategy"
    },
    {
      code: 6012,
      name: "InvalidBump",
      msg: "Invalid bump"
    },
    {
      code: 6013,
      name: "AmountMustGreaterThanZero",
      msg: "Amount must be greater than 0"
    },
    {
      code: 6014,
      name: "MangoIsNotSupportedAnymore",
      msg: "Mango is not supported anymore"
    },
    {
      code: 6015,
      name: "StrategyIsNotSupported",
      msg: "Strategy is not supported"
    },
    {
      code: 6016,
      name: "PayAmountIsExeeced",
      msg: "Pay amount is exceeded"
    },
    {
      code: 6017,
      name: "FeeVaultIsNotSet",
      msg: "Fee vault is not set"
    },
    {
      code: 6018,
      name: "LendingAssertionViolation",
      msg: "deposit amount in lending is not matched"
    },
    {
      code: 6019,
      name: "HaveMoneyInLending",
      msg: "Cannot remove strategy becase we have some in lending"
    }
  ],
  types: [
    {
      name: "VaultBumps",
      docs: [
        "Vault bumps struct"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "vault_bump",
            docs: [
              "vault_bump"
            ],
            type: "u8"
          },
          {
            name: "token_vault_bump",
            docs: [
              "token_vault_bump"
            ],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "StrategyBumps",
      docs: [
        "Strategy bumps struct"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "strategy_index",
            docs: [
              "strategy_index"
            ],
            type: "u8"
          },
          {
            name: "other_bumps",
            docs: [
              "Bumps of PDAs for the integrated protocol."
            ],
            type: {
              array: [
                "u8",
                10
              ]
            }
          }
        ]
      }
    },
    {
      name: "LockedProfitTracker",
      docs: [
        "LockedProfitTracker struct"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "last_updated_locked_profit",
            docs: [
              "The total locked profit from the last report"
            ],
            type: "u64"
          },
          {
            name: "last_report",
            docs: [
              "The last timestamp (in seconds) rebalancing"
            ],
            type: "u64"
          },
          {
            name: "locked_profit_degradation",
            docs: [
              "Rate per second of degradation"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "StrategyType",
      docs: [
        "StrategyType struct"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "PortFinanceWithoutLM"
          },
          {
            name: "PortFinanceWithLM"
          },
          {
            name: "SolendWithoutLM"
          },
          {
            name: "Mango"
          },
          {
            name: "SolendWithLM"
          },
          {
            name: "ApricotWithoutLM"
          },
          {
            name: "Francium"
          },
          {
            name: "Tulip"
          },
          {
            name: "Vault"
          },
          {
            name: "Drift"
          },
          {
            name: "Frakt"
          },
          {
            name: "Marginfi"
          }
        ]
      }
    },
    {
      name: "Vault",
      docs: [
        "Vault struct"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "enabled",
            docs: [
              "The flag, if admin set enable = false, then the user can only withdraw and cannot deposit in the vault."
            ],
            type: "u8"
          },
          {
            name: "bumps",
            docs: [
              "Vault nonce, to create vault seeds"
            ],
            type: {
              defined: {
                name: "VaultBumps"
              }
            }
          },
          {
            name: "total_amount",
            docs: [
              "The total liquidity of the vault, including remaining tokens in token_vault and the liquidity in all strategies."
            ],
            type: "u64"
          },
          {
            name: "token_vault",
            docs: [
              "Token account, hold liquidity in vault reserve"
            ],
            type: "pubkey"
          },
          {
            name: "fee_vault",
            docs: [
              "Hold lp token of vault, each time rebalance crank is called, vault calculate performance fee and mint corresponding lp token amount to fee_vault. fee_vault is owned by treasury address"
            ],
            type: "pubkey"
          },
          {
            name: "token_mint",
            docs: [
              "Token mint that vault supports"
            ],
            type: "pubkey"
          },
          {
            name: "lp_mint",
            docs: [
              "Lp mint of vault"
            ],
            type: "pubkey"
          },
          {
            name: "strategies",
            docs: [
              "The list of strategy addresses that vault supports, vault can support up to MAX_STRATEGY strategies at the same time."
            ],
            type: {
              array: [
                "pubkey",
                30
              ]
            }
          },
          {
            name: "base",
            docs: [
              "The base address to create vault seeds"
            ],
            type: "pubkey"
          },
          {
            name: "admin",
            docs: [
              "Admin of vault"
            ],
            type: "pubkey"
          },
          {
            name: "operator",
            docs: [
              "Person who can send the crank. Operator can only send liquidity to strategies that admin defined, and claim reward to account of treasury address"
            ],
            type: "pubkey"
          },
          {
            name: "locked_profit_tracker",
            docs: [
              "Stores information for locked profit."
            ],
            type: {
              defined: {
                name: "LockedProfitTracker"
              }
            }
          }
        ]
      }
    },
    {
      name: "Strategy",
      docs: [
        "Strategy struct"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "reserve",
            docs: [
              "Lending pool address, that the strategy will deposit/withdraw balance"
            ],
            type: "pubkey"
          },
          {
            name: "collateral_vault",
            docs: [
              "The token account, that holds the collateral token"
            ],
            type: "pubkey"
          },
          {
            name: "strategy_type",
            docs: [
              "Specify type of strategy"
            ],
            type: {
              defined: {
                name: "StrategyType"
              }
            }
          },
          {
            name: "current_liquidity",
            docs: [
              "The liquidity in strategy at the time vault deposit/withdraw from a lending protocol"
            ],
            type: "u64"
          },
          {
            name: "bumps",
            docs: [
              "Hold some bumps, in case the strategy needs to use other seeds to sign a CPI call."
            ],
            type: {
              array: [
                "u8",
                10
              ]
            }
          },
          {
            name: "vault",
            docs: [
              "Vault address, that the strategy belongs"
            ],
            type: "pubkey"
          },
          {
            name: "is_disable",
            docs: [
              "If we remove strategy by remove_strategy2 endpoint, this account will be never added again"
            ],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "AddLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lp_mint_amount",
            type: "u64"
          },
          {
            name: "token_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "RemoveLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lp_unmint_amount",
            type: "u64"
          },
          {
            name: "token_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "StrategyDeposit",
      type: {
        kind: "struct",
        fields: [
          {
            name: "strategy_type",
            type: {
              defined: {
                name: "StrategyType"
              }
            }
          },
          {
            name: "token_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "StrategyWithdraw",
      type: {
        kind: "struct",
        fields: [
          {
            name: "strategy_type",
            type: {
              defined: {
                name: "StrategyType"
              }
            }
          },
          {
            name: "collateral_amount",
            type: "u64"
          },
          {
            name: "estimated_token_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "ClaimReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "strategy_type",
            type: {
              defined: {
                name: "StrategyType"
              }
            }
          },
          {
            name: "token_amount",
            type: "u64"
          },
          {
            name: "mint_account",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "PerformanceFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lp_mint_more",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "ReportLoss",
      type: {
        kind: "struct",
        fields: [
          {
            name: "strategy",
            type: "pubkey"
          },
          {
            name: "loss",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "TotalAmount",
      type: {
        kind: "struct",
        fields: [
          {
            name: "total_amount",
            type: "u64"
          }
        ]
      }
    }
  ]
};

// src/idl/damm-v1/idl.json
var idl_default3 = {
  address: "Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB",
  metadata: {
    name: "amm",
    version: "0.5.3",
    spec: "0.1.0"
  },
  docs: [
    "Program for AMM"
  ],
  instructions: [
    {
      name: "initialize_permissioned_pool",
      docs: [
        "Initialize a new permissioned pool."
      ],
      discriminator: [
        77,
        85,
        178,
        157,
        50,
        48,
        212,
        126
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (arbitrary address)"
          ],
          writable: true,
          signer: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "token_a_mint",
          docs: [
            "Token A mint of the pool. Eg: USDT"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token B mint of the pool. Eg: USDC"
          ]
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault A"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "admin_token_a",
          docs: [
            "Admin token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "admin_token_b",
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "admin_pool_lp",
          docs: [
            "Admin pool LP token account. Used to receive LP during first deposit (initialize pool)",
            "Admin pool LP token account. Used to receive LP during first deposit (initialize pool)"
          ],
          writable: true
        },
        {
          name: "protocol_token_a_fee",
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "protocol_token_b_fee",
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "admin",
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ],
          writable: true,
          signer: true
        },
        {
          name: "fee_owner"
        },
        {
          name: "rent",
          docs: [
            "Rent account."
          ]
        },
        {
          name: "mint_metadata",
          writable: true
        },
        {
          name: "metadata_program"
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program."
          ]
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ]
        }
      ],
      args: [
        {
          name: "curve_type",
          type: {
            defined: {
              name: "CurveType"
            }
          }
        }
      ]
    },
    {
      name: "initialize_permissionless_pool",
      docs: [
        "Initialize a new permissionless pool."
      ],
      discriminator: [
        118,
        173,
        41,
        157,
        173,
        72,
        97,
        103
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA address)"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "token_a_mint",
          docs: [
            "Token A mint of the pool. Eg: USDT"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token B mint of the pool. Eg: USDC"
          ]
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault A"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "payer_token_a",
          docs: [
            "Payer token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "payer_pool_lp",
          writable: true
        },
        {
          name: "protocol_token_a_fee",
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "protocol_token_b_fee",
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "payer",
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ],
          writable: true,
          signer: true
        },
        {
          name: "fee_owner"
        },
        {
          name: "rent",
          docs: [
            "Rent account."
          ]
        },
        {
          name: "mint_metadata",
          writable: true
        },
        {
          name: "metadata_program"
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program."
          ]
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ]
        }
      ],
      args: [
        {
          name: "curve_type",
          type: {
            defined: {
              name: "CurveType"
            }
          }
        },
        {
          name: "token_a_amount",
          type: "u64"
        },
        {
          name: "token_b_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "initialize_permissionless_pool_with_fee_tier",
      docs: [
        "Initialize a new permissionless pool with customized fee tier"
      ],
      discriminator: [
        6,
        135,
        68,
        147,
        229,
        82,
        169,
        113
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA address)"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "token_a_mint",
          docs: [
            "Token A mint of the pool. Eg: USDT"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token B mint of the pool. Eg: USDC"
          ]
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault A"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "payer_token_a",
          docs: [
            "Payer token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "payer_pool_lp",
          writable: true
        },
        {
          name: "protocol_token_a_fee",
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "protocol_token_b_fee",
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "payer",
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ],
          writable: true,
          signer: true
        },
        {
          name: "fee_owner"
        },
        {
          name: "rent",
          docs: [
            "Rent account."
          ]
        },
        {
          name: "mint_metadata",
          writable: true
        },
        {
          name: "metadata_program"
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program."
          ]
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ]
        }
      ],
      args: [
        {
          name: "curve_type",
          type: {
            defined: {
              name: "CurveType"
            }
          }
        },
        {
          name: "trade_fee_bps",
          type: "u64"
        },
        {
          name: "token_a_amount",
          type: "u64"
        },
        {
          name: "token_b_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "enable_or_disable_pool",
      docs: [
        "Enable or disable a pool. A disabled pool allow only remove balanced liquidity operation."
      ],
      discriminator: [
        128,
        6,
        228,
        131,
        55,
        161,
        52,
        169
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "admin",
          docs: [
            "Admin account. Must be owner of the pool."
          ],
          signer: true
        }
      ],
      args: [
        {
          name: "enable",
          type: "bool"
        }
      ]
    },
    {
      name: "swap",
      docs: [
        "Swap token A to B, or vice versa. An amount of trading fee will be charged for liquidity provider, and the admin of the pool."
      ],
      discriminator: [
        248,
        198,
        158,
        145,
        225,
        117,
        135,
        200
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "user_source_token",
          docs: [
            "User token account. Token from this account will be transfer into the vault by the pool in exchange for another token of the pool."
          ],
          writable: true
        },
        {
          name: "user_destination_token",
          docs: [
            "User token account. The exchanged token will be transfer into this account from the pool."
          ],
          writable: true
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "Lp token mint of vault a"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "Lp token mint of vault b"
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "protocol_token_fee",
          docs: [
            "Protocol fee token account. Used to receive trading fee. It's mint field must matched with user_source_token mint field."
          ],
          writable: true
        },
        {
          name: "user",
          docs: [
            "User account. Must be owner of user_source_token."
          ],
          signer: true
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        }
      ],
      args: [
        {
          name: "in_amount",
          type: "u64"
        },
        {
          name: "minimum_out_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "remove_liquidity_single_side",
      docs: [
        "Withdraw only single token from the pool. Only supported by pool with stable swap curve."
      ],
      discriminator: [
        84,
        84,
        177,
        66,
        254,
        185,
        10,
        251
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "user_pool_lp",
          docs: [
            "User pool lp token account. LP will be burned from this account upon success liquidity removal."
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault A"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault B"
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "user_destination_token",
          docs: [
            "User token account to receive token upon success liquidity removal."
          ],
          writable: true
        },
        {
          name: "user",
          docs: [
            "User account. Must be owner of the user_pool_lp account."
          ],
          signer: true
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        }
      ],
      args: [
        {
          name: "pool_token_amount",
          type: "u64"
        },
        {
          name: "minimum_out_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "add_imbalance_liquidity",
      docs: [
        "Deposit tokens to the pool in an imbalance ratio. Only supported by pool with stable swap curve."
      ],
      discriminator: [
        79,
        35,
        122,
        84,
        173,
        15,
        93,
        191
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "user_pool_lp",
          docs: [
            "user pool lp token account. lp will be burned from this account upon success liquidity removal."
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault a"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault b"
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "user_a_token",
          docs: [
            "User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ],
          writable: true
        },
        {
          name: "user_b_token",
          docs: [
            "User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ],
          writable: true
        },
        {
          name: "user",
          docs: [
            "User account. Must be owner of user_a_token, and user_b_token."
          ],
          signer: true
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        }
      ],
      args: [
        {
          name: "minimum_pool_token_amount",
          type: "u64"
        },
        {
          name: "token_a_amount",
          type: "u64"
        },
        {
          name: "token_b_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "remove_balance_liquidity",
      docs: [
        "Withdraw tokens from the pool in a balanced ratio. User will still able to withdraw from pool even the pool is disabled. This allow user to exit their liquidity when there's some unforeseen event happen."
      ],
      discriminator: [
        133,
        109,
        44,
        179,
        56,
        238,
        114,
        33
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "user_pool_lp",
          docs: [
            "user pool lp token account. lp will be burned from this account upon success liquidity removal."
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault a"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault b"
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "user_a_token",
          docs: [
            "User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ],
          writable: true
        },
        {
          name: "user_b_token",
          docs: [
            "User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ],
          writable: true
        },
        {
          name: "user",
          docs: [
            "User account. Must be owner of user_a_token, and user_b_token."
          ],
          signer: true
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        }
      ],
      args: [
        {
          name: "pool_token_amount",
          type: "u64"
        },
        {
          name: "minimum_a_token_out",
          type: "u64"
        },
        {
          name: "minimum_b_token_out",
          type: "u64"
        }
      ]
    },
    {
      name: "add_balance_liquidity",
      docs: [
        "Deposit tokens to the pool in a balanced ratio."
      ],
      discriminator: [
        168,
        227,
        50,
        62,
        189,
        171,
        84,
        176
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "user_pool_lp",
          docs: [
            "user pool lp token account. lp will be burned from this account upon success liquidity removal."
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault a"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault b"
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "user_a_token",
          docs: [
            "User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ],
          writable: true
        },
        {
          name: "user_b_token",
          docs: [
            "User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ],
          writable: true
        },
        {
          name: "user",
          docs: [
            "User account. Must be owner of user_a_token, and user_b_token."
          ],
          signer: true
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        }
      ],
      args: [
        {
          name: "pool_token_amount",
          type: "u64"
        },
        {
          name: "maximum_token_a_amount",
          type: "u64"
        },
        {
          name: "maximum_token_b_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "set_pool_fees",
      docs: [
        "Update trading fee charged for liquidity provider, and admin."
      ],
      discriminator: [
        102,
        44,
        158,
        54,
        205,
        37,
        126,
        78
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "fee_operator",
          docs: [
            "Fee operator account"
          ],
          signer: true
        }
      ],
      args: [
        {
          name: "fees",
          type: {
            defined: {
              name: "PoolFees"
            }
          }
        },
        {
          name: "new_partner_fee_numerator",
          type: "u64"
        }
      ]
    },
    {
      name: "override_curve_param",
      docs: [
        "Update swap curve parameters. This function do not allow update of curve type. For example: stable swap curve to constant product curve. Only supported by pool with stable swap curve.",
        "Only amp is allowed to be override. The other attributes of stable swap curve will be ignored."
      ],
      discriminator: [
        98,
        86,
        204,
        51,
        94,
        71,
        69,
        187
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "admin",
          docs: [
            "Admin account."
          ],
          signer: true
        }
      ],
      args: [
        {
          name: "curve_type",
          type: {
            defined: {
              name: "CurveType"
            }
          }
        }
      ]
    },
    {
      name: "get_pool_info",
      docs: [
        "Get the general information of the pool."
      ],
      discriminator: [
        9,
        48,
        220,
        101,
        22,
        240,
        78,
        200
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ]
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ]
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault a"
          ]
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault b"
          ]
        }
      ],
      args: []
    },
    {
      name: "bootstrap_liquidity",
      docs: [
        "Bootstrap the pool when liquidity is depleted."
      ],
      discriminator: [
        4,
        228,
        215,
        71,
        225,
        253,
        119,
        206
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "user_pool_lp",
          docs: [
            "user pool lp token account. lp will be burned from this account upon success liquidity removal."
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault a"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault b"
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "user_a_token",
          docs: [
            "User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ],
          writable: true
        },
        {
          name: "user_b_token",
          docs: [
            "User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ],
          writable: true
        },
        {
          name: "user",
          docs: [
            "User account. Must be owner of user_a_token, and user_b_token."
          ],
          signer: true
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        }
      ],
      args: [
        {
          name: "token_a_amount",
          type: "u64"
        },
        {
          name: "token_b_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "create_mint_metadata",
      docs: [
        "Create mint metadata account for old pools"
      ],
      discriminator: [
        13,
        70,
        168,
        41,
        250,
        100,
        148,
        90
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account"
          ]
        },
        {
          name: "lp_mint",
          docs: [
            "LP mint account of the pool"
          ]
        },
        {
          name: "a_vault_lp",
          docs: [
            "Vault A LP account of the pool"
          ]
        },
        {
          name: "mint_metadata",
          writable: true
        },
        {
          name: "metadata_program"
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ]
        },
        {
          name: "payer",
          docs: [
            "Payer"
          ],
          writable: true,
          signer: true
        }
      ],
      args: []
    },
    {
      name: "create_lock_escrow",
      docs: [
        "Create lock account"
      ],
      discriminator: [
        54,
        87,
        165,
        19,
        69,
        227,
        218,
        224
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account"
          ]
        },
        {
          name: "lock_escrow",
          docs: [
            "Lock account"
          ],
          writable: true
        },
        {
          name: "owner"
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ]
        },
        {
          name: "payer",
          docs: [
            "Payer account"
          ],
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ]
        }
      ],
      args: []
    },
    {
      name: "lock",
      docs: [
        "Lock Lp token"
      ],
      discriminator: [
        21,
        19,
        208,
        43,
        237,
        62,
        255,
        87
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ]
        },
        {
          name: "lock_escrow",
          docs: [
            "Lock account"
          ],
          writable: true
        },
        {
          name: "owner",
          docs: [
            "Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "source_tokens",
          docs: [
            "owner lp token account"
          ],
          writable: true
        },
        {
          name: "escrow_vault",
          docs: [
            "Escrow vault"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ]
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ]
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault a"
          ]
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault b"
          ]
        }
      ],
      args: [
        {
          name: "max_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "claim_fee",
      docs: [
        "Claim fee"
      ],
      discriminator: [
        169,
        32,
        79,
        137,
        136,
        232,
        70,
        137
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "lock_escrow",
          docs: [
            "Lock account"
          ],
          writable: true
        },
        {
          name: "owner",
          docs: [
            "Owner of lock account"
          ],
          writable: true,
          signer: true
        },
        {
          name: "source_tokens",
          docs: [
            "owner lp token account"
          ],
          writable: true
        },
        {
          name: "escrow_vault",
          docs: [
            "Escrow vault"
          ],
          writable: true
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token a. token a of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token b. token b of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault a"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault b"
          ],
          writable: true
        },
        {
          name: "user_a_token",
          docs: [
            "User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ],
          writable: true
        },
        {
          name: "user_b_token",
          docs: [
            "User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account."
          ],
          writable: true
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. the pool will deposit/withdraw liquidity from the vault."
          ]
        }
      ],
      args: [
        {
          name: "max_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "create_config",
      docs: [
        "Create config"
      ],
      discriminator: [
        201,
        207,
        243,
        114,
        75,
        111,
        47,
        189
      ],
      accounts: [
        {
          name: "config",
          writable: true
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program"
        }
      ],
      args: [
        {
          name: "config_parameters",
          type: {
            defined: {
              name: "ConfigParameters"
            }
          }
        }
      ]
    },
    {
      name: "close_config",
      docs: [
        "Close config"
      ],
      discriminator: [
        145,
        9,
        72,
        157,
        95,
        125,
        61,
        85
      ],
      accounts: [
        {
          name: "config",
          writable: true
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        }
      ],
      args: []
    },
    {
      name: "initialize_permissionless_constant_product_pool_with_config",
      docs: [
        "Initialize permissionless pool with config"
      ],
      discriminator: [
        7,
        166,
        138,
        171,
        206,
        171,
        236,
        244
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA address)"
          ],
          writable: true
        },
        {
          name: "config"
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "token_a_mint",
          docs: [
            "Token A mint of the pool. Eg: USDT"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token B mint of the pool. Eg: USDC"
          ]
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault A"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "payer_token_a",
          docs: [
            "Payer token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "payer_pool_lp",
          writable: true
        },
        {
          name: "protocol_token_a_fee",
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "protocol_token_b_fee",
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "payer",
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ],
          writable: true,
          signer: true
        },
        {
          name: "rent",
          docs: [
            "Rent account."
          ]
        },
        {
          name: "mint_metadata",
          writable: true
        },
        {
          name: "metadata_program"
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program."
          ]
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ]
        }
      ],
      args: [
        {
          name: "token_a_amount",
          type: "u64"
        },
        {
          name: "token_b_amount",
          type: "u64"
        }
      ]
    },
    {
      name: "initialize_permissionless_constant_product_pool_with_config2",
      docs: [
        "Initialize permissionless pool with config 2"
      ],
      discriminator: [
        48,
        149,
        220,
        130,
        61,
        11,
        9,
        178
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA address)"
          ],
          writable: true
        },
        {
          name: "config"
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "token_a_mint",
          docs: [
            "Token A mint of the pool. Eg: USDT"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token B mint of the pool. Eg: USDC"
          ]
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault A"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "payer_token_a",
          docs: [
            "Payer token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "payer_pool_lp",
          writable: true
        },
        {
          name: "protocol_token_a_fee",
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "protocol_token_b_fee",
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "payer",
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ],
          writable: true,
          signer: true
        },
        {
          name: "rent",
          docs: [
            "Rent account."
          ]
        },
        {
          name: "mint_metadata",
          writable: true
        },
        {
          name: "metadata_program"
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program."
          ]
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ]
        }
      ],
      args: [
        {
          name: "token_a_amount",
          type: "u64"
        },
        {
          name: "token_b_amount",
          type: "u64"
        },
        {
          name: "activation_point",
          type: {
            option: "u64"
          }
        }
      ]
    },
    {
      name: "initialize_customizable_permissionless_constant_product_pool",
      docs: [
        "Initialize permissionless pool with customizable params"
      ],
      discriminator: [
        145,
        24,
        172,
        194,
        219,
        125,
        3,
        190
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA address)"
          ],
          writable: true
        },
        {
          name: "lp_mint",
          docs: [
            "LP token mint of the pool"
          ],
          writable: true
        },
        {
          name: "token_a_mint",
          docs: [
            "Token A mint of the pool. Eg: USDT"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token B mint of the pool. Eg: USDC"
          ]
        },
        {
          name: "a_vault",
          docs: [
            "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "b_vault",
          docs: [
            "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
          ],
          writable: true
        },
        {
          name: "a_token_vault",
          docs: [
            "Token vault account of vault A"
          ],
          writable: true
        },
        {
          name: "b_token_vault",
          docs: [
            "Token vault account of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp_mint",
          docs: [
            "LP token mint of vault A"
          ],
          writable: true
        },
        {
          name: "b_vault_lp_mint",
          docs: [
            "LP token mint of vault B"
          ],
          writable: true
        },
        {
          name: "a_vault_lp",
          docs: [
            "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "b_vault_lp",
          docs: [
            "LP token account of vault B. Used to receive/burn vault LP upon deposit/withdraw from the vault."
          ],
          writable: true
        },
        {
          name: "payer_token_a",
          docs: [
            "Payer token account for pool token A mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "Admin token account for pool token B mint. Used to bootstrap the pool with initial liquidity."
          ],
          writable: true
        },
        {
          name: "payer_pool_lp",
          writable: true
        },
        {
          name: "protocol_token_a_fee",
          docs: [
            "Protocol fee token account for token A. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "protocol_token_b_fee",
          docs: [
            "Protocol fee token account for token B. Used to receive trading fee."
          ],
          writable: true
        },
        {
          name: "payer",
          docs: [
            "Admin account. This account will be the admin of the pool, and the payer for PDA during initialize pool."
          ],
          writable: true,
          signer: true
        },
        {
          name: "rent",
          docs: [
            "Rent account."
          ]
        },
        {
          name: "mint_metadata",
          writable: true
        },
        {
          name: "metadata_program"
        },
        {
          name: "vault_program",
          docs: [
            "Vault program. The pool will deposit/withdraw liquidity from the vault."
          ]
        },
        {
          name: "token_program",
          docs: [
            "Token program."
          ]
        },
        {
          name: "associated_token_program",
          docs: [
            "Associated token program."
          ]
        },
        {
          name: "system_program",
          docs: [
            "System program."
          ]
        }
      ],
      args: [
        {
          name: "token_a_amount",
          type: "u64"
        },
        {
          name: "token_b_amount",
          type: "u64"
        },
        {
          name: "params",
          type: {
            defined: {
              name: "CustomizableParams"
            }
          }
        }
      ]
    },
    {
      name: "update_activation_point",
      docs: [
        "Update activation slot"
      ],
      discriminator: [
        150,
        62,
        125,
        219,
        171,
        220,
        26,
        237
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "admin",
          docs: [
            "Admin account."
          ],
          signer: true
        }
      ],
      args: [
        {
          name: "new_activation_point",
          type: "u64"
        }
      ]
    },
    {
      name: "withdraw_protocol_fees",
      docs: [
        "Withdraw protocol fee"
      ],
      discriminator: [
        11,
        68,
        165,
        98,
        18,
        208,
        134,
        73
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ]
        },
        {
          name: "a_vault_lp"
        },
        {
          name: "protocol_token_a_fee",
          writable: true
        },
        {
          name: "protocol_token_b_fee",
          writable: true
        },
        {
          name: "treasury_token_a",
          writable: true
        },
        {
          name: "treasury_token_b",
          writable: true
        },
        {
          name: "token_program"
        }
      ],
      args: []
    },
    {
      name: "set_whitelisted_vault",
      docs: [
        "Set whitelisted vault"
      ],
      discriminator: [
        12,
        148,
        94,
        42,
        55,
        57,
        83,
        247
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "admin",
          signer: true
        }
      ],
      args: [
        {
          name: "whitelisted_vault",
          type: "pubkey"
        }
      ]
    },
    {
      name: "partner_claim_fee",
      docs: [
        "Partner claim fee"
      ],
      discriminator: [
        57,
        53,
        176,
        30,
        123,
        70,
        52,
        64
      ],
      accounts: [
        {
          name: "pool",
          docs: [
            "Pool account (PDA)"
          ],
          writable: true
        },
        {
          name: "a_vault_lp"
        },
        {
          name: "protocol_token_a_fee",
          writable: true
        },
        {
          name: "protocol_token_b_fee",
          writable: true
        },
        {
          name: "partner_token_a",
          writable: true
        },
        {
          name: "partner_token_b",
          writable: true
        },
        {
          name: "token_program"
        },
        {
          name: "partner_authority",
          signer: true
        }
      ],
      args: [
        {
          name: "max_amount_a",
          type: "u64"
        },
        {
          name: "max_amount_b",
          type: "u64"
        }
      ]
    }
  ],
  accounts: [
    {
      name: "Config",
      discriminator: [
        155,
        12,
        170,
        224,
        30,
        250,
        204,
        130
      ]
    },
    {
      name: "LockEscrow",
      discriminator: [
        190,
        106,
        121,
        6,
        200,
        182,
        21,
        75
      ]
    },
    {
      name: "Pool",
      discriminator: [
        241,
        154,
        109,
        4,
        17,
        177,
        109,
        188
      ]
    }
  ],
  events: [
    {
      name: "AddLiquidity",
      discriminator: [
        31,
        94,
        125,
        90,
        227,
        52,
        61,
        186
      ]
    },
    {
      name: "RemoveLiquidity",
      discriminator: [
        116,
        244,
        97,
        232,
        103,
        31,
        152,
        58
      ]
    },
    {
      name: "BootstrapLiquidity",
      discriminator: [
        121,
        127,
        38,
        136,
        92,
        55,
        14,
        247
      ]
    },
    {
      name: "Swap",
      discriminator: [
        81,
        108,
        227,
        190,
        205,
        208,
        10,
        196
      ]
    },
    {
      name: "SetPoolFees",
      discriminator: [
        245,
        26,
        198,
        164,
        88,
        18,
        75,
        9
      ]
    },
    {
      name: "PoolInfo",
      discriminator: [
        207,
        20,
        87,
        97,
        251,
        212,
        234,
        45
      ]
    },
    {
      name: "TransferAdmin",
      discriminator: [
        228,
        169,
        131,
        244,
        61,
        56,
        65,
        254
      ]
    },
    {
      name: "OverrideCurveParam",
      discriminator: [
        247,
        20,
        165,
        248,
        75,
        5,
        54,
        246
      ]
    },
    {
      name: "PoolCreated",
      discriminator: [
        202,
        44,
        41,
        88,
        104,
        220,
        157,
        82
      ]
    },
    {
      name: "PoolEnabled",
      discriminator: [
        2,
        151,
        18,
        83,
        204,
        134,
        92,
        191
      ]
    },
    {
      name: "MigrateFeeAccount",
      discriminator: [
        223,
        234,
        232,
        26,
        252,
        105,
        180,
        125
      ]
    },
    {
      name: "CreateLockEscrow",
      discriminator: [
        74,
        94,
        106,
        141,
        49,
        17,
        98,
        109
      ]
    },
    {
      name: "Lock",
      discriminator: [
        220,
        183,
        67,
        215,
        153,
        207,
        56,
        234
      ]
    },
    {
      name: "ClaimFee",
      discriminator: [
        75,
        122,
        154,
        48,
        140,
        74,
        123,
        163
      ]
    },
    {
      name: "CreateConfig",
      discriminator: [
        199,
        152,
        10,
        19,
        39,
        39,
        157,
        104
      ]
    },
    {
      name: "CloseConfig",
      discriminator: [
        249,
        181,
        108,
        89,
        4,
        150,
        90,
        174
      ]
    },
    {
      name: "WithdrawProtocolFees",
      discriminator: [
        30,
        240,
        207,
        196,
        139,
        239,
        79,
        28
      ]
    },
    {
      name: "PartnerClaimFees",
      discriminator: [
        135,
        131,
        10,
        94,
        119,
        209,
        202,
        48
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "MathOverflow",
      msg: "Math operation overflow"
    },
    {
      code: 6001,
      name: "InvalidFee",
      msg: "Invalid fee setup"
    },
    {
      code: 6002,
      name: "InvalidInvariant",
      msg: "Invalid invariant d"
    },
    {
      code: 6003,
      name: "FeeCalculationFailure",
      msg: "Fee calculation failure"
    },
    {
      code: 6004,
      name: "ExceededSlippage",
      msg: "Exceeded slippage tolerance"
    },
    {
      code: 6005,
      name: "InvalidCalculation",
      msg: "Invalid curve calculation"
    },
    {
      code: 6006,
      name: "ZeroTradingTokens",
      msg: "Given pool token amount results in zero trading tokens"
    },
    {
      code: 6007,
      name: "ConversionError",
      msg: "Math conversion overflow"
    },
    {
      code: 6008,
      name: "FaultyLpMint",
      msg: "LP mint authority must be 'A' vault lp, without freeze authority, and 0 supply"
    },
    {
      code: 6009,
      name: "MismatchedTokenMint",
      msg: "Token mint mismatched"
    },
    {
      code: 6010,
      name: "MismatchedLpMint",
      msg: "LP mint mismatched"
    },
    {
      code: 6011,
      name: "MismatchedOwner",
      msg: "Invalid lp token owner"
    },
    {
      code: 6012,
      name: "InvalidVaultAccount",
      msg: "Invalid vault account"
    },
    {
      code: 6013,
      name: "InvalidVaultLpAccount",
      msg: "Invalid vault lp account"
    },
    {
      code: 6014,
      name: "InvalidPoolLpMintAccount",
      msg: "Invalid pool lp mint account"
    },
    {
      code: 6015,
      name: "PoolDisabled",
      msg: "Pool disabled"
    },
    {
      code: 6016,
      name: "InvalidAdminAccount",
      msg: "Invalid admin account"
    },
    {
      code: 6017,
      name: "InvalidProtocolFeeAccount",
      msg: "Invalid protocol fee account"
    },
    {
      code: 6018,
      name: "SameAdminAccount",
      msg: "Same admin account"
    },
    {
      code: 6019,
      name: "IdenticalSourceDestination",
      msg: "Identical user source and destination token account"
    },
    {
      code: 6020,
      name: "ApyCalculationError",
      msg: "Apy calculation error"
    },
    {
      code: 6021,
      name: "InsufficientSnapshot",
      msg: "Insufficient virtual price snapshot"
    },
    {
      code: 6022,
      name: "NonUpdatableCurve",
      msg: "Current curve is non-updatable"
    },
    {
      code: 6023,
      name: "MisMatchedCurve",
      msg: "New curve is mismatched with old curve"
    },
    {
      code: 6024,
      name: "InvalidAmplification",
      msg: "Amplification is invalid"
    },
    {
      code: 6025,
      name: "UnsupportedOperation",
      msg: "Operation is not supported"
    },
    {
      code: 6026,
      name: "ExceedMaxAChanges",
      msg: "Exceed max amplification changes"
    },
    {
      code: 6027,
      name: "InvalidRemainingAccountsLen",
      msg: "Invalid remaining accounts length"
    },
    {
      code: 6028,
      name: "InvalidRemainingAccounts",
      msg: "Invalid remaining account"
    },
    {
      code: 6029,
      name: "MismatchedDepegMint",
      msg: "Token mint B doesn't matches depeg type token mint"
    },
    {
      code: 6030,
      name: "InvalidApyAccount",
      msg: "Invalid APY account"
    },
    {
      code: 6031,
      name: "InvalidTokenMultiplier",
      msg: "Invalid token multiplier"
    },
    {
      code: 6032,
      name: "InvalidDepegInformation",
      msg: "Invalid depeg information"
    },
    {
      code: 6033,
      name: "UpdateTimeConstraint",
      msg: "Update time constraint violated"
    },
    {
      code: 6034,
      name: "ExceedMaxFeeBps",
      msg: "Exceeded max fee bps"
    },
    {
      code: 6035,
      name: "InvalidAdmin",
      msg: "Invalid admin"
    },
    {
      code: 6036,
      name: "PoolIsNotPermissioned",
      msg: "Pool is not permissioned"
    },
    {
      code: 6037,
      name: "InvalidDepositAmount",
      msg: "Invalid deposit amount"
    },
    {
      code: 6038,
      name: "InvalidFeeOwner",
      msg: "Invalid fee owner"
    },
    {
      code: 6039,
      name: "NonDepletedPool",
      msg: "Pool is not depleted"
    },
    {
      code: 6040,
      name: "AmountNotPeg",
      msg: "Token amount is not 1:1"
    },
    {
      code: 6041,
      name: "AmountIsZero",
      msg: "Amount is zero"
    },
    {
      code: 6042,
      name: "TypeCastFailed",
      msg: "Type cast error"
    },
    {
      code: 6043,
      name: "AmountIsNotEnough",
      msg: "Amount is not enough"
    },
    {
      code: 6044,
      name: "InvalidActivationDuration",
      msg: "Invalid activation duration"
    },
    {
      code: 6045,
      name: "PoolIsNotLaunchPool",
      msg: "Pool is not launch pool"
    },
    {
      code: 6046,
      name: "UnableToModifyActivationPoint",
      msg: "Unable to modify activation point"
    },
    {
      code: 6047,
      name: "InvalidAuthorityToCreateThePool",
      msg: "Invalid authority to create the pool"
    },
    {
      code: 6048,
      name: "InvalidActivationType",
      msg: "Invalid activation type"
    },
    {
      code: 6049,
      name: "InvalidActivationPoint",
      msg: "Invalid activation point"
    },
    {
      code: 6050,
      name: "PreActivationSwapStarted",
      msg: "Pre activation swap window started"
    },
    {
      code: 6051,
      name: "InvalidPoolType",
      msg: "Invalid pool type"
    },
    {
      code: 6052,
      name: "InvalidQuoteMint",
      msg: "Quote token must be SOL,USDC"
    }
  ],
  types: [
    {
      name: "TokenMultiplier",
      docs: [
        "Multiplier for the pool token. Used to normalized token with different decimal into the same precision."
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "token_a_multiplier",
            docs: [
              "Multiplier for token A of the pool."
            ],
            type: "u64"
          },
          {
            name: "token_b_multiplier",
            docs: [
              "Multiplier for token B of the pool."
            ],
            type: "u64"
          },
          {
            name: "precision_factor",
            docs: [
              "Record the highest token decimal in the pool. For example, Token A is 6 decimal, token B is 9 decimal. This will save value of 9."
            ],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "PoolFees",
      docs: [
        "Information regarding fee charges"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "trade_fee_numerator",
            docs: [
              "Trade fees are extra token amounts that are held inside the token",
              "accounts during a trade, making the value of liquidity tokens rise.",
              "Trade fee numerator"
            ],
            type: "u64"
          },
          {
            name: "trade_fee_denominator",
            docs: [
              "Trade fee denominator"
            ],
            type: "u64"
          },
          {
            name: "protocol_trade_fee_numerator",
            docs: [
              "Protocol trading fees are extra token amounts that are held inside the token",
              "accounts during a trade, with the equivalent in pool tokens minted to",
              "the protocol of the program.",
              "Protocol trade fee numerator"
            ],
            type: "u64"
          },
          {
            name: "protocol_trade_fee_denominator",
            docs: [
              "Protocol trade fee denominator"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Depeg",
      docs: [
        "Contains information for depeg pool"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_virtual_price",
            docs: [
              "The virtual price of staking / interest bearing token"
            ],
            type: "u64"
          },
          {
            name: "base_cache_updated",
            docs: [
              "The last time base_virtual_price is updated"
            ],
            type: "u64"
          },
          {
            name: "depeg_type",
            docs: [
              "Type of the depeg pool"
            ],
            type: {
              defined: {
                name: "DepegType"
              }
            }
          }
        ]
      }
    },
    {
      name: "ConfigParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "trade_fee_numerator",
            type: "u64"
          },
          {
            name: "protocol_trade_fee_numerator",
            type: "u64"
          },
          {
            name: "activation_duration",
            type: "u64"
          },
          {
            name: "vault_config_key",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            type: "pubkey"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "index",
            type: "u64"
          },
          {
            name: "partner_fee_numerator",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "CustomizableParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "trade_fee_numerator",
            docs: [
              "Trading fee."
            ],
            type: "u32"
          },
          {
            name: "activation_point",
            docs: [
              "The pool start trading."
            ],
            type: {
              option: "u64"
            }
          },
          {
            name: "has_alpha_vault",
            docs: [
              "Whether the pool support alpha vault"
            ],
            type: "bool"
          },
          {
            name: "activation_type",
            docs: [
              "Activation type"
            ],
            type: "u8"
          },
          {
            name: "padding",
            docs: [
              "Padding"
            ],
            type: {
              array: [
                "u8",
                90
              ]
            }
          }
        ]
      }
    },
    {
      name: "Padding",
      docs: [
        "Padding for future pool fields"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "padding0",
            docs: [
              "Padding 0"
            ],
            type: {
              array: [
                "u8",
                6
              ]
            }
          },
          {
            name: "padding1",
            docs: [
              "Padding 1"
            ],
            type: {
              array: [
                "u64",
                21
              ]
            }
          },
          {
            name: "padding2",
            docs: [
              "Padding 2"
            ],
            type: {
              array: [
                "u64",
                21
              ]
            }
          }
        ]
      }
    },
    {
      name: "PartnerInfo",
      type: {
        kind: "struct",
        fields: [
          {
            name: "fee_numerator",
            type: "u64"
          },
          {
            name: "partner_authority",
            type: "pubkey"
          },
          {
            name: "pending_fee_a",
            type: "u64"
          },
          {
            name: "pending_fee_b",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Bootstrapping",
      type: {
        kind: "struct",
        fields: [
          {
            name: "activation_point",
            docs: [
              "Activation point, can be slot or timestamp"
            ],
            type: "u64"
          },
          {
            name: "whitelisted_vault",
            docs: [
              "Whitelisted vault to be able to buy pool before activation_point"
            ],
            type: "pubkey"
          },
          {
            name: "pool_creator",
            docs: [
              "Need to store pool creator in lauch pool, so they can modify liquidity before activation_point"
            ],
            type: "pubkey"
          },
          {
            name: "activation_type",
            docs: [
              "Activation type, 0 means by slot, 1 means by timestamp"
            ],
            type: "u8"
          }
        ]
      }
    },
    {
      name: "ActivationType",
      docs: [
        "Type of the activation"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Slot"
          },
          {
            name: "Timestamp"
          }
        ]
      }
    },
    {
      name: "RoundDirection",
      docs: [
        "Rounding direction"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Floor"
          },
          {
            name: "Ceiling"
          }
        ]
      }
    },
    {
      name: "TradeDirection",
      docs: [
        "Trade (swap) direction"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "AtoB"
          },
          {
            name: "BtoA"
          }
        ]
      }
    },
    {
      name: "NewCurveType",
      docs: [
        "Type of the swap curve"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "ConstantProduct"
          },
          {
            name: "Stable",
            fields: [
              {
                name: "amp",
                docs: [
                  "Amplification coefficient"
                ],
                type: "u64"
              },
              {
                name: "token_multiplier",
                docs: [
                  "Multiplier for the pool token. Used to normalized token with different decimal into the same precision."
                ],
                type: {
                  defined: {
                    name: "TokenMultiplier"
                  }
                }
              },
              {
                name: "depeg",
                docs: [
                  "Depeg pool information. Contains functions to allow token amount to be repeg using stake / interest bearing token virtual price"
                ],
                type: {
                  defined: {
                    name: "Depeg"
                  }
                }
              },
              {
                name: "last_amp_updated_timestamp",
                docs: [
                  "The last amp updated timestamp. Used to prevent update_curve_info called infinitely many times within a short period"
                ],
                type: "u64"
              }
            ]
          },
          {
            name: "NewCurve",
            fields: [
              {
                name: "field_one",
                type: "u64"
              },
              {
                name: "field_two",
                type: "u64"
              }
            ]
          }
        ]
      }
    },
    {
      name: "CurveType",
      docs: [
        "Type of the swap curve"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "ConstantProduct"
          },
          {
            name: "Stable",
            fields: [
              {
                name: "amp",
                docs: [
                  "Amplification coefficient"
                ],
                type: "u64"
              },
              {
                name: "token_multiplier",
                docs: [
                  "Multiplier for the pool token. Used to normalized token with different decimal into the same precision."
                ],
                type: {
                  defined: {
                    name: "TokenMultiplier"
                  }
                }
              },
              {
                name: "depeg",
                docs: [
                  "Depeg pool information. Contains functions to allow token amount to be repeg using stake / interest bearing token virtual price"
                ],
                type: {
                  defined: {
                    name: "Depeg"
                  }
                }
              },
              {
                name: "last_amp_updated_timestamp",
                docs: [
                  "The last amp updated timestamp. Used to prevent update_curve_info called infinitely many times within a short period"
                ],
                type: "u64"
              }
            ]
          }
        ]
      }
    },
    {
      name: "DepegType",
      docs: [
        "Type of depeg pool"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "None"
          },
          {
            name: "Marinade"
          },
          {
            name: "Lido"
          },
          {
            name: "SplStake"
          }
        ]
      }
    },
    {
      name: "Rounding",
      docs: [
        "Round up, down"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Up"
          },
          {
            name: "Down"
          }
        ]
      }
    },
    {
      name: "PoolType",
      docs: [
        "Pool type"
      ],
      type: {
        kind: "enum",
        variants: [
          {
            name: "Permissioned"
          },
          {
            name: "Permissionless"
          }
        ]
      }
    },
    {
      name: "Config",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFees"
              }
            }
          },
          {
            name: "activation_duration",
            type: "u64"
          },
          {
            name: "vault_config_key",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            docs: [
              "Only pool_creator_authority can use the current config to initialize new pool. When it's Pubkey::default, it's a public config."
            ],
            type: "pubkey"
          },
          {
            name: "activation_type",
            docs: [
              "Activation type"
            ],
            type: "u8"
          },
          {
            name: "partner_fee_numerator",
            type: "u64"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                219
              ]
            }
          }
        ]
      }
    },
    {
      name: "LockEscrow",
      docs: [
        "State of lock escrow account"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            docs: [
              "Pool address"
            ],
            type: "pubkey"
          },
          {
            name: "owner",
            docs: [
              "Owner address"
            ],
            type: "pubkey"
          },
          {
            name: "escrow_vault",
            docs: [
              "Vault address, store the lock user lock"
            ],
            type: "pubkey"
          },
          {
            name: "bump",
            docs: [
              "bump, used to sign"
            ],
            type: "u8"
          },
          {
            name: "total_locked_amount",
            docs: [
              "Total locked amount"
            ],
            type: "u64"
          },
          {
            name: "lp_per_token",
            docs: [
              "Lp per token, virtual price of lp token"
            ],
            type: "u128"
          },
          {
            name: "unclaimed_fee_pending",
            docs: [
              "Unclaimed fee pending"
            ],
            type: "u64"
          },
          {
            name: "a_fee",
            docs: [
              "Total a fee claimed so far"
            ],
            type: "u64"
          },
          {
            name: "b_fee",
            docs: [
              "Total b fee claimed so far"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Pool",
      docs: [
        "State of pool account"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "lp_mint",
            docs: [
              "LP token mint of the pool"
            ],
            type: "pubkey"
          },
          {
            name: "token_a_mint",
            docs: [
              "Token A mint of the pool. Eg: USDT"
            ],
            type: "pubkey"
          },
          {
            name: "token_b_mint",
            docs: [
              "Token B mint of the pool. Eg: USDC"
            ],
            type: "pubkey"
          },
          {
            name: "a_vault",
            docs: [
              "Vault account for token A. Token A of the pool will be deposit / withdraw from this vault account."
            ],
            type: "pubkey"
          },
          {
            name: "b_vault",
            docs: [
              "Vault account for token B. Token B of the pool will be deposit / withdraw from this vault account."
            ],
            type: "pubkey"
          },
          {
            name: "a_vault_lp",
            docs: [
              "LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
            ],
            type: "pubkey"
          },
          {
            name: "b_vault_lp",
            docs: [
              "LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault."
            ],
            type: "pubkey"
          },
          {
            name: "a_vault_lp_bump",
            docs: [
              '"A" vault lp bump. Used to create signer seeds.'
            ],
            type: "u8"
          },
          {
            name: "enabled",
            docs: [
              "Flag to determine whether the pool is enabled, or disabled."
            ],
            type: "bool"
          },
          {
            name: "protocol_token_a_fee",
            docs: [
              "Protocol fee token account for token A. Used to receive trading fee."
            ],
            type: "pubkey"
          },
          {
            name: "protocol_token_b_fee",
            docs: [
              "Protocol fee token account for token B. Used to receive trading fee."
            ],
            type: "pubkey"
          },
          {
            name: "fee_last_updated_at",
            docs: [
              "Fee last updated timestamp"
            ],
            type: "u64"
          },
          {
            name: "padding0",
            type: {
              array: [
                "u8",
                24
              ]
            }
          },
          {
            name: "fees",
            docs: [
              "Store the fee charges setting."
            ],
            type: {
              defined: {
                name: "PoolFees"
              }
            }
          },
          {
            name: "pool_type",
            docs: [
              "Pool type"
            ],
            type: {
              defined: {
                name: "PoolType"
              }
            }
          },
          {
            name: "stake",
            docs: [
              "Stake pubkey of SPL stake pool"
            ],
            type: "pubkey"
          },
          {
            name: "total_locked_lp",
            docs: [
              "Total locked lp token"
            ],
            type: "u64"
          },
          {
            name: "bootstrapping",
            docs: [
              "bootstrapping config"
            ],
            type: {
              defined: {
                name: "Bootstrapping"
              }
            }
          },
          {
            name: "partner_info",
            type: {
              defined: {
                name: "PartnerInfo"
              }
            }
          },
          {
            name: "padding",
            docs: [
              "Padding for future pool field"
            ],
            type: {
              defined: {
                name: "Padding"
              }
            }
          },
          {
            name: "curve_type",
            docs: [
              "The type of the swap curve supported by the pool."
            ],
            type: {
              defined: {
                name: "CurveType"
              }
            }
          }
        ]
      }
    },
    {
      name: "AddLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lp_mint_amount",
            type: "u64"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "RemoveLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lp_unmint_amount",
            type: "u64"
          },
          {
            name: "token_a_out_amount",
            type: "u64"
          },
          {
            name: "token_b_out_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "BootstrapLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lp_mint_amount",
            type: "u64"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          },
          {
            name: "pool",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "Swap",
      type: {
        kind: "struct",
        fields: [
          {
            name: "in_amount",
            type: "u64"
          },
          {
            name: "out_amount",
            type: "u64"
          },
          {
            name: "trade_fee",
            type: "u64"
          },
          {
            name: "protocol_fee",
            type: "u64"
          },
          {
            name: "host_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SetPoolFees",
      type: {
        kind: "struct",
        fields: [
          {
            name: "trade_fee_numerator",
            type: "u64"
          },
          {
            name: "trade_fee_denominator",
            type: "u64"
          },
          {
            name: "protocol_trade_fee_numerator",
            type: "u64"
          },
          {
            name: "protocol_trade_fee_denominator",
            type: "u64"
          },
          {
            name: "pool",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "PoolInfo",
      type: {
        kind: "struct",
        fields: [
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          },
          {
            name: "virtual_price",
            type: "f64"
          },
          {
            name: "current_timestamp",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "TransferAdmin",
      type: {
        kind: "struct",
        fields: [
          {
            name: "admin",
            type: "pubkey"
          },
          {
            name: "new_admin",
            type: "pubkey"
          },
          {
            name: "pool",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "OverrideCurveParam",
      type: {
        kind: "struct",
        fields: [
          {
            name: "new_amp",
            type: "u64"
          },
          {
            name: "updated_timestamp",
            type: "u64"
          },
          {
            name: "pool",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "PoolCreated",
      type: {
        kind: "struct",
        fields: [
          {
            name: "lp_mint",
            type: "pubkey"
          },
          {
            name: "token_a_mint",
            type: "pubkey"
          },
          {
            name: "token_b_mint",
            type: "pubkey"
          },
          {
            name: "pool_type",
            type: {
              defined: {
                name: "PoolType"
              }
            }
          },
          {
            name: "pool",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "PoolEnabled",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "enabled",
            type: "bool"
          }
        ]
      }
    },
    {
      name: "MigrateFeeAccount",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "new_admin_token_a_fee",
            type: "pubkey"
          },
          {
            name: "new_admin_token_b_fee",
            type: "pubkey"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "CreateLockEscrow",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "Lock",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "ClaimFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "amount",
            type: "u64"
          },
          {
            name: "a_fee",
            type: "u64"
          },
          {
            name: "b_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "CreateConfig",
      type: {
        kind: "struct",
        fields: [
          {
            name: "trade_fee_numerator",
            type: "u64"
          },
          {
            name: "protocol_trade_fee_numerator",
            type: "u64"
          },
          {
            name: "config",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "CloseConfig",
      type: {
        kind: "struct",
        fields: [
          {
            name: "config",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "WithdrawProtocolFees",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "protocol_a_fee",
            type: "u64"
          },
          {
            name: "protocol_b_fee",
            type: "u64"
          },
          {
            name: "protocol_a_fee_owner",
            type: "pubkey"
          },
          {
            name: "protocol_b_fee_owner",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "PartnerClaimFees",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "fee_a",
            type: "u64"
          },
          {
            name: "fee_b",
            type: "u64"
          },
          {
            name: "partner",
            type: "pubkey"
          }
        ]
      }
    }
  ]
};

// src/idl/damm-v2/idl.json
var idl_default4 = {
  address: "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG",
  metadata: {
    name: "cp_amm",
    version: "0.1.0",
    spec: "0.1.0",
    description: "Created with Anchor"
  },
  instructions: [
    {
      name: "add_liquidity",
      discriminator: [
        181,
        157,
        89,
        67,
        143,
        182,
        52,
        72
      ],
      accounts: [
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "AddLiquidityParameters"
            }
          }
        }
      ]
    },
    {
      name: "claim_partner_fee",
      discriminator: [
        97,
        206,
        39,
        105,
        94,
        94,
        126,
        148
      ],
      accounts: [
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The treasury token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The treasury token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "partner",
          signer: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "max_amount_a",
          type: "u64"
        },
        {
          name: "max_amount_b",
          type: "u64"
        }
      ]
    },
    {
      name: "claim_position_fee",
      discriminator: [
        180,
        38,
        154,
        17,
        133,
        33,
        162,
        211
      ],
      accounts: [
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "claim_protocol_fee",
      discriminator: [
        165,
        228,
        133,
        48,
        99,
        249,
        255,
        33
      ],
      accounts: [
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_account",
          docs: [
            "The treasury token a account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  153,
                  10,
                  107,
                  154,
                  255,
                  249,
                  210,
                  173,
                  176,
                  67,
                  220,
                  214,
                  152,
                  71,
                  46,
                  146,
                  161,
                  33,
                  81,
                  148,
                  166,
                  119,
                  5,
                  189,
                  142,
                  11,
                  57,
                  68,
                  162,
                  70,
                  126,
                  100
                ]
              },
              {
                kind: "account",
                path: "token_a_program"
              },
              {
                kind: "account",
                path: "token_a_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "token_b_account",
          docs: [
            "The treasury token b account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  153,
                  10,
                  107,
                  154,
                  255,
                  249,
                  210,
                  173,
                  176,
                  67,
                  220,
                  214,
                  152,
                  71,
                  46,
                  146,
                  161,
                  33,
                  81,
                  148,
                  166,
                  119,
                  5,
                  189,
                  142,
                  11,
                  57,
                  68,
                  162,
                  70,
                  126,
                  100
                ]
              },
              {
                kind: "account",
                path: "token_b_program"
              },
              {
                kind: "account",
                path: "token_b_mint"
              }
            ],
            program: {
              kind: "const",
              value: [
                140,
                151,
                37,
                143,
                78,
                36,
                137,
                241,
                187,
                61,
                16,
                41,
                20,
                142,
                13,
                131,
                11,
                90,
                19,
                153,
                218,
                255,
                16,
                132,
                4,
                142,
                123,
                216,
                219,
                233,
                248,
                89
              ]
            }
          }
        },
        {
          name: "claim_fee_operator",
          docs: [
            "Claim fee operator"
          ]
        },
        {
          name: "operator",
          docs: [
            "Operator"
          ],
          signer: true,
          relations: [
            "claim_fee_operator"
          ]
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "claim_reward",
      discriminator: [
        149,
        95,
        181,
        242,
        94,
        90,
        158,
        162
      ],
      accounts: [
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "reward_vault",
          docs: [
            "The vault token account for reward token"
          ],
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "user_token_account",
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        }
      ]
    },
    {
      name: "close_claim_fee_operator",
      discriminator: [
        38,
        134,
        82,
        216,
        95,
        124,
        17,
        99
      ],
      accounts: [
        {
          name: "claim_fee_operator",
          writable: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_config",
      discriminator: [
        145,
        9,
        72,
        157,
        95,
        125,
        61,
        85
      ],
      accounts: [
        {
          name: "config",
          writable: true
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "close_position",
      discriminator: [
        123,
        134,
        81,
        0,
        49,
        68,
        98,
        98
      ],
      accounts: [
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ],
          writable: true
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "rent_receiver",
          writable: true
        },
        {
          name: "owner",
          docs: [
            "Owner of position"
          ],
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "create_claim_fee_operator",
      discriminator: [
        169,
        62,
        207,
        107,
        58,
        187,
        162,
        109
      ],
      accounts: [
        {
          name: "claim_fee_operator",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  102,
                  95,
                  111,
                  112,
                  101,
                  114,
                  97,
                  116,
                  111,
                  114
                ]
              },
              {
                kind: "account",
                path: "operator"
              }
            ]
          }
        },
        {
          name: "operator"
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "create_config",
      docs: [
        "ADMIN FUNCTIONS /////"
      ],
      discriminator: [
        201,
        207,
        243,
        114,
        75,
        111,
        47,
        189
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "arg",
                path: "config_parameters.index"
              }
            ]
          }
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "config_parameters",
          type: {
            defined: {
              name: "ConfigParameters"
            }
          }
        }
      ]
    },
    {
      name: "create_position",
      discriminator: [
        48,
        215,
        197,
        153,
        96,
        203,
        180,
        133
      ],
      accounts: [
        {
          name: "owner"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the position. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "token_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "create_token_badge",
      discriminator: [
        88,
        206,
        0,
        91,
        60,
        175,
        151,
        118
      ],
      accounts: [
        {
          name: "token_badge",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  98,
                  97,
                  100,
                  103,
                  101
                ]
              },
              {
                kind: "account",
                path: "token_mint"
              }
            ]
          }
        },
        {
          name: "token_mint"
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: []
    },
    {
      name: "fund_reward",
      discriminator: [
        188,
        50,
        249,
        165,
        93,
        151,
        38,
        63
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "reward_vault",
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "funder_token_account",
          writable: true
        },
        {
          name: "funder",
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "carry_forward",
          type: "bool"
        }
      ]
    },
    {
      name: "initialize_customizable_pool",
      discriminator: [
        20,
        161,
        241,
        24,
        189,
        221,
        180,
        2
      ],
      accounts: [
        {
          name: "creator"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the pool. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          docs: [
            "Initialize an account to store the pool state"
          ],
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "token_a_mint",
          docs: [
            "Token a mint"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token b mint"
          ]
        },
        {
          name: "token_a_vault",
          docs: [
            "Token a vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_a_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "token_b_vault",
          docs: [
            "Token b vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_b_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "payer_token_a",
          docs: [
            "payer token a account"
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "creator token b account"
          ],
          writable: true
        },
        {
          name: "token_a_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_2022_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializeCustomizablePoolParameters"
            }
          }
        }
      ]
    },
    {
      name: "initialize_pool",
      docs: [
        "USER FUNCTIONS ////"
      ],
      discriminator: [
        95,
        180,
        10,
        172,
        84,
        174,
        232,
        40
      ],
      accounts: [
        {
          name: "creator"
        },
        {
          name: "position_nft_mint",
          docs: [
            "position_nft_mint"
          ],
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "position nft account"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110,
                  95,
                  110,
                  102,
                  116,
                  95,
                  97,
                  99,
                  99,
                  111,
                  117,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "payer",
          docs: [
            "Address paying to create the pool. Can be anyone"
          ],
          writable: true,
          signer: true
        },
        {
          name: "config",
          docs: [
            "Which config the pool belongs to."
          ]
        },
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          docs: [
            "Initialize an account to store the pool state"
          ],
          writable: true
        },
        {
          name: "position",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  115,
                  105,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "position_nft_mint"
              }
            ]
          }
        },
        {
          name: "token_a_mint",
          docs: [
            "Token a mint"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "Token b mint"
          ]
        },
        {
          name: "token_a_vault",
          docs: [
            "Token a vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_a_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "token_b_vault",
          docs: [
            "Token b vault for the pool"
          ],
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  116,
                  111,
                  107,
                  101,
                  110,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "token_b_mint"
              },
              {
                kind: "account",
                path: "pool"
              }
            ]
          }
        },
        {
          name: "payer_token_a",
          docs: [
            "payer token a account"
          ],
          writable: true
        },
        {
          name: "payer_token_b",
          docs: [
            "creator token b account"
          ],
          writable: true
        },
        {
          name: "token_a_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Program to create mint account and mint tokens"
          ]
        },
        {
          name: "token_2022_program",
          docs: [
            "Program to create NFT mint/token account and transfer for token22 account"
          ],
          address: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "InitializePoolParameters"
            }
          }
        }
      ]
    },
    {
      name: "initialize_reward",
      discriminator: [
        95,
        135,
        192,
        196,
        242,
        129,
        230,
        68
      ],
      accounts: [
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "reward_vault",
          writable: true,
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  119,
                  97,
                  114,
                  100,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "pool"
              },
              {
                kind: "arg",
                path: "reward_index"
              }
            ]
          }
        },
        {
          name: "reward_mint"
        },
        {
          name: "admin",
          writable: true,
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "reward_duration",
          type: "u64"
        },
        {
          name: "funder",
          type: "pubkey"
        }
      ]
    },
    {
      name: "lock_position",
      discriminator: [
        227,
        62,
        2,
        252,
        247,
        10,
        171,
        185
      ],
      accounts: [
        {
          name: "pool",
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "vesting",
          writable: true,
          signer: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "payer",
          writable: true,
          signer: true
        },
        {
          name: "system_program",
          address: "11111111111111111111111111111111"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "VestingParameters"
            }
          }
        }
      ]
    },
    {
      name: "permanent_lock_position",
      discriminator: [
        165,
        176,
        125,
        6,
        231,
        171,
        186,
        213
      ],
      accounts: [
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "permanent_lock_liquidity",
          type: "u128"
        }
      ]
    },
    {
      name: "refresh_vesting",
      discriminator: [
        9,
        94,
        216,
        14,
        116,
        204,
        247,
        0
      ],
      accounts: [
        {
          name: "pool",
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner"
        }
      ],
      args: []
    },
    {
      name: "remove_all_liquidity",
      discriminator: [
        10,
        51,
        61,
        35,
        112,
        105,
        24,
        85
      ],
      accounts: [
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "token_a_amount_threshold",
          type: "u64"
        },
        {
          name: "token_b_amount_threshold",
          type: "u64"
        }
      ]
    },
    {
      name: "remove_liquidity",
      discriminator: [
        80,
        85,
        209,
        72,
        24,
        206,
        177,
        108
      ],
      accounts: [
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          writable: true,
          relations: [
            "position"
          ]
        },
        {
          name: "position",
          writable: true
        },
        {
          name: "token_a_account",
          docs: [
            "The user token a account"
          ],
          writable: true
        },
        {
          name: "token_b_account",
          docs: [
            "The user token b account"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ],
          relations: [
            "pool"
          ]
        },
        {
          name: "position_nft_account",
          docs: [
            "The token account for nft"
          ]
        },
        {
          name: "owner",
          docs: [
            "owner of position"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "RemoveLiquidityParameters"
            }
          }
        }
      ]
    },
    {
      name: "set_pool_status",
      discriminator: [
        112,
        87,
        135,
        223,
        83,
        204,
        132,
        53
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "status",
          type: "u8"
        }
      ]
    },
    {
      name: "swap",
      discriminator: [
        248,
        198,
        158,
        145,
        225,
        117,
        135,
        200
      ],
      accounts: [
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          docs: [
            "Pool account"
          ],
          writable: true
        },
        {
          name: "input_token_account",
          docs: [
            "The user token account for input token"
          ],
          writable: true
        },
        {
          name: "output_token_account",
          docs: [
            "The user token account for output token"
          ],
          writable: true
        },
        {
          name: "token_a_vault",
          docs: [
            "The vault token account for input token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_b_vault",
          docs: [
            "The vault token account for output token"
          ],
          writable: true,
          relations: [
            "pool"
          ]
        },
        {
          name: "token_a_mint",
          docs: [
            "The mint of token a"
          ]
        },
        {
          name: "token_b_mint",
          docs: [
            "The mint of token b"
          ]
        },
        {
          name: "payer",
          docs: [
            "The user performing the swap"
          ],
          signer: true
        },
        {
          name: "token_a_program",
          docs: [
            "Token a program"
          ]
        },
        {
          name: "token_b_program",
          docs: [
            "Token b program"
          ]
        },
        {
          name: "referral_token_account",
          docs: [
            "referral token account"
          ],
          writable: true,
          optional: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: {
              name: "SwapParameters"
            }
          }
        }
      ]
    },
    {
      name: "update_reward_duration",
      discriminator: [
        138,
        174,
        196,
        169,
        213,
        235,
        254,
        107
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "new_duration",
          type: "u64"
        }
      ]
    },
    {
      name: "update_reward_funder",
      discriminator: [
        211,
        28,
        48,
        32,
        215,
        160,
        35,
        23
      ],
      accounts: [
        {
          name: "pool",
          writable: true
        },
        {
          name: "admin",
          signer: true
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        },
        {
          name: "new_funder",
          type: "pubkey"
        }
      ]
    },
    {
      name: "withdraw_ineligible_reward",
      discriminator: [
        148,
        206,
        42,
        195,
        247,
        49,
        103,
        8
      ],
      accounts: [
        {
          name: "pool_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  111,
                  111,
                  108,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "pool",
          writable: true
        },
        {
          name: "reward_vault",
          writable: true
        },
        {
          name: "reward_mint"
        },
        {
          name: "funder_token_account",
          writable: true
        },
        {
          name: "funder",
          signer: true
        },
        {
          name: "token_program"
        },
        {
          name: "event_authority",
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  95,
                  95,
                  101,
                  118,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104,
                  111,
                  114,
                  105,
                  116,
                  121
                ]
              }
            ]
          }
        },
        {
          name: "program"
        }
      ],
      args: [
        {
          name: "reward_index",
          type: "u8"
        }
      ]
    }
  ],
  accounts: [
    {
      name: "ClaimFeeOperator",
      discriminator: [
        166,
        48,
        134,
        86,
        34,
        200,
        188,
        150
      ]
    },
    {
      name: "Config",
      discriminator: [
        155,
        12,
        170,
        224,
        30,
        250,
        204,
        130
      ]
    },
    {
      name: "Pool",
      discriminator: [
        241,
        154,
        109,
        4,
        17,
        177,
        109,
        188
      ]
    },
    {
      name: "Position",
      discriminator: [
        170,
        188,
        143,
        228,
        122,
        64,
        247,
        208
      ]
    },
    {
      name: "TokenBadge",
      discriminator: [
        116,
        219,
        204,
        229,
        249,
        116,
        255,
        150
      ]
    },
    {
      name: "Vesting",
      discriminator: [
        100,
        149,
        66,
        138,
        95,
        200,
        128,
        241
      ]
    }
  ],
  events: [
    {
      name: "EvtAddLiquidity",
      discriminator: [
        175,
        242,
        8,
        157,
        30,
        247,
        185,
        169
      ]
    },
    {
      name: "EvtClaimPartnerFee",
      discriminator: [
        118,
        99,
        77,
        10,
        226,
        1,
        1,
        87
      ]
    },
    {
      name: "EvtClaimPositionFee",
      discriminator: [
        198,
        182,
        183,
        52,
        97,
        12,
        49,
        56
      ]
    },
    {
      name: "EvtClaimProtocolFee",
      discriminator: [
        186,
        244,
        75,
        251,
        188,
        13,
        25,
        33
      ]
    },
    {
      name: "EvtClaimReward",
      discriminator: [
        218,
        86,
        147,
        200,
        235,
        188,
        215,
        231
      ]
    },
    {
      name: "EvtCloseClaimFeeOperator",
      discriminator: [
        111,
        39,
        37,
        55,
        110,
        216,
        194,
        23
      ]
    },
    {
      name: "EvtCloseConfig",
      discriminator: [
        36,
        30,
        239,
        45,
        58,
        132,
        14,
        5
      ]
    },
    {
      name: "EvtClosePosition",
      discriminator: [
        20,
        145,
        144,
        68,
        143,
        142,
        214,
        178
      ]
    },
    {
      name: "EvtCreateClaimFeeOperator",
      discriminator: [
        21,
        6,
        153,
        120,
        68,
        116,
        28,
        177
      ]
    },
    {
      name: "EvtCreateConfig",
      discriminator: [
        131,
        207,
        180,
        174,
        180,
        73,
        165,
        54
      ]
    },
    {
      name: "EvtCreatePosition",
      discriminator: [
        156,
        15,
        119,
        198,
        29,
        181,
        221,
        55
      ]
    },
    {
      name: "EvtCreateTokenBadge",
      discriminator: [
        141,
        120,
        134,
        116,
        34,
        28,
        114,
        160
      ]
    },
    {
      name: "EvtFundReward",
      discriminator: [
        104,
        233,
        237,
        122,
        199,
        191,
        121,
        85
      ]
    },
    {
      name: "EvtInitializePool",
      discriminator: [
        228,
        50,
        246,
        85,
        203,
        66,
        134,
        37
      ]
    },
    {
      name: "EvtInitializeReward",
      discriminator: [
        129,
        91,
        188,
        3,
        246,
        52,
        185,
        249
      ]
    },
    {
      name: "EvtLockPosition",
      discriminator: [
        168,
        63,
        108,
        83,
        219,
        82,
        2,
        200
      ]
    },
    {
      name: "EvtPermanentLockPosition",
      discriminator: [
        145,
        143,
        162,
        218,
        218,
        80,
        67,
        11
      ]
    },
    {
      name: "EvtRemoveLiquidity",
      discriminator: [
        87,
        46,
        88,
        98,
        175,
        96,
        34,
        91
      ]
    },
    {
      name: "EvtSetPoolStatus",
      discriminator: [
        100,
        213,
        74,
        3,
        95,
        91,
        228,
        146
      ]
    },
    {
      name: "EvtSwap",
      discriminator: [
        27,
        60,
        21,
        213,
        138,
        170,
        187,
        147
      ]
    },
    {
      name: "EvtUpdateRewardDuration",
      discriminator: [
        149,
        135,
        65,
        231,
        129,
        153,
        65,
        57
      ]
    },
    {
      name: "EvtUpdateRewardFunder",
      discriminator: [
        76,
        154,
        208,
        13,
        40,
        115,
        246,
        146
      ]
    },
    {
      name: "EvtWithdrawIneligibleReward",
      discriminator: [
        248,
        215,
        184,
        78,
        31,
        180,
        179,
        168
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "MathOverflow",
      msg: "Math operation overflow"
    },
    {
      code: 6001,
      name: "InvalidFee",
      msg: "Invalid fee setup"
    },
    {
      code: 6002,
      name: "ExceededSlippage",
      msg: "Exceeded slippage tolerance"
    },
    {
      code: 6003,
      name: "PoolDisabled",
      msg: "Pool disabled"
    },
    {
      code: 6004,
      name: "ExceedMaxFeeBps",
      msg: "Exceeded max fee bps"
    },
    {
      code: 6005,
      name: "InvalidAdmin",
      msg: "Invalid admin"
    },
    {
      code: 6006,
      name: "AmountIsZero",
      msg: "Amount is zero"
    },
    {
      code: 6007,
      name: "TypeCastFailed",
      msg: "Type cast error"
    },
    {
      code: 6008,
      name: "UnableToModifyActivationPoint",
      msg: "Unable to modify activation point"
    },
    {
      code: 6009,
      name: "InvalidAuthorityToCreateThePool",
      msg: "Invalid authority to create the pool"
    },
    {
      code: 6010,
      name: "InvalidActivationType",
      msg: "Invalid activation type"
    },
    {
      code: 6011,
      name: "InvalidActivationPoint",
      msg: "Invalid activation point"
    },
    {
      code: 6012,
      name: "InvalidQuoteMint",
      msg: "Quote token must be SOL,USDC"
    },
    {
      code: 6013,
      name: "InvalidFeeCurve",
      msg: "Invalid fee curve"
    },
    {
      code: 6014,
      name: "InvalidPriceRange",
      msg: "Invalid Price Range"
    },
    {
      code: 6015,
      name: "PriceRangeViolation",
      msg: "Trade is over price range"
    },
    {
      code: 6016,
      name: "InvalidParameters",
      msg: "Invalid parameters"
    },
    {
      code: 6017,
      name: "InvalidCollectFeeMode",
      msg: "Invalid collect fee mode"
    },
    {
      code: 6018,
      name: "InvalidInput",
      msg: "Invalid input"
    },
    {
      code: 6019,
      name: "CannotCreateTokenBadgeOnSupportedMint",
      msg: "Cannot create token badge on supported mint"
    },
    {
      code: 6020,
      name: "InvalidTokenBadge",
      msg: "Invalid token badge"
    },
    {
      code: 6021,
      name: "InvalidMinimumLiquidity",
      msg: "Invalid minimum liquidity"
    },
    {
      code: 6022,
      name: "InvalidVestingInfo",
      msg: "Invalid vesting information"
    },
    {
      code: 6023,
      name: "InsufficientLiquidity",
      msg: "Insufficient liquidity"
    },
    {
      code: 6024,
      name: "InvalidVestingAccount",
      msg: "Invalid vesting account"
    },
    {
      code: 6025,
      name: "InvalidPoolStatus",
      msg: "Invalid pool status"
    },
    {
      code: 6026,
      name: "UnsupportNativeMintToken2022",
      msg: "Unsupported native mint token2022"
    },
    {
      code: 6027,
      name: "InvalidRewardIndex",
      msg: "Invalid reward index"
    },
    {
      code: 6028,
      name: "InvalidRewardDuration",
      msg: "Invalid reward duration"
    },
    {
      code: 6029,
      name: "RewardInitialized",
      msg: "Reward already initialized"
    },
    {
      code: 6030,
      name: "RewardUninitialized",
      msg: "Reward not initialized"
    },
    {
      code: 6031,
      name: "InvalidRewardVault",
      msg: "Invalid reward vault"
    },
    {
      code: 6032,
      name: "MustWithdrawnIneligibleReward",
      msg: "Must withdraw ineligible reward"
    },
    {
      code: 6033,
      name: "IdenticalRewardDuration",
      msg: "Reward duration is the same"
    },
    {
      code: 6034,
      name: "RewardCampaignInProgress",
      msg: "Reward campaign in progress"
    },
    {
      code: 6035,
      name: "IdenticalFunder",
      msg: "Identical funder"
    },
    {
      code: 6036,
      name: "InvalidFunder",
      msg: "Invalid funder"
    },
    {
      code: 6037,
      name: "RewardNotEnded",
      msg: "Reward not ended"
    },
    {
      code: 6038,
      name: "FeeInverseIsIncorrect",
      msg: "Fee inverse is incorrect"
    },
    {
      code: 6039,
      name: "PositionIsNotEmpty",
      msg: "Position is not empty"
    }
  ],
  types: [
    {
      name: "AddLiquidityParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity_delta",
            docs: [
              "delta liquidity"
            ],
            type: "u128"
          },
          {
            name: "token_a_amount_threshold",
            docs: [
              "maximum token a amount"
            ],
            type: "u64"
          },
          {
            name: "token_b_amount_threshold",
            docs: [
              "maximum token b amount"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "BaseFeeConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "fee_scheduler_mode",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "reduction_factor",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "BaseFeeParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "reduction_factor",
            type: "u64"
          },
          {
            name: "fee_scheduler_mode",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "BaseFeeStruct",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_fee_numerator",
            type: "u64"
          },
          {
            name: "fee_scheduler_mode",
            type: "u8"
          },
          {
            name: "padding_0",
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "reduction_factor",
            type: "u64"
          },
          {
            name: "padding_1",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "ClaimFeeOperator",
      docs: [
        "Parameter that set by the protocol"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "operator",
            docs: [
              "operator"
            ],
            type: "pubkey"
          },
          {
            name: "_padding",
            docs: [
              "Reserve"
            ],
            type: {
              array: [
                "u8",
                128
              ]
            }
          }
        ]
      }
    },
    {
      name: "Config",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "vault_config_key",
            docs: [
              "Vault config key"
            ],
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            docs: [
              "Only pool_creator_authority can use the current config to initialize new pool. When it's Pubkey::default, it's a public config."
            ],
            type: "pubkey"
          },
          {
            name: "pool_fees",
            docs: [
              "Pool fee"
            ],
            type: {
              defined: {
                name: "PoolFeesConfig"
              }
            }
          },
          {
            name: "activation_type",
            docs: [
              "Activation type"
            ],
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            docs: [
              "Collect fee mode"
            ],
            type: "u8"
          },
          {
            name: "_padding_0",
            docs: [
              "padding 0"
            ],
            type: {
              array: [
                "u8",
                6
              ]
            }
          },
          {
            name: "index",
            docs: [
              "config index"
            ],
            type: "u64"
          },
          {
            name: "sqrt_min_price",
            docs: [
              "sqrt min price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            docs: [
              "sqrt max price"
            ],
            type: "u128"
          },
          {
            name: "_padding_1",
            docs: [
              "Fee curve point",
              "Padding for further use"
            ],
            type: {
              array: [
                "u64",
                10
              ]
            }
          }
        ]
      }
    },
    {
      name: "ConfigParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "sqrt_min_price",
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            type: "u128"
          },
          {
            name: "vault_config_key",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            type: "pubkey"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          },
          {
            name: "index",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "DynamicFeeConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "initialized",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                7
              ]
            }
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          },
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "padding_1",
            type: {
              array: [
                "u8",
                8
              ]
            }
          },
          {
            name: "bin_step_u128",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "DynamicFeeParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "bin_step_u128",
            type: "u128"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          }
        ]
      }
    },
    {
      name: "DynamicFeeStruct",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "initialized",
            type: "u8"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                7
              ]
            }
          },
          {
            name: "max_volatility_accumulator",
            type: "u32"
          },
          {
            name: "variable_fee_control",
            type: "u32"
          },
          {
            name: "bin_step",
            type: "u16"
          },
          {
            name: "filter_period",
            type: "u16"
          },
          {
            name: "decay_period",
            type: "u16"
          },
          {
            name: "reduction_factor",
            type: "u16"
          },
          {
            name: "last_update_timestamp",
            type: "u64"
          },
          {
            name: "bin_step_u128",
            type: "u128"
          },
          {
            name: "sqrt_price_reference",
            type: "u128"
          },
          {
            name: "volatility_accumulator",
            type: "u128"
          },
          {
            name: "volatility_reference",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "EvtAddLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "params",
            type: {
              defined: {
                name: "AddLiquidityParameters"
              }
            }
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          },
          {
            name: "total_amount_a",
            type: "u64"
          },
          {
            name: "total_amount_b",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimPartnerFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimPositionFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "fee_a_claimed",
            type: "u64"
          },
          {
            name: "fee_b_claimed",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimProtocolFee",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtClaimReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "mint_reward",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "total_reward",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtCloseClaimFeeOperator",
      docs: [
        "Close claim fee operator"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "claim_fee_operator",
            type: "pubkey"
          },
          {
            name: "operator",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCloseConfig",
      docs: [
        "Close config"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "config",
            docs: [
              "Config pubkey"
            ],
            type: "pubkey"
          },
          {
            name: "admin",
            docs: [
              "admin pk"
            ],
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtClosePosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "position_nft_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateClaimFeeOperator",
      docs: [
        "Create claim fee operator"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "operator",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateConfig",
      docs: [
        "Create config"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "vault_config_key",
            type: "pubkey"
          },
          {
            name: "pool_creator_authority",
            type: "pubkey"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "sqrt_min_price",
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            type: "u128"
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          },
          {
            name: "index",
            type: "u64"
          },
          {
            name: "config",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreatePosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "position_nft_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtCreateTokenBadge",
      docs: [
        "Create token badge"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "token_mint",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtFundReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "funder",
            type: "pubkey"
          },
          {
            name: "mint_reward",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "amount",
            type: "u64"
          },
          {
            name: "transfer_fee_excluded_amount_in",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtInitializePool",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "token_a_mint",
            type: "pubkey"
          },
          {
            name: "token_b_mint",
            type: "pubkey"
          },
          {
            name: "creator",
            type: "pubkey"
          },
          {
            name: "payer",
            type: "pubkey"
          },
          {
            name: "alpha_vault",
            type: "pubkey"
          },
          {
            name: "pool_fees",
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "sqrt_min_price",
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            type: "u128"
          },
          {
            name: "activation_type",
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            type: "u8"
          },
          {
            name: "liquidity",
            type: "u128"
          },
          {
            name: "sqrt_price",
            type: "u128"
          },
          {
            name: "activation_point",
            type: "u64"
          },
          {
            name: "token_a_flag",
            type: "u8"
          },
          {
            name: "token_b_flag",
            type: "u8"
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          },
          {
            name: "total_amount_a",
            type: "u64"
          },
          {
            name: "total_amount_b",
            type: "u64"
          },
          {
            name: "pool_type",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "EvtInitializeReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_mint",
            type: "pubkey"
          },
          {
            name: "funder",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "reward_duration",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtLockPosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "vesting",
            type: "pubkey"
          },
          {
            name: "cliff_point",
            type: "u64"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "cliff_unlock_liquidity",
            type: "u128"
          },
          {
            name: "liquidity_per_period",
            type: "u128"
          },
          {
            name: "number_of_period",
            type: "u16"
          }
        ]
      }
    },
    {
      name: "EvtPermanentLockPosition",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "lock_liquidity_amount",
            type: "u128"
          },
          {
            name: "total_permanent_locked_liquidity",
            type: "u128"
          }
        ]
      }
    },
    {
      name: "EvtRemoveLiquidity",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "owner",
            type: "pubkey"
          },
          {
            name: "params",
            type: {
              defined: {
                name: "RemoveLiquidityParameters"
              }
            }
          },
          {
            name: "token_a_amount",
            type: "u64"
          },
          {
            name: "token_b_amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtSetPoolStatus",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "status",
            type: "u8"
          }
        ]
      }
    },
    {
      name: "EvtSwap",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "trade_direction",
            type: "u8"
          },
          {
            name: "has_referral",
            type: "bool"
          },
          {
            name: "params",
            type: {
              defined: {
                name: "SwapParameters"
              }
            }
          },
          {
            name: "swap_result",
            type: {
              defined: {
                name: "SwapResult"
              }
            }
          },
          {
            name: "actual_amount_in",
            type: "u64"
          },
          {
            name: "current_timestamp",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtUpdateRewardDuration",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "old_reward_duration",
            type: "u64"
          },
          {
            name: "new_reward_duration",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "EvtUpdateRewardFunder",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_index",
            type: "u8"
          },
          {
            name: "old_funder",
            type: "pubkey"
          },
          {
            name: "new_funder",
            type: "pubkey"
          }
        ]
      }
    },
    {
      name: "EvtWithdrawIneligibleReward",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "reward_mint",
            type: "pubkey"
          },
          {
            name: "amount",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "InitializeCustomizablePoolParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            docs: [
              "pool fees"
            ],
            type: {
              defined: {
                name: "PoolFeeParameters"
              }
            }
          },
          {
            name: "sqrt_min_price",
            docs: [
              "sqrt min price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            docs: [
              "sqrt max price"
            ],
            type: "u128"
          },
          {
            name: "has_alpha_vault",
            docs: [
              "has alpha vault"
            ],
            type: "bool"
          },
          {
            name: "liquidity",
            docs: [
              "initialize liquidity"
            ],
            type: "u128"
          },
          {
            name: "sqrt_price",
            docs: [
              "The init price of the pool as a sqrt(token_b/token_a) Q64.64 value"
            ],
            type: "u128"
          },
          {
            name: "activation_type",
            docs: [
              "activation type"
            ],
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            docs: [
              "collect fee mode"
            ],
            type: "u8"
          },
          {
            name: "activation_point",
            docs: [
              "activation point"
            ],
            type: {
              option: "u64"
            }
          }
        ]
      }
    },
    {
      name: "InitializePoolParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity",
            docs: [
              "initialize liquidity"
            ],
            type: "u128"
          },
          {
            name: "sqrt_price",
            docs: [
              "The init price of the pool as a sqrt(token_b/token_a) Q64.64 value"
            ],
            type: "u128"
          },
          {
            name: "activation_point",
            docs: [
              "activation point"
            ],
            type: {
              option: "u64"
            }
          }
        ]
      }
    },
    {
      name: "Pool",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool_fees",
            docs: [
              "Pool fee"
            ],
            type: {
              defined: {
                name: "PoolFeesStruct"
              }
            }
          },
          {
            name: "token_a_mint",
            docs: [
              "token a mint"
            ],
            type: "pubkey"
          },
          {
            name: "token_b_mint",
            docs: [
              "token b mint"
            ],
            type: "pubkey"
          },
          {
            name: "token_a_vault",
            docs: [
              "token a vault"
            ],
            type: "pubkey"
          },
          {
            name: "token_b_vault",
            docs: [
              "token b vault"
            ],
            type: "pubkey"
          },
          {
            name: "whitelisted_vault",
            docs: [
              "Whitelisted vault to be able to buy pool before activation_point"
            ],
            type: "pubkey"
          },
          {
            name: "partner",
            docs: [
              "partner"
            ],
            type: "pubkey"
          },
          {
            name: "liquidity",
            docs: [
              "liquidity share"
            ],
            type: "u128"
          },
          {
            name: "token_a_reserve",
            docs: [
              "token a reserve"
            ],
            type: "u64"
          },
          {
            name: "token_b_reserve",
            docs: [
              "token b reserve"
            ],
            type: "u64"
          },
          {
            name: "protocol_a_fee",
            docs: [
              "protocol a fee"
            ],
            type: "u64"
          },
          {
            name: "protocol_b_fee",
            docs: [
              "protocol b fee"
            ],
            type: "u64"
          },
          {
            name: "partner_a_fee",
            docs: [
              "partner a fee"
            ],
            type: "u64"
          },
          {
            name: "partner_b_fee",
            docs: [
              "partner b fee"
            ],
            type: "u64"
          },
          {
            name: "sqrt_min_price",
            docs: [
              "min price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_max_price",
            docs: [
              "max price"
            ],
            type: "u128"
          },
          {
            name: "sqrt_price",
            docs: [
              "current price"
            ],
            type: "u128"
          },
          {
            name: "activation_point",
            docs: [
              "Activation point, can be slot or timestamp"
            ],
            type: "u64"
          },
          {
            name: "activation_type",
            docs: [
              "Activation type, 0 means by slot, 1 means by timestamp"
            ],
            type: "u8"
          },
          {
            name: "pool_status",
            docs: [
              "pool status, 0: enable, 1 disable"
            ],
            type: "u8"
          },
          {
            name: "token_a_flag",
            docs: [
              "token a flag"
            ],
            type: "u8"
          },
          {
            name: "token_b_flag",
            docs: [
              "token b flag"
            ],
            type: "u8"
          },
          {
            name: "collect_fee_mode",
            docs: [
              "0 is collect fee in both token, 1 only collect fee in token a, 2 only collect fee in token b"
            ],
            type: "u8"
          },
          {
            name: "pool_type",
            docs: [
              "pool type"
            ],
            type: "u8"
          },
          {
            name: "_padding_0",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u8",
                2
              ]
            }
          },
          {
            name: "fee_a_per_liquidity",
            docs: [
              "cumulative"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "fee_b_per_liquidity",
            docs: [
              "cumulative"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "permanent_lock_liquidity",
            type: "u128"
          },
          {
            name: "metrics",
            docs: [
              "metrics"
            ],
            type: {
              defined: {
                name: "PoolMetrics"
              }
            }
          },
          {
            name: "_padding_1",
            docs: [
              "Padding for further use"
            ],
            type: {
              array: [
                "u64",
                10
              ]
            }
          },
          {
            name: "reward_infos",
            docs: [
              "Farming reward information"
            ],
            type: {
              array: [
                {
                  defined: {
                    name: "RewardInfo"
                  }
                },
                2
              ]
            }
          }
        ]
      }
    },
    {
      name: "PoolFeeParameters",
      docs: [
        "Information regarding fee charges"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            docs: [
              "Base fee"
            ],
            type: {
              defined: {
                name: "BaseFeeParameters"
              }
            }
          },
          {
            name: "protocol_fee_percent",
            docs: [
              "Protocol trade fee percent"
            ],
            type: "u8"
          },
          {
            name: "partner_fee_percent",
            docs: [
              "partner fee percent"
            ],
            type: "u8"
          },
          {
            name: "referral_fee_percent",
            docs: [
              "referral fee percent"
            ],
            type: "u8"
          },
          {
            name: "dynamic_fee",
            docs: [
              "dynamic fee"
            ],
            type: {
              option: {
                defined: {
                  name: "DynamicFeeParameters"
                }
              }
            }
          }
        ]
      }
    },
    {
      name: "PoolFeesConfig",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            type: {
              defined: {
                name: "BaseFeeConfig"
              }
            }
          },
          {
            name: "dynamic_fee",
            type: {
              defined: {
                name: "DynamicFeeConfig"
              }
            }
          },
          {
            name: "protocol_fee_percent",
            type: "u8"
          },
          {
            name: "partner_fee_percent",
            type: "u8"
          },
          {
            name: "referral_fee_percent",
            type: "u8"
          },
          {
            name: "padding_0",
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "padding_1",
            type: {
              array: [
                "u64",
                5
              ]
            }
          }
        ]
      }
    },
    {
      name: "PoolFeesStruct",
      docs: [
        "Information regarding fee charges",
        "trading_fee = amount * trade_fee_numerator / denominator",
        "protocol_fee = trading_fee * protocol_fee_percentage / 100",
        "referral_fee = protocol_fee * referral_percentage / 100",
        "partner_fee = (protocol_fee - referral_fee) * partner_fee_percentage / denominator"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "base_fee",
            docs: [
              "Trade fees are extra token amounts that are held inside the token",
              "accounts during a trade, making the value of liquidity tokens rise.",
              "Trade fee numerator"
            ],
            type: {
              defined: {
                name: "BaseFeeStruct"
              }
            }
          },
          {
            name: "protocol_fee_percent",
            docs: [
              "Protocol trading fees are extra token amounts that are held inside the token",
              "accounts during a trade, with the equivalent in pool tokens minted to",
              "the protocol of the program.",
              "Protocol trade fee numerator"
            ],
            type: "u8"
          },
          {
            name: "partner_fee_percent",
            docs: [
              "partner fee"
            ],
            type: "u8"
          },
          {
            name: "referral_fee_percent",
            docs: [
              "referral fee"
            ],
            type: "u8"
          },
          {
            name: "padding_0",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u8",
                5
              ]
            }
          },
          {
            name: "dynamic_fee",
            docs: [
              "dynamic fee"
            ],
            type: {
              defined: {
                name: "DynamicFeeStruct"
              }
            }
          },
          {
            name: "padding_1",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u64",
                2
              ]
            }
          }
        ]
      }
    },
    {
      name: "PoolMetrics",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "total_lp_a_fee",
            type: "u128"
          },
          {
            name: "total_lp_b_fee",
            type: "u128"
          },
          {
            name: "total_protocol_a_fee",
            type: "u64"
          },
          {
            name: "total_protocol_b_fee",
            type: "u64"
          },
          {
            name: "total_partner_a_fee",
            type: "u64"
          },
          {
            name: "total_partner_b_fee",
            type: "u64"
          },
          {
            name: "total_position",
            type: "u64"
          },
          {
            name: "padding",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Position",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "pool",
            type: "pubkey"
          },
          {
            name: "nft_mint",
            docs: [
              "nft mint"
            ],
            type: "pubkey"
          },
          {
            name: "fee_a_per_token_checkpoint",
            docs: [
              "fee a checkpoint"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "fee_b_per_token_checkpoint",
            docs: [
              "fee b checkpoint"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "fee_a_pending",
            docs: [
              "fee a pending"
            ],
            type: "u64"
          },
          {
            name: "fee_b_pending",
            docs: [
              "fee b pending"
            ],
            type: "u64"
          },
          {
            name: "unlocked_liquidity",
            docs: [
              "unlock liquidity"
            ],
            type: "u128"
          },
          {
            name: "vested_liquidity",
            docs: [
              "vesting liquidity"
            ],
            type: "u128"
          },
          {
            name: "permanent_locked_liquidity",
            docs: [
              "permanent locked liquidity"
            ],
            type: "u128"
          },
          {
            name: "metrics",
            docs: [
              "metrics"
            ],
            type: {
              defined: {
                name: "PositionMetrics"
              }
            }
          },
          {
            name: "reward_infos",
            docs: [
              "Farming reward information"
            ],
            type: {
              array: [
                {
                  defined: {
                    name: "UserRewardInfo"
                  }
                },
                2
              ]
            }
          },
          {
            name: "padding",
            docs: [
              "padding for future usage"
            ],
            type: {
              array: [
                "u128",
                6
              ]
            }
          }
        ]
      }
    },
    {
      name: "PositionMetrics",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "total_claimed_a_fee",
            type: "u64"
          },
          {
            name: "total_claimed_b_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "RemoveLiquidityParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "liquidity_delta",
            docs: [
              "delta liquidity"
            ],
            type: "u128"
          },
          {
            name: "token_a_amount_threshold",
            docs: [
              "minimum token a amount"
            ],
            type: "u64"
          },
          {
            name: "token_b_amount_threshold",
            docs: [
              "minimum token b amount"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "RewardInfo",
      docs: [
        "Stores the state relevant for tracking liquidity mining rewards"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "initialized",
            docs: [
              "Indicates if the reward has been initialized"
            ],
            type: "u8"
          },
          {
            name: "reward_token_flag",
            docs: [
              "reward token flag"
            ],
            type: "u8"
          },
          {
            name: "_padding_0",
            docs: [
              "padding"
            ],
            type: {
              array: [
                "u8",
                6
              ]
            }
          },
          {
            name: "_padding_1",
            docs: [
              "Padding to ensure `reward_rate: u128` is 16-byte aligned"
            ],
            type: {
              array: [
                "u8",
                8
              ]
            }
          },
          {
            name: "mint",
            docs: [
              "Reward token mint."
            ],
            type: "pubkey"
          },
          {
            name: "vault",
            docs: [
              "Reward vault token account."
            ],
            type: "pubkey"
          },
          {
            name: "funder",
            docs: [
              "Authority account that allows to fund rewards"
            ],
            type: "pubkey"
          },
          {
            name: "reward_duration",
            docs: [
              "reward duration"
            ],
            type: "u64"
          },
          {
            name: "reward_duration_end",
            docs: [
              "reward duration end"
            ],
            type: "u64"
          },
          {
            name: "reward_rate",
            docs: [
              "reward rate"
            ],
            type: "u128"
          },
          {
            name: "reward_per_token_stored",
            docs: [
              "Reward per token stored"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "last_update_time",
            docs: [
              "The last time reward states were updated."
            ],
            type: "u64"
          },
          {
            name: "cumulative_seconds_with_empty_liquidity_reward",
            docs: [
              "Accumulated seconds when the farm distributed rewards but the bin was empty.",
              "These rewards will be carried over to the next reward time window."
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SwapParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount_in",
            type: "u64"
          },
          {
            name: "minimum_amount_out",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "SwapResult",
      docs: [
        "Encodes all results of swapping"
      ],
      type: {
        kind: "struct",
        fields: [
          {
            name: "output_amount",
            type: "u64"
          },
          {
            name: "next_sqrt_price",
            type: "u128"
          },
          {
            name: "lp_fee",
            type: "u64"
          },
          {
            name: "protocol_fee",
            type: "u64"
          },
          {
            name: "partner_fee",
            type: "u64"
          },
          {
            name: "referral_fee",
            type: "u64"
          }
        ]
      }
    },
    {
      name: "TokenBadge",
      docs: [
        "Parameter that set by the protocol"
      ],
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "token_mint",
            docs: [
              "token mint"
            ],
            type: "pubkey"
          },
          {
            name: "_padding",
            docs: [
              "Reserve"
            ],
            type: {
              array: [
                "u8",
                128
              ]
            }
          }
        ]
      }
    },
    {
      name: "UserRewardInfo",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "reward_per_token_checkpoint",
            docs: [
              "The latest update reward checkpoint"
            ],
            type: {
              array: [
                "u8",
                32
              ]
            }
          },
          {
            name: "reward_pendings",
            docs: [
              "Current pending rewards"
            ],
            type: "u64"
          },
          {
            name: "total_claimed_rewards",
            docs: [
              "Total claimed rewards"
            ],
            type: "u64"
          }
        ]
      }
    },
    {
      name: "Vesting",
      serialization: "bytemuck",
      repr: {
        kind: "c"
      },
      type: {
        kind: "struct",
        fields: [
          {
            name: "position",
            type: "pubkey"
          },
          {
            name: "cliff_point",
            type: "u64"
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "cliff_unlock_liquidity",
            type: "u128"
          },
          {
            name: "liquidity_per_period",
            type: "u128"
          },
          {
            name: "total_released_liquidity",
            type: "u128"
          },
          {
            name: "number_of_period",
            type: "u16"
          },
          {
            name: "padding",
            type: {
              array: [
                "u8",
                14
              ]
            }
          },
          {
            name: "padding2",
            type: {
              array: [
                "u128",
                4
              ]
            }
          }
        ]
      }
    },
    {
      name: "VestingParameters",
      type: {
        kind: "struct",
        fields: [
          {
            name: "cliff_point",
            type: {
              option: "u64"
            }
          },
          {
            name: "period_frequency",
            type: "u64"
          },
          {
            name: "cliff_unlock_liquidity",
            type: "u128"
          },
          {
            name: "liquidity_per_period",
            type: "u128"
          },
          {
            name: "number_of_period",
            type: "u16"
          }
        ]
      }
    }
  ]
};

// src/helpers/createProgram.ts
function createDbcProgram(connection, commitment = "confirmed") {
  const provider = new AnchorProvider(connection, null, {
    commitment
  });
  const program = new Program(
    idl_default,
    provider
  );
  return { program };
}
function createVaultProgram(connection, commitment = "confirmed") {
  const provider = new AnchorProvider(connection, null, {
    commitment
  });
  const program = new Program(idl_default2, provider);
  return program;
}
function createDammV1Program(connection, commitment = "confirmed") {
  const provider = new AnchorProvider(connection, null, {
    commitment
  });
  const program = new Program(idl_default3, provider);
  return program;
}
function createDammV2Program(connection, commitment = "confirmed") {
  const provider = new AnchorProvider(connection, null, {
    commitment
  });
  const program = new Program(idl_default4, provider);
  return program;
}

// src/helpers/token.ts
import {
  PublicKey as PublicKey6,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from "@solana/web3.js";
import {
  ASSOCIATED_TOKEN_PROGRAM_ID,
  createAssociatedTokenAccountIdempotentInstruction,
  createCloseAccountInstruction,
  getAccount,
  getAssociatedTokenAddressSync,
  getMint,
  NATIVE_MINT as NATIVE_MINT2,
  TOKEN_2022_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
  TokenAccountNotFoundError,
  TokenInvalidAccountOwnerError
} from "@solana/spl-token";
var getOrCreateATAInstruction = async (connection, tokenMint, owner, payer, allowOwnerOffCurve = true, tokenProgram) => {
  const toAccount = getAssociatedTokenAddressSync(
    tokenMint,
    owner,
    allowOwnerOffCurve,
    tokenProgram
  );
  try {
    await getAccount(connection, toAccount);
    return { ataPubkey: toAccount, ix: void 0 };
  } catch (e) {
    if (e instanceof TokenAccountNotFoundError || e instanceof TokenInvalidAccountOwnerError) {
      const ix = createAssociatedTokenAccountIdempotentInstruction(
        payer,
        toAccount,
        owner,
        tokenMint,
        tokenProgram
      );
      return { ataPubkey: toAccount, ix };
    } else {
      console.error("Error::getOrCreateATAInstruction", e);
      throw e;
    }
  }
};
function unwrapSOLInstruction(owner, receiver, allowOwnerOffCurve = true) {
  const wSolATAAccount = getAssociatedTokenAddressSync(
    NATIVE_MINT2,
    owner,
    allowOwnerOffCurve
  );
  if (wSolATAAccount) {
    const closedWrappedSolInstruction = createCloseAccountInstruction(
      wSolATAAccount,
      receiver,
      owner,
      [],
      TOKEN_PROGRAM_ID
    );
    return closedWrappedSolInstruction;
  }
  return null;
}
function wrapSOLInstruction(from, to, amount) {
  return [
    SystemProgram.transfer({
      fromPubkey: from,
      toPubkey: to,
      lamports: amount
    }),
    new TransactionInstruction({
      keys: [
        {
          pubkey: to,
          isSigner: false,
          isWritable: true
        }
      ],
      data: Buffer.from(new Uint8Array([17])),
      programId: TOKEN_PROGRAM_ID
    })
  ];
}
function findAssociatedTokenAddress(walletAddress, tokenMintAddress, tokenProgramId) {
  return PublicKey6.findProgramAddressSync(
    [
      walletAddress.toBuffer(),
      tokenProgramId.toBuffer(),
      tokenMintAddress.toBuffer()
    ],
    ASSOCIATED_TOKEN_PROGRAM_ID
  )[0];
}
async function getTokenDecimals(connection, mintAddress) {
  const mintPubkey = mintAddress instanceof PublicKey6 ? mintAddress : new PublicKey6(mintAddress);
  const tokenProgram = (await connection.getAccountInfo(mintPubkey)).owner;
  const mintInfo = await getMint(
    connection,
    mintPubkey,
    "confirmed",
    tokenProgram
  );
  return mintInfo.decimals;
}
function getTokenProgram(tokenType) {
  return tokenType === 0 /* SPL */ ? TOKEN_PROGRAM_ID : TOKEN_2022_PROGRAM_ID;
}
async function getTokenType(connection, tokenMint) {
  const accountInfo = await connection.getAccountInfo(tokenMint);
  if (!accountInfo) {
    return null;
  }
  return accountInfo.owner.equals(TOKEN_PROGRAM_ID) ? 0 /* SPL */ : 1 /* Token2022 */;
}
async function prepareTokenAccountTx(connection, owner, payer, tokenMint, amount, tokenProgram) {
  const instructions = [];
  const { ataPubkey: tokenAccount, ix: createAtaIx } = await getOrCreateATAInstruction(
    connection,
    tokenMint,
    owner,
    payer,
    true,
    tokenProgram
  );
  createAtaIx && instructions.push(createAtaIx);
  if (tokenMint.equals(NATIVE_MINT2)) {
    const wrapIx = wrapSOLInstruction(owner, tokenAccount, amount);
    instructions.push(...wrapIx);
  }
  const transaction = new Transaction();
  if (instructions.length > 0) {
    transaction.add(...instructions);
  }
  return { tokenAccount, transaction };
}
async function cleanUpTokenAccountTx(owner, receiver, tokenMint) {
  if (tokenMint.equals(NATIVE_MINT2)) {
    const unwrapIx = unwrapSOLInstruction(owner, receiver);
    if (unwrapIx) {
      return { transaction: new Transaction().add(unwrapIx) };
    }
  }
  return null;
}

// src/helpers/instructions.ts
import {
  SystemProgram as SystemProgram2,
  SYSVAR_RENT_PUBKEY
} from "@solana/web3.js";
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID2 } from "@solana/spl-token";
async function createInitializePermissionlessDynamicVaultIx(mint, payer, vaultProgram) {
  const vaultKey = deriveVaultAddress(mint, BASE_ADDRESS);
  const tokenVaultKey = deriveTokenVaultKey(vaultKey);
  const lpMintKey = deriveVaultLpMintAddress(vaultKey);
  const ix = await vaultProgram.methods.initialize().accountsPartial({
    vault: vaultKey,
    tokenVault: tokenVaultKey,
    tokenMint: mint,
    lpMint: lpMintKey,
    payer,
    rent: SYSVAR_RENT_PUBKEY,
    tokenProgram: TOKEN_PROGRAM_ID2,
    systemProgram: SystemProgram2.programId
  }).instruction();
  return {
    instruction: ix,
    vaultKey,
    tokenVaultKey,
    lpMintKey
  };
}
async function createLockEscrowIx(payer, pool, lpMint, escrowOwner, lockEscrowKey, dammV1Program) {
  const ix = await dammV1Program.methods.createLockEscrow().accountsPartial({
    pool,
    lpMint,
    owner: escrowOwner,
    lockEscrow: lockEscrowKey,
    payer,
    systemProgram: SystemProgram2.programId
  }).instruction();
  return ix;
}

// src/services/program.ts
var DynamicBondingCurveProgram = class {
  constructor(connection, commitment) {
    const { program } = createDbcProgram(connection, commitment);
    this.program = program;
    this.connection = connection;
    this.poolAuthority = deriveDbcPoolAuthority();
    this.commitment = commitment;
  }
  async prepareTokenAccounts(owner, payer, tokenAMint, tokenBMint, tokenAProgram, tokenBProgram) {
    const instructions = [];
    const [
      { ataPubkey: ataTokenA, ix: createAtaTokenAIx },
      { ataPubkey: ataTokenB, ix: createAtaTokenBIx }
    ] = await Promise.all([
      getOrCreateATAInstruction(
        this.connection,
        tokenAMint,
        owner,
        payer,
        true,
        tokenAProgram
      ),
      getOrCreateATAInstruction(
        this.connection,
        tokenBMint,
        owner,
        payer,
        true,
        tokenBProgram
      )
    ]);
    createAtaTokenAIx && instructions.push(createAtaTokenAIx);
    createAtaTokenBIx && instructions.push(createAtaTokenBIx);
    return { ataTokenA, ataTokenB, instructions };
  }
  /**
   * Get the underlying program instance
   * @returns The program instance
   */
  getProgram() {
    return this.program;
  }
};

// src/services/pool.ts
import { NATIVE_MINT as NATIVE_MINT3, TOKEN_2022_PROGRAM_ID as TOKEN_2022_PROGRAM_ID2 } from "@solana/spl-token";
import { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID3 } from "@solana/spl-token";

// src/math/swapQuote.ts
import BN12 from "bn.js";

// src/math/feeMath.ts
import BN11 from "bn.js";

// src/math/feeScheduler.ts
import BN10 from "bn.js";
function getFeeNumeratorOnLinearFeeScheduler(cliffFeeNumerator, reductionFactor, period) {
  const reduction = SafeMath.mul(new BN10(period), reductionFactor);
  if (reduction.gt(cliffFeeNumerator)) {
    return new BN10(0);
  }
  return SafeMath.sub(cliffFeeNumerator, reduction);
}
function getFeeNumeratorOnExponentialFeeScheduler(cliffFeeNumerator, reductionFactor, period) {
  if (period === 0) {
    return cliffFeeNumerator;
  }
  if (period === 1) {
    const basisPointMax2 = new BN10(BASIS_POINT_MAX);
    return mulDiv(
      cliffFeeNumerator,
      basisPointMax2.sub(reductionFactor),
      basisPointMax2,
      1 /* Down */
    );
  }
  const basisPointMax = new BN10(BASIS_POINT_MAX);
  const ONE_Q642 = new BN10(1).shln(64);
  const reductionFactorScaled = SafeMath.div(
    SafeMath.shl(reductionFactor, 64),
    basisPointMax
  );
  let base = SafeMath.sub(ONE_Q642, reductionFactorScaled);
  const result = pow(base, new BN10(period));
  return SafeMath.div(SafeMath.mul(cliffFeeNumerator, result), ONE_Q642);
}

// src/math/feeMath.ts
function getBaseFeeNumerator(baseFee, tradeDirection, currentPoint, activationPoint, inputAmount) {
  const baseFeeMode = baseFee.baseFeeMode;
  if (baseFeeMode === 2 /* RateLimiter */) {
    const feeIncrementBps = baseFee.firstFactor;
    const maxLimiterDuration = baseFee.secondFactor;
    const referenceAmount = baseFee.thirdFactor;
    const isBaseToQuote = tradeDirection === 0 /* BaseToQuote */;
    const isRateLimiterApplied = checkRateLimiterApplied(
      baseFeeMode,
      isBaseToQuote,
      currentPoint,
      activationPoint,
      baseFee.secondFactor
    );
    if (currentPoint.lt(activationPoint)) {
      return baseFee.cliffFeeNumerator;
    }
    const lastEffectivePoint = activationPoint.add(maxLimiterDuration);
    if (currentPoint.gt(lastEffectivePoint)) {
      return baseFee.cliffFeeNumerator;
    }
    if (!inputAmount) {
      return baseFee.cliffFeeNumerator;
    }
    if (isRateLimiterApplied) {
      return getFeeNumeratorOnRateLimiter(
        baseFee.cliffFeeNumerator,
        referenceAmount,
        new BN11(feeIncrementBps),
        inputAmount
      );
    } else {
      return baseFee.cliffFeeNumerator;
    }
  } else {
    const numberOfPeriod = baseFee.firstFactor;
    const periodFrequency = baseFee.secondFactor;
    const reductionFactor = baseFee.thirdFactor;
    if (periodFrequency.isZero()) {
      return baseFee.cliffFeeNumerator;
    }
    let period;
    if (currentPoint.lt(activationPoint)) {
      period = numberOfPeriod;
    } else {
      const elapsedPoints = SafeMath.sub(currentPoint, activationPoint);
      const periodCount = SafeMath.div(elapsedPoints, periodFrequency);
      period = Math.min(parseInt(periodCount.toString()), numberOfPeriod);
    }
    if (baseFeeMode === 0 /* FeeSchedulerLinear */) {
      return getFeeNumeratorOnLinearFeeScheduler(
        baseFee.cliffFeeNumerator,
        reductionFactor,
        period
      );
    } else {
      return getFeeNumeratorOnExponentialFeeScheduler(
        baseFee.cliffFeeNumerator,
        reductionFactor,
        period
      );
    }
  }
}
function getVariableFee(dynamicFee, volatilityTracker) {
  if (dynamicFee.initialized === 0) {
    return new BN11(0);
  }
  if (volatilityTracker.volatilityAccumulator.isZero()) {
    return new BN11(0);
  }
  const volatilityTimesBinStep = SafeMath.mul(
    volatilityTracker.volatilityAccumulator,
    new BN11(dynamicFee.binStep)
  );
  const squared = SafeMath.mul(volatilityTimesBinStep, volatilityTimesBinStep);
  const vFee = SafeMath.mul(squared, new BN11(dynamicFee.variableFeeControl));
  const scaleFactor = new BN11(1e11);
  const numerator = SafeMath.add(vFee, SafeMath.sub(scaleFactor, new BN11(1)));
  return SafeMath.div(numerator, scaleFactor);
}
function getFeeOnAmount(amount, poolFees, isReferral, currentPoint, activationPoint, volatilityTracker, tradeDirection) {
  const baseFeeNumerator = getBaseFeeNumerator(
    poolFees.baseFee,
    tradeDirection,
    currentPoint,
    activationPoint,
    poolFees.baseFee.baseFeeMode === 2 /* RateLimiter */ ? amount : void 0
  );
  let totalFeeNumerator = baseFeeNumerator;
  if (poolFees.dynamicFee.initialized !== 0) {
    const variableFee = getVariableFee(
      poolFees.dynamicFee,
      volatilityTracker
    );
    totalFeeNumerator = SafeMath.add(totalFeeNumerator, variableFee);
  }
  if (totalFeeNumerator.gt(new BN11(MAX_FEE_NUMERATOR))) {
    totalFeeNumerator = new BN11(MAX_FEE_NUMERATOR);
  }
  const tradingFee = mulDiv(
    amount,
    totalFeeNumerator,
    new BN11(FEE_DENOMINATOR),
    0 /* Up */
  );
  const amountAfterFee = SafeMath.sub(amount, tradingFee);
  const protocolFee = mulDiv(
    tradingFee,
    new BN11(poolFees.protocolFeePercent),
    new BN11(100),
    1 /* Down */
  );
  const tradingFeeAfterProtocol = SafeMath.sub(tradingFee, protocolFee);
  let referralFee = new BN11(0);
  if (isReferral) {
    referralFee = mulDiv(
      protocolFee,
      new BN11(poolFees.referralFeePercent),
      new BN11(100),
      1 /* Down */
    );
  }
  const protocolFeeAfterReferral = SafeMath.sub(protocolFee, referralFee);
  return {
    amount: amountAfterFee,
    tradingFee: tradingFeeAfterProtocol,
    protocolFee: protocolFeeAfterReferral,
    referralFee
  };
}

// src/math/swapQuote.ts
function getSwapResult(poolState, configState, amountIn, feeMode, tradeDirection, currentPoint) {
  let actualProtocolFee = new BN12(0);
  let actualTradingFee = new BN12(0);
  let actualReferralFee = new BN12(0);
  let actualAmountIn;
  if (feeMode.feesOnInput) {
    const feeResult = getFeeOnAmount(
      amountIn,
      configState.poolFees,
      feeMode.hasReferral,
      currentPoint,
      poolState.activationPoint,
      poolState.volatilityTracker,
      tradeDirection
    );
    actualProtocolFee = feeResult.protocolFee;
    actualTradingFee = feeResult.tradingFee;
    actualReferralFee = feeResult.referralFee;
    actualAmountIn = feeResult.amount;
  } else {
    actualAmountIn = amountIn;
  }
  const swapAmount = tradeDirection === 0 /* BaseToQuote */ ? getSwapAmountFromBaseToQuote(
    configState,
    poolState.sqrtPrice,
    actualAmountIn
  ) : getSwapAmountFromQuoteToBase(
    configState,
    poolState.sqrtPrice,
    actualAmountIn
  );
  let actualAmountOut;
  if (feeMode.feesOnInput) {
    actualAmountOut = swapAmount.outputAmount;
  } else {
    const feeResult = getFeeOnAmount(
      swapAmount.outputAmount,
      configState.poolFees,
      feeMode.hasReferral,
      currentPoint,
      poolState.activationPoint,
      poolState.volatilityTracker,
      tradeDirection
    );
    actualProtocolFee = feeResult.protocolFee;
    actualTradingFee = feeResult.tradingFee;
    actualReferralFee = feeResult.referralFee;
    actualAmountOut = feeResult.amount;
  }
  return {
    amountOut: actualAmountOut,
    minimumAmountOut: actualAmountOut,
    nextSqrtPrice: swapAmount.nextSqrtPrice,
    fee: {
      trading: actualTradingFee,
      protocol: actualProtocolFee,
      referral: actualReferralFee
    },
    price: {
      beforeSwap: poolState.sqrtPrice,
      afterSwap: swapAmount.nextSqrtPrice
    }
  };
}
function getSwapAmountFromBaseToQuote(configState, currentSqrtPrice, amountIn) {
  if (amountIn.isZero()) {
    return {
      outputAmount: new BN12(0),
      nextSqrtPrice: currentSqrtPrice
    };
  }
  let totalOutputAmount = new BN12(0);
  let sqrtPrice = currentSqrtPrice;
  let amountLeft = amountIn;
  for (let i = configState.curve.length - 1; i >= 0; i--) {
    if (configState.curve[i].sqrtPrice.isZero() || configState.curve[i].liquidity.isZero()) {
      continue;
    }
    if (configState.curve[i].sqrtPrice.lt(sqrtPrice)) {
      const currentLiquidity = i + 1 < configState.curve.length ? configState.curve[i + 1].liquidity : configState.curve[i].liquidity;
      if (currentLiquidity.isZero()) continue;
      const maxAmountIn = getDeltaAmountBaseUnsigned(
        configState.curve[i].sqrtPrice,
        sqrtPrice,
        currentLiquidity,
        0 /* Up */
      );
      if (amountLeft.lt(maxAmountIn)) {
        const nextSqrtPrice = getNextSqrtPriceFromInput(
          sqrtPrice,
          currentLiquidity,
          amountLeft,
          true
        );
        const outputAmount = getDeltaAmountQuoteUnsigned(
          nextSqrtPrice,
          sqrtPrice,
          currentLiquidity,
          1 /* Down */
        );
        totalOutputAmount = SafeMath.add(
          totalOutputAmount,
          outputAmount
        );
        sqrtPrice = nextSqrtPrice;
        amountLeft = new BN12(0);
        break;
      } else {
        const nextSqrtPrice = configState.curve[i].sqrtPrice;
        const outputAmount = getDeltaAmountQuoteUnsigned(
          nextSqrtPrice,
          sqrtPrice,
          currentLiquidity,
          1 /* Down */
        );
        totalOutputAmount = SafeMath.add(
          totalOutputAmount,
          outputAmount
        );
        sqrtPrice = nextSqrtPrice;
        amountLeft = SafeMath.sub(amountLeft, maxAmountIn);
      }
    }
  }
  if (!amountLeft.isZero() && !configState.curve[0].liquidity.isZero()) {
    const nextSqrtPrice = getNextSqrtPriceFromInput(
      sqrtPrice,
      configState.curve[0].liquidity,
      amountLeft,
      true
    );
    const outputAmount = getDeltaAmountQuoteUnsigned(
      nextSqrtPrice,
      sqrtPrice,
      configState.curve[0].liquidity,
      1 /* Down */
    );
    totalOutputAmount = SafeMath.add(totalOutputAmount, outputAmount);
    sqrtPrice = nextSqrtPrice;
  }
  return {
    outputAmount: totalOutputAmount,
    nextSqrtPrice: sqrtPrice
  };
}
function getSwapAmountFromQuoteToBase(configState, currentSqrtPrice, amountIn) {
  if (amountIn.isZero()) {
    return {
      outputAmount: new BN12(0),
      nextSqrtPrice: currentSqrtPrice
    };
  }
  let totalOutputAmount = new BN12(0);
  let sqrtPrice = currentSqrtPrice;
  let amountLeft = amountIn;
  for (let i = 0; i < configState.curve.length; i++) {
    if (configState.curve[i].sqrtPrice.isZero() || configState.curve[i].liquidity.isZero()) {
      break;
    }
    if (configState.curve[i].liquidity.isZero()) continue;
    if (configState.curve[i].sqrtPrice.gt(sqrtPrice)) {
      const maxAmountIn = getDeltaAmountQuoteUnsigned(
        sqrtPrice,
        configState.curve[i].sqrtPrice,
        configState.curve[i].liquidity,
        0 /* Up */
      );
      if (amountLeft.lt(maxAmountIn)) {
        const nextSqrtPrice = getNextSqrtPriceFromInput(
          sqrtPrice,
          configState.curve[i].liquidity,
          amountLeft,
          false
        );
        const outputAmount = getDeltaAmountBaseUnsigned(
          sqrtPrice,
          nextSqrtPrice,
          configState.curve[i].liquidity,
          1 /* Down */
        );
        totalOutputAmount = SafeMath.add(
          totalOutputAmount,
          outputAmount
        );
        sqrtPrice = nextSqrtPrice;
        amountLeft = new BN12(0);
        break;
      } else {
        const nextSqrtPrice = configState.curve[i].sqrtPrice;
        const outputAmount = getDeltaAmountBaseUnsigned(
          sqrtPrice,
          nextSqrtPrice,
          configState.curve[i].liquidity,
          1 /* Down */
        );
        totalOutputAmount = SafeMath.add(
          totalOutputAmount,
          outputAmount
        );
        sqrtPrice = nextSqrtPrice;
        amountLeft = SafeMath.sub(amountLeft, maxAmountIn);
      }
    }
  }
  if (!amountLeft.isZero()) {
    throw new Error("Not enough liquidity to process the entire amount");
  }
  return {
    outputAmount: totalOutputAmount,
    nextSqrtPrice: sqrtPrice
  };
}
function getFeeMode(collectFeeMode, tradeDirection, hasReferral) {
  const quoteToBase = tradeDirection === 1 /* QuoteToBase */;
  const feesOnInput = quoteToBase && collectFeeMode === 0 /* QuoteToken */;
  const feesOnBaseToken = quoteToBase && collectFeeMode === 1 /* OutputToken */;
  return {
    feesOnInput,
    feesOnBaseToken,
    hasReferral
  };
}
async function swapQuote(virtualPool, config, swapBaseForQuote, amountIn, slippageBps = 0, hasReferral, currentPoint) {
  if (virtualPool.quoteReserve.gte(config.migrationQuoteThreshold)) {
    throw new Error("Virtual pool is completed");
  }
  if (amountIn.isZero()) {
    throw new Error("Amount is zero");
  }
  const tradeDirection = swapBaseForQuote ? 0 /* BaseToQuote */ : 1 /* QuoteToBase */;
  const feeMode = getFeeMode(
    config.collectFeeMode,
    tradeDirection,
    hasReferral
  );
  const result = getSwapResult(
    virtualPool,
    config,
    amountIn,
    feeMode,
    tradeDirection,
    currentPoint
  );
  if (slippageBps > 0) {
    const slippageFactor = new BN12(1e4 - slippageBps);
    const denominator = new BN12(1e4);
    const minimumAmountOut = result.amountOut.mul(slippageFactor).div(denominator);
    return {
      ...result,
      minimumAmountOut
    };
  }
  return result;
}
function calculateQuoteExactInAmount(config, virtualPool, currentPoint) {
  if (virtualPool.quoteReserve.gte(config.migrationQuoteThreshold)) {
    return new BN12(0);
  }
  const amountInAfterFee = config.migrationQuoteThreshold.sub(
    virtualPool.quoteReserve
  );
  if (config.collectFeeMode === 0 /* OnlyQuote */) {
    const baseFeeNumerator = getBaseFeeNumerator(
      config.poolFees.baseFee,
      1 /* QuoteToBase */,
      currentPoint,
      virtualPool.activationPoint
    );
    let totalFeeNumerator = baseFeeNumerator;
    if (config.poolFees.dynamicFee.initialized !== 0) {
      const variableFee = getVariableFee(
        config.poolFees.dynamicFee,
        virtualPool.volatilityTracker
      );
      totalFeeNumerator = SafeMath.add(totalFeeNumerator, variableFee);
    }
    totalFeeNumerator = BN12.min(totalFeeNumerator, new BN12(MAX_FEE_NUMERATOR));
    const denominator = new BN12(FEE_DENOMINATOR).sub(totalFeeNumerator);
    return mulDiv(
      amountInAfterFee,
      new BN12(FEE_DENOMINATOR),
      denominator,
      0 /* Up */
    );
  } else {
    return amountInAfterFee;
  }
}

// src/services/state.ts
import { PublicKey as PublicKey8 } from "@solana/web3.js";
var StateService = class extends DynamicBondingCurveProgram {
  constructor(connection, commitment) {
    super(connection, commitment);
  }
  /**
   * Get pool config data (partner config)
   * @param configAddress - The address of the pool config key
   * @returns A pool config
   */
  async getPoolConfig(configAddress) {
    return getAccountData(
      configAddress,
      "poolConfig",
      this.program
    );
  }
  /**
   * Get all config keys
   * @returns An array of config key accounts
   */
  async getPoolConfigs() {
    return this.program.account.poolConfig.all();
  }
  /**
   * Get all config keys of an owner wallet address
   * @param owner - The owner of the config keys
   * @returns An array of config key accounts
   */
  async getPoolConfigsByOwner(owner) {
    const filters = createProgramAccountFilter(owner, 72);
    return this.program.account.poolConfig.all(filters);
  }
  /**
   * Get virtual pool data
   * @param poolAddress - The address of the pool
   * @returns A virtual pool or null if not found
   */
  async getPool(poolAddress) {
    return getAccountData(
      poolAddress,
      "virtualPool",
      this.program
    );
  }
  /**
   * Get all dynamic bonding curve pools
   * @returns Array of pool accounts with their addresses
   */
  async getPools() {
    return this.program.account.virtualPool.all();
  }
  /**
   * Get all dynamic bonding curve pools by config key address
   * @param configAddress - The address of the config key
   * @returns Array of pool accounts with their addresses
   */
  async getPoolsByConfig(configAddress) {
    const filters = createProgramAccountFilter(configAddress, 72);
    return this.program.account.virtualPool.all(filters);
  }
  /**
   * Get all dynamic bonding curve pools by creator address
   * @param creatorAddress - The address of the creator
   * @returns Array of pool accounts with their addresses
   */
  async getPoolsByCreator(creatorAddress) {
    const filters = createProgramAccountFilter(creatorAddress, 104);
    return this.program.account.virtualPool.all(filters);
  }
  /**
   * Get pool by base mint
   * @param baseMint - The base mint address
   * @returns A virtual pool account
   */
  async getPoolByBaseMint(baseMint) {
    const filters = createProgramAccountFilter(baseMint, 136);
    const pools = await this.program.account.virtualPool.all(filters);
    return pools.length > 0 ? pools[0] : null;
  }
  /**
   * Get pool migration quote threshold
   * @param poolAddress - The address of the pool
   * @returns The migration quote threshold
   */
  async getPoolMigrationQuoteThreshold(poolAddress) {
    const pool = await this.getPool(poolAddress);
    if (!pool) {
      throw new Error(`Pool not found: ${poolAddress.toString()}`);
    }
    const configAddress = pool.config;
    const config = await this.getPoolConfig(configAddress);
    return config.migrationQuoteThreshold;
  }
  /**
   * Get the progress of the curve by comparing current quote reserve to migration threshold
   * @param poolAddress - The address of the pool
   * @returns The progress as a ratio between 0 and 1
   */
  async getPoolCurveProgress(poolAddress) {
    const pool = await this.getPool(poolAddress);
    if (!pool) {
      throw new Error(`Pool not found: ${poolAddress.toString()}`);
    }
    const config = await this.getPoolConfig(pool.config);
    const quoteReserve = pool.quoteReserve;
    const migrationThreshold = config.migrationQuoteThreshold;
    const quoteReserveNum = quoteReserve.toNumber();
    const thresholdNum = migrationThreshold.toNumber();
    const progress = quoteReserveNum / thresholdNum;
    return Math.min(Math.max(progress, 0), 1);
  }
  /**
   * Get pool metadata
   * @param poolAddress - The address of the pool
   * @returns A pool metadata
   */
  async getPoolMetadata(poolAddress) {
    const filters = createProgramAccountFilter(poolAddress, 8);
    const accounts = await this.program.account.virtualPoolMetadata.all(filters);
    return accounts.map((account) => account.account);
  }
  /**
   * Get partner metadata
   * @param partnerAddress - The address of the partner
   * @returns A partner metadata
   */
  async getPartnerMetadata(walletAddress) {
    const filters = createProgramAccountFilter(walletAddress, 8);
    const accounts = await this.program.account.partnerMetadata.all(filters);
    return accounts.map((account) => account.account);
  }
  /**
   * Get DAMM V1 lock escrow details
   * @param lockEscrowAddress - The address of the lock escrow
   * @returns A lock escrow account
   */
  async getDammV1LockEscrow(lockEscrowAddress) {
    const metadata = await this.program.account.lockEscrow.fetchNullable(
      lockEscrowAddress instanceof PublicKey8 ? lockEscrowAddress : new PublicKey8(lockEscrowAddress)
    );
    return metadata;
  }
  /**
   * Get fee metrics for a specific pool
   * @param poolAddress - The address of the pool
   * @returns Object containing current and total fee metrics
   */
  async getPoolFeeMetrics(poolAddress) {
    const pool = await this.getPool(poolAddress);
    if (!pool) {
      throw new Error(`Pool not found: ${poolAddress.toString()}`);
    }
    return {
      current: {
        partnerBaseFee: pool.partnerBaseFee,
        partnerQuoteFee: pool.partnerQuoteFee,
        creatorBaseFee: pool.creatorBaseFee,
        creatorQuoteFee: pool.creatorQuoteFee
      },
      total: {
        totalTradingBaseFee: pool.metrics.totalTradingBaseFee,
        totalTradingQuoteFee: pool.metrics.totalTradingQuoteFee
      }
    };
  }
  /**
   * Get all fees for pools linked to a specific config key
   * @param configAddress - The address of the pool config
   * @returns Array of pools with their quote fees
   */
  async getPoolsFeesByConfig(configAddress) {
    const filteredPools = await this.getPoolsByConfig(configAddress);
    return filteredPools.map((pool) => ({
      poolAddress: pool.publicKey,
      partnerBaseFee: pool.account.partnerBaseFee,
      partnerQuoteFee: pool.account.partnerQuoteFee,
      creatorBaseFee: pool.account.creatorBaseFee,
      creatorQuoteFee: pool.account.creatorQuoteFee,
      totalTradingBaseFee: pool.account.metrics.totalTradingBaseFee,
      totalTradingQuoteFee: pool.account.metrics.totalTradingQuoteFee
    }));
  }
  /**
   * Get all fees for pools linked to a specific creator
   * @param creatorAddress - The address of the creator
   * @returns Array of pools with their base fees
   */
  async getPoolsFeesByCreator(creatorAddress) {
    const filteredPools = await this.getPoolsByCreator(creatorAddress);
    return filteredPools.map((pool) => ({
      poolAddress: pool.publicKey,
      partnerBaseFee: pool.account.partnerBaseFee,
      partnerQuoteFee: pool.account.partnerQuoteFee,
      creatorBaseFee: pool.account.creatorBaseFee,
      creatorQuoteFee: pool.account.creatorQuoteFee,
      totalTradingBaseFee: pool.account.metrics.totalTradingBaseFee,
      totalTradingQuoteFee: pool.account.metrics.totalTradingQuoteFee
    }));
  }
};

// src/services/pool.ts
import BN13 from "bn.js";
var PoolService = class extends DynamicBondingCurveProgram {
  constructor(connection, commitment) {
    super(connection, commitment);
    this.state = new StateService(connection, commitment);
  }
  /**
   * Private method to initialize a pool with SPL token
   * @param initializeSplPoolParams - The parameters for the initialize SPL pool
   * @returns A transaction that initializes the pool with SPL token
   */
  async initializeSplPool(initializeSplPoolParams) {
    const {
      name,
      symbol,
      uri,
      pool,
      config,
      payer,
      poolCreator,
      mintMetadata,
      baseMint,
      baseVault,
      quoteVault,
      quoteMint
    } = initializeSplPoolParams;
    return this.program.methods.initializeVirtualPoolWithSplToken({
      name,
      symbol,
      uri
    }).accountsPartial({
      pool,
      config,
      payer,
      creator: poolCreator,
      mintMetadata,
      baseMint,
      poolAuthority: this.poolAuthority,
      baseVault,
      quoteVault,
      quoteMint,
      tokenQuoteProgram: TOKEN_PROGRAM_ID3,
      metadataProgram: METAPLEX_PROGRAM_ID,
      tokenProgram: TOKEN_PROGRAM_ID3
    }).transaction();
  }
  /**
   * Private method to initialize a pool with Token2022
   * @param initializeToken2022PoolParams - The parameters for the initialize Token2022 pool
   * @returns A transaction that initializes the pool with Token2022
   */
  async initializeToken2022Pool(initializeToken2022PoolParams) {
    const {
      name,
      symbol,
      uri,
      pool,
      config,
      payer,
      poolCreator,
      baseMint,
      baseVault,
      quoteVault,
      quoteMint
    } = initializeToken2022PoolParams;
    return this.program.methods.initializeVirtualPoolWithToken2022({
      name,
      symbol,
      uri
    }).accountsPartial({
      pool,
      config,
      payer,
      creator: poolCreator,
      baseMint,
      poolAuthority: this.poolAuthority,
      baseVault,
      quoteVault,
      quoteMint,
      tokenQuoteProgram: TOKEN_PROGRAM_ID3,
      tokenProgram: TOKEN_2022_PROGRAM_ID2
    }).transaction();
  }
  /**
   * Private method to prepare swap parameters
   * @param swapBaseForQuote - Whether to swap base for quote
   * @param virtualPoolState - The virtual pool state
   * @param poolConfigState - The pool config state
   * @returns The prepare swap parameters
   */
  prepareSwapParams(swapBaseForQuote, virtualPoolState, poolConfigState) {
    if (swapBaseForQuote) {
      return {
        inputMint: new PublicKey9(virtualPoolState.baseMint),
        outputMint: new PublicKey9(poolConfigState.quoteMint),
        inputTokenProgram: getTokenProgram(virtualPoolState.poolType),
        outputTokenProgram: getTokenProgram(
          poolConfigState.quoteTokenFlag
        )
      };
    } else {
      return {
        inputMint: new PublicKey9(poolConfigState.quoteMint),
        outputMint: new PublicKey9(virtualPoolState.baseMint),
        inputTokenProgram: getTokenProgram(
          poolConfigState.quoteTokenFlag
        ),
        outputTokenProgram: getTokenProgram(virtualPoolState.poolType)
      };
    }
  }
  /**
   * Private method to create config transaction
   * @param configParam - The config parameters
   * @param config - The config address
   * @param feeClaimer - The fee claimer address
   * @param leftoverReceiver - The leftover receiver address
   * @param quoteMint - The quote mint address
   * @param payer - The payer address
   * @returns A transaction that creates the config
   */
  async createConfigTx(configParam, config, feeClaimer, leftoverReceiver, quoteMint, payer) {
    return this.program.methods.createConfig(configParam).accountsPartial({
      config,
      feeClaimer,
      leftoverReceiver,
      quoteMint,
      payer
    }).transaction();
  }
  /**
   * Private method to create pool transaction
   * @param createConfigAndPoolWithFirstBuyParam - The parameters for the config and pool and buy
   * @param configKey - The config key
   * @param quoteMintToken - The quote mint token
   * @param payerAddress - The payer address
   * @returns A transaction that creates the pool
   */
  async createPoolTx(createPoolParam, tokenType, quoteMint) {
    const { baseMint, name, symbol, uri, poolCreator, config, payer } = createPoolParam;
    const pool = deriveDbcPoolAddress(quoteMint, baseMint, config);
    const baseVault = deriveDbcTokenVaultAddress(pool, baseMint);
    const quoteVault = deriveDbcTokenVaultAddress(pool, quoteMint);
    const baseParams = {
      name,
      symbol,
      uri,
      pool,
      config,
      payer,
      poolCreator,
      baseMint,
      baseVault,
      quoteVault,
      quoteMint
    };
    if (tokenType === 0 /* SPL */) {
      const mintMetadata = deriveMintMetadata(baseMint);
      return this.initializeSplPool({ ...baseParams, mintMetadata });
    } else {
      return this.initializeToken2022Pool(baseParams);
    }
  }
  /**
   * Private method to create first buy transaction
   * @param createConfigAndPoolWithFirstBuyParam - The parameters for the config and pool and buy
   * @param configKey - The config key
   * @param quoteMintToken - The quote mint token
   * @param payerAddress - The payer address
   * @returns Instructions for the first buy
   */
  async swapBuyTx(createConfigAndPoolWithFirstBuyParam, config, quoteMint) {
    const { baseMint, poolCreator } = createConfigAndPoolWithFirstBuyParam.createPoolParam;
    const { buyAmount, minimumAmountOut, referralTokenAccount } = createConfigAndPoolWithFirstBuyParam.swapBuyParam;
    validateSwapAmount(buyAmount);
    let currentPoint;
    if (createConfigAndPoolWithFirstBuyParam.activationType === 0 /* Slot */) {
      const currentSlot = await this.connection.getSlot();
      currentPoint = currentSlot;
    } else {
      const currentSlot = await this.connection.getSlot();
      const currentTime = await this.connection.getBlockTime(currentSlot);
      currentPoint = currentTime;
    }
    const isRateLimiterApplied = checkRateLimiterApplied(
      createConfigAndPoolWithFirstBuyParam.poolFees.baseFee.baseFeeMode,
      false,
      new BN13(0),
      new BN13(0),
      new BN13(0)
    );
    const quoteTokenFlag = await getTokenType(this.connection, quoteMint);
    const { inputMint, outputMint, inputTokenProgram, outputTokenProgram } = this.prepareSwapParams(
      false,
      {
        baseMint,
        poolType: createConfigAndPoolWithFirstBuyParam.tokenType
      },
      {
        quoteMint,
        quoteTokenFlag
      }
    );
    const pool = deriveDbcPoolAddress(quoteMint, baseMint, config);
    const baseVault = deriveDbcTokenVaultAddress(pool, baseMint);
    const quoteVault = deriveDbcTokenVaultAddress(pool, quoteMint);
    const {
      ataTokenA: inputTokenAccount,
      ataTokenB: outputTokenAccount,
      instructions: preInstructions
    } = await this.prepareTokenAccounts(
      poolCreator,
      poolCreator,
      inputMint,
      outputMint,
      inputTokenProgram,
      outputTokenProgram
    );
    if (inputMint.equals(NATIVE_MINT3)) {
      preInstructions.push(
        ...wrapSOLInstruction(
          poolCreator,
          inputTokenAccount,
          BigInt(buyAmount.toString())
        )
      );
    }
    const postInstructions = [];
    if ([inputMint.toBase58(), outputMint.toBase58()].includes(
      NATIVE_MINT3.toBase58()
    )) {
      const unwrapIx = unwrapSOLInstruction(poolCreator, poolCreator);
      unwrapIx && postInstructions.push(unwrapIx);
    }
    const remainingAccounts = isRateLimiterApplied ? [
      {
        isSigner: false,
        isWritable: false,
        pubkey: SYSVAR_INSTRUCTIONS_PUBKEY
      }
    ] : [];
    return this.program.methods.swap({
      amountIn: buyAmount,
      minimumAmountOut
    }).accountsPartial({
      baseMint,
      quoteMint,
      pool,
      baseVault,
      quoteVault,
      config,
      poolAuthority: this.poolAuthority,
      referralTokenAccount,
      inputTokenAccount,
      outputTokenAccount,
      payer: poolCreator,
      tokenBaseProgram: outputTokenProgram,
      tokenQuoteProgram: inputTokenProgram
    }).remainingAccounts(remainingAccounts).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
  }
  /**
   * Create a new pool
   * @param createPoolParam - The parameters for the pool
   * @returns A new pool
   */
  async createPool(createPoolParam) {
    const { baseMint, config, name, symbol, uri, payer, poolCreator } = createPoolParam;
    const poolConfigState = await this.state.getPoolConfig(config);
    const { quoteMint, tokenType } = poolConfigState;
    const pool = deriveDbcPoolAddress(quoteMint, baseMint, config);
    const baseVault = deriveDbcTokenVaultAddress(pool, baseMint);
    const quoteVault = deriveDbcTokenVaultAddress(pool, quoteMint);
    const baseParams = {
      name,
      symbol,
      uri,
      pool,
      config,
      payer,
      poolCreator,
      baseMint,
      baseVault,
      quoteVault,
      quoteMint
    };
    if (tokenType === 0 /* SPL */) {
      const mintMetadata = deriveMintMetadata(baseMint);
      return this.initializeSplPool({ ...baseParams, mintMetadata });
    } else {
      return this.initializeToken2022Pool(baseParams);
    }
  }
  /**
   * Create a new config and pool
   * @param createConfigAndPoolParam - The parameters for the config and pool
   * @returns A new config and pool
   */
  async createConfigAndPool(createConfigAndPoolParam) {
    const {
      config,
      feeClaimer,
      leftoverReceiver,
      quoteMint,
      payer,
      ...configParam
    } = createConfigAndPoolParam;
    const { baseMint, name, symbol, uri, poolCreator } = createConfigAndPoolParam.createPoolParam;
    validateConfigParameters({ ...configParam, leftoverReceiver });
    const configKey = new PublicKey9(config);
    const quoteMintToken = new PublicKey9(quoteMint);
    const payerAddress = new PublicKey9(payer);
    const tx = new Transaction2();
    const configTx = await this.program.methods.createConfig(configParam).accountsPartial({
      config,
      feeClaimer,
      leftoverReceiver,
      quoteMint,
      payer
    }).transaction();
    tx.add(configTx);
    const pool = deriveDbcPoolAddress(quoteMintToken, baseMint, configKey);
    const baseVault = deriveDbcTokenVaultAddress(pool, baseMint);
    const quoteVault = deriveDbcTokenVaultAddress(pool, quoteMintToken);
    const baseParams = {
      name,
      symbol,
      uri,
      pool,
      config: configKey,
      payer: payerAddress,
      poolCreator,
      baseMint,
      baseVault,
      quoteVault,
      quoteMint: quoteMintToken
    };
    if (createConfigAndPoolParam.tokenType === 0 /* SPL */) {
      const mintMetadata = deriveMintMetadata(baseMint);
      const poolTx = await this.initializeSplPool({
        ...baseParams,
        mintMetadata
      });
      tx.add(poolTx);
    } else {
      const poolTx = await this.initializeToken2022Pool(baseParams);
      tx.add(poolTx);
    }
    return tx;
  }
  /**
   * Create a new config and pool and buy tokens
   * @param createConfigAndPoolWithFirstBuyParam - The parameters for the config and pool and buy
   * @returns An object containing the new config transaction, new pool transaction, and first buy transaction
   */
  async createConfigAndPoolWithFirstBuy(createConfigAndPoolWithFirstBuyParam) {
    const {
      config,
      feeClaimer,
      leftoverReceiver,
      quoteMint,
      payer,
      ...configParam
    } = createConfigAndPoolWithFirstBuyParam;
    validateConfigParameters({ ...configParam, leftoverReceiver });
    const configKey = new PublicKey9(config);
    const quoteMintToken = new PublicKey9(quoteMint);
    const payerAddress = new PublicKey9(payer);
    const feeClaimerAddress = new PublicKey9(feeClaimer);
    const leftoverReceiverAddress = new PublicKey9(leftoverReceiver);
    const createConfigTx = await this.createConfigTx(
      configParam,
      configKey,
      feeClaimerAddress,
      leftoverReceiverAddress,
      quoteMintToken,
      payerAddress
    );
    const createPoolTx = await this.createPoolTx(
      {
        ...createConfigAndPoolWithFirstBuyParam.createPoolParam,
        config: configKey,
        payer: payerAddress
      },
      createConfigAndPoolWithFirstBuyParam.tokenType,
      quoteMintToken
    );
    const swapBuyTx = await this.swapBuyTx(
      createConfigAndPoolWithFirstBuyParam,
      configKey,
      quoteMintToken
    );
    return {
      createConfigTx,
      createPoolTx,
      swapBuyTx
    };
  }
  /**
   * Create a new pool and buy tokens
   * @param createPoolWithFirstBuyParam - The parameters for the pool and buy
   * @returns A transaction that creates the pool and buys tokens
   */
  async createPoolWithFirstBuy(createPoolWithFirstBuyParam) {
    const { baseMint, config, name, symbol, uri, payer, poolCreator } = createPoolWithFirstBuyParam.createPoolParam;
    const { buyAmount, minimumAmountOut, referralTokenAccount } = createPoolWithFirstBuyParam;
    const poolConfigState = await this.state.getPoolConfig(config);
    const { quoteMint, tokenType } = poolConfigState;
    const pool = deriveDbcPoolAddress(quoteMint, baseMint, config);
    const baseVault = deriveDbcTokenVaultAddress(pool, baseMint);
    const quoteVault = deriveDbcTokenVaultAddress(pool, quoteMint);
    const baseParams = {
      name,
      symbol,
      uri,
      pool,
      config,
      payer,
      poolCreator,
      baseMint,
      baseVault,
      quoteVault,
      quoteMint
    };
    let tx;
    if (tokenType === 0 /* SPL */) {
      const mintMetadata = deriveMintMetadata(baseMint);
      tx = await this.initializeSplPool({ ...baseParams, mintMetadata });
    } else {
      tx = await this.initializeToken2022Pool(baseParams);
    }
    validateSwapAmount(buyAmount);
    let currentPoint;
    if (poolConfigState.activationType === 0 /* Slot */) {
      const currentSlot = await this.connection.getSlot();
      currentPoint = new BN13(currentSlot);
    } else {
      const currentSlot = await this.connection.getSlot();
      const currentTime = await this.connection.getBlockTime(currentSlot);
      currentPoint = new BN13(currentTime);
    }
    const isRateLimiterApplied = checkRateLimiterApplied(
      poolConfigState.poolFees.baseFee.baseFeeMode,
      false,
      new BN13(0),
      new BN13(0),
      new BN13(0)
    );
    const { inputMint, outputMint, inputTokenProgram, outputTokenProgram } = this.prepareSwapParams(
      false,
      { baseMint, poolType: tokenType },
      poolConfigState
    );
    const {
      ataTokenA: inputTokenAccount,
      ataTokenB: outputTokenAccount,
      instructions: preInstructions
    } = await this.prepareTokenAccounts(
      poolCreator,
      poolCreator,
      inputMint,
      outputMint,
      inputTokenProgram,
      outputTokenProgram
    );
    if (inputMint.equals(NATIVE_MINT3)) {
      preInstructions.push(
        ...wrapSOLInstruction(
          poolCreator,
          inputTokenAccount,
          BigInt(buyAmount.toString())
        )
      );
    }
    const postInstructions = [];
    if ([inputMint.toBase58(), outputMint.toBase58()].includes(
      NATIVE_MINT3.toBase58()
    )) {
      const unwrapIx = unwrapSOLInstruction(poolCreator, poolCreator);
      unwrapIx && postInstructions.push(unwrapIx);
    }
    const remainingAccounts = isRateLimiterApplied ? [
      {
        isSigner: false,
        isWritable: false,
        pubkey: SYSVAR_INSTRUCTIONS_PUBKEY
      }
    ] : [];
    const firstBuyTx = await this.program.methods.swap({
      amountIn: buyAmount,
      minimumAmountOut
    }).accountsPartial({
      baseMint,
      quoteMint,
      pool,
      baseVault,
      quoteVault,
      config,
      poolAuthority: this.poolAuthority,
      referralTokenAccount,
      inputTokenAccount,
      outputTokenAccount,
      payer: poolCreator,
      tokenBaseProgram: outputTokenProgram,
      tokenQuoteProgram: inputTokenProgram
    }).remainingAccounts(remainingAccounts).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    tx.add(...firstBuyTx.instructions);
    return tx;
  }
  /**
   * Swap between base and quote
   * @param pool - The pool address
   * @param swapParam - The parameters for the swap
   * @returns A swap transaction
   */
  async swap(swapParam) {
    const poolState = await this.state.getPool(swapParam.pool);
    if (!poolState) {
      throw new Error(`Pool not found: ${swapParam.pool.toString()}`);
    }
    const poolConfigState = await this.state.getPoolConfig(poolState.config);
    const { amountIn, minimumAmountOut, swapBaseForQuote, owner } = swapParam;
    validateSwapAmount(amountIn);
    let currentPoint;
    if (poolConfigState.activationType === 0 /* Slot */) {
      const currentSlot = await this.connection.getSlot();
      currentPoint = new BN13(currentSlot);
    } else {
      const currentSlot = await this.connection.getSlot();
      const currentTime = await this.connection.getBlockTime(currentSlot);
      currentPoint = new BN13(currentTime);
    }
    const isRateLimiterApplied = checkRateLimiterApplied(
      poolConfigState.poolFees.baseFee.baseFeeMode,
      swapBaseForQuote,
      currentPoint,
      poolState.activationPoint,
      poolConfigState.poolFees.baseFee.secondFactor
    );
    const { inputMint, outputMint, inputTokenProgram, outputTokenProgram } = this.prepareSwapParams(swapBaseForQuote, poolState, poolConfigState);
    const {
      ataTokenA: inputTokenAccount,
      ataTokenB: outputTokenAccount,
      instructions: preInstructions
    } = await this.prepareTokenAccounts(
      owner,
      owner,
      inputMint,
      outputMint,
      inputTokenProgram,
      outputTokenProgram
    );
    if (inputMint.equals(NATIVE_MINT3)) {
      preInstructions.push(
        ...wrapSOLInstruction(
          owner,
          inputTokenAccount,
          BigInt(amountIn.toString())
        )
      );
    }
    const postInstructions = [];
    if ([inputMint.toBase58(), outputMint.toBase58()].includes(
      NATIVE_MINT3.toBase58()
    )) {
      const unwrapIx = unwrapSOLInstruction(owner, owner);
      unwrapIx && postInstructions.push(unwrapIx);
    }
    const remainingAccounts = isRateLimiterApplied ? [
      {
        isSigner: false,
        isWritable: false,
        pubkey: SYSVAR_INSTRUCTIONS_PUBKEY
      }
    ] : [];
    return this.program.methods.swap({
      amountIn,
      minimumAmountOut
    }).accountsPartial({
      baseMint: poolState.baseMint,
      quoteMint: poolConfigState.quoteMint,
      pool: swapParam.pool,
      baseVault: poolState.baseVault,
      quoteVault: poolState.quoteVault,
      config: poolState.config,
      poolAuthority: this.poolAuthority,
      referralTokenAccount: swapParam.referralTokenAccount,
      inputTokenAccount,
      outputTokenAccount,
      payer: owner,
      tokenBaseProgram: swapBaseForQuote ? inputTokenProgram : outputTokenProgram,
      tokenQuoteProgram: swapBaseForQuote ? outputTokenProgram : inputTokenProgram
    }).remainingAccounts(remainingAccounts).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
  }
  /**
   * Calculate the amount out for a swap (quote)
   * @param virtualPool - The virtual pool
   * @param config - The config
   * @param swapBaseForQuote - Whether to swap base for quote
   * @param amountIn - The amount in
   * @param slippageBps - Slippage tolerance in basis points (100 = 1%)
   * @param hasReferral - Whether the referral is enabled
   * @param currentPoint - The current point
   * @returns The swap quote result
   */
  swapQuote(swapQuoteParam) {
    const {
      virtualPool,
      config,
      swapBaseForQuote,
      amountIn,
      slippageBps = 0,
      hasReferral,
      currentPoint
    } = swapQuoteParam;
    return swapQuote(
      virtualPool,
      config,
      swapBaseForQuote,
      amountIn,
      slippageBps,
      hasReferral,
      currentPoint
    );
  }
  swapQuoteExactIn(swapQuoteExactInParam) {
    const { virtualPool, config, currentPoint } = swapQuoteExactInParam;
    const requiredQuoteAmount = calculateQuoteExactInAmount(
      config,
      virtualPool,
      currentPoint
    );
    return {
      exactAmountIn: requiredQuoteAmount
    };
  }
};

// src/services/migration.ts
import {
  ComputeBudgetProgram,
  Keypair,
  SystemProgram as SystemProgram3,
  SYSVAR_RENT_PUBKEY as SYSVAR_RENT_PUBKEY2
} from "@solana/web3.js";
import {
  ASSOCIATED_TOKEN_PROGRAM_ID as ASSOCIATED_TOKEN_PROGRAM_ID2,
  createAssociatedTokenAccountIdempotentInstruction as createAssociatedTokenAccountIdempotentInstruction2,
  getAssociatedTokenAddressSync as getAssociatedTokenAddressSync2,
  TOKEN_2022_PROGRAM_ID as TOKEN_2022_PROGRAM_ID3,
  TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID4
} from "@solana/spl-token";
var MigrationService = class extends DynamicBondingCurveProgram {
  constructor(connection, commitment) {
    super(connection, commitment);
    this.state = new StateService(connection, commitment);
  }
  /**
   * Get vault program instance
   * @returns The vault program instance
   */
  getVaultProgram() {
    return createVaultProgram(this.connection);
  }
  /**
   * Get DAMM V1 program instance
   * @returns The DAMM V1 program instance
   */
  getDammV1Program() {
    return createDammV1Program(this.connection);
  }
  /**
   * Create Locker (if there is lockedVesting)
   * @param createLockerParam - The parameters for the locker
   * @returns A create locker transaction
   */
  async createLocker(createLockerParam) {
    const poolAuthority = deriveDbcPoolAuthority();
    const lockerEventAuthority = deriveLockerEventAuthority();
    const virtualPoolState = await this.state.getPool(
      createLockerParam.virtualPool
    );
    if (!virtualPoolState) {
      throw new Error(
        `Pool not found: ${createLockerParam.virtualPool.toString()}`
      );
    }
    const poolConfigState = await this.state.getPoolConfig(
      virtualPoolState.config
    );
    const base = deriveBaseKeyForLocker(createLockerParam.virtualPool);
    const escrow = deriveEscrow(base);
    const tokenProgram = poolConfigState.tokenType === 0 ? TOKEN_PROGRAM_ID4 : TOKEN_2022_PROGRAM_ID3;
    const escrowToken = findAssociatedTokenAddress(
      escrow,
      virtualPoolState.baseMint,
      tokenProgram
    );
    const preInstructions = [];
    const createOwnerEscrowVaultTokenXIx = createAssociatedTokenAccountIdempotentInstruction2(
      createLockerParam.payer,
      escrowToken,
      escrow,
      virtualPoolState.baseMint,
      tokenProgram
    );
    preInstructions.push(createOwnerEscrowVaultTokenXIx);
    const accounts = {
      virtualPool: createLockerParam.virtualPool,
      config: virtualPoolState.config,
      poolAuthority,
      baseVault: virtualPoolState.baseVault,
      baseMint: virtualPoolState.baseMint,
      base,
      creator: virtualPoolState.creator,
      escrow,
      escrowToken,
      payer: createLockerParam.payer,
      tokenProgram,
      lockerProgram: LOCKER_PROGRAM_ID,
      lockerEventAuthority,
      systemProgram: SystemProgram3.programId
    };
    return this.program.methods.createLocker().accountsPartial(accounts).preInstructions(preInstructions).transaction();
  }
  /**
   * Withdraw leftover
   * @param withdrawLeftoverParam - The parameters for the withdraw leftover
   * @returns A withdraw leftover transaction
   */
  async withdrawLeftover(withdrawLeftoverParam) {
    const poolState = await this.state.getPool(
      withdrawLeftoverParam.virtualPool
    );
    if (!poolState) {
      throw new Error(
        `Pool not found: ${withdrawLeftoverParam.virtualPool.toString()}`
      );
    }
    const poolConfigState = await this.state.getPoolConfig(poolState.config);
    const tokenBaseProgram = getTokenProgram(poolConfigState.tokenType);
    const preInstructions = [];
    const { ataPubkey: tokenBaseAccount, ix: createBaseTokenAccountIx } = await getOrCreateATAInstruction(
      this.connection,
      poolState.baseMint,
      poolConfigState.leftoverReceiver,
      poolConfigState.leftoverReceiver,
      true,
      tokenBaseProgram
    );
    createBaseTokenAccountIx && preInstructions.push(createBaseTokenAccountIx);
    return this.program.methods.withdrawLeftover().accountsPartial({
      poolAuthority: this.poolAuthority,
      config: poolState.config,
      virtualPool: withdrawLeftoverParam.virtualPool,
      tokenBaseAccount,
      baseVault: poolState.baseVault,
      baseMint: poolState.baseMint,
      leftoverReceiver: poolConfigState.leftoverReceiver,
      tokenBaseProgram
    }).preInstructions(preInstructions).transaction();
  }
  ///////////////////////
  // DAMM V1 FUNCTIONS //
  ///////////////////////
  /**
   * Create metadata for the migration of Meteora DAMM V1
   * @param createDammV1MigrationMetadataParam - The parameters for the migration
   * @returns A migration transaction
   */
  async createDammV1MigrationMetadata(createDammV1MigrationMetadataParam) {
    const migrationMetadata = deriveDammV1MigrationMetadataAddress(
      createDammV1MigrationMetadataParam.virtualPool
    );
    const accounts = {
      virtualPool: createDammV1MigrationMetadataParam.virtualPool,
      config: createDammV1MigrationMetadataParam.config,
      migrationMetadata,
      payer: createDammV1MigrationMetadataParam.payer,
      systemProgram: SystemProgram3.programId
    };
    return this.program.methods.migrationMeteoraDammCreateMetadata().accountsPartial(accounts).transaction();
  }
  /**
   * Migrate to DAMM V1
   * @param migrateToDammV1Param - The parameters for the migration
   * @returns A migrate transaction
   */
  async migrateToDammV1(migrateToDammV1Param) {
    const poolState = await this.state.getPool(
      migrateToDammV1Param.virtualPool
    );
    if (!poolState) {
      throw new Error(
        `Pool not found: ${migrateToDammV1Param.virtualPool.toString()}`
      );
    }
    const poolConfigState = await this.state.getPoolConfig(poolState.config);
    const migrationMetadata = deriveDammV1MigrationMetadataAddress(
      migrateToDammV1Param.virtualPool
    );
    const dammPool = deriveDammV1PoolAddress(
      migrateToDammV1Param.dammConfig,
      poolState.baseMint,
      poolConfigState.quoteMint
    );
    const lpMint = deriveDammV1LpMintAddress(dammPool);
    const mintMetadata = deriveMintMetadata(lpMint);
    const [protocolTokenAFee, protocolTokenBFee] = [
      deriveDammV1ProtocolFeeAddress(poolState.baseMint, dammPool),
      deriveDammV1ProtocolFeeAddress(poolConfigState.quoteMint, dammPool)
    ];
    const vaultProgram = this.getVaultProgram();
    const [
      {
        vaultPda: aVault,
        tokenVaultPda: aTokenVault,
        lpMintPda: aLpMintPda
      },
      {
        vaultPda: bVault,
        tokenVaultPda: bTokenVault,
        lpMintPda: bLpMintPda
      }
    ] = [
      deriveVaultPdas(poolState.baseMint),
      deriveVaultPdas(poolConfigState.quoteMint)
    ];
    const [aVaultAccount, bVaultAccount] = await Promise.all([
      vaultProgram.account.vault.fetchNullable(aVault),
      vaultProgram.account.vault.fetchNullable(bVault)
    ]);
    let aVaultLpMint = aLpMintPda;
    let bVaultLpMint = bLpMintPda;
    const preInstructions = [];
    if (!aVaultAccount) {
      const createVaultAIx = await createInitializePermissionlessDynamicVaultIx(
        poolState.baseMint,
        migrateToDammV1Param.payer,
        vaultProgram
      );
      if (createVaultAIx) {
        preInstructions.push(createVaultAIx.instruction);
      }
    } else {
      aVaultLpMint = aVaultAccount.lpMint;
    }
    if (!bVaultAccount) {
      const createVaultBIx = await createInitializePermissionlessDynamicVaultIx(
        poolConfigState.quoteMint,
        migrateToDammV1Param.payer,
        vaultProgram
      );
      if (createVaultBIx) {
        preInstructions.push(createVaultBIx.instruction);
      }
    } else {
      bVaultLpMint = bVaultAccount.lpMint;
    }
    const [aVaultLp, bVaultLp] = [
      deriveDammV1VaultLPAddress(aVault, dammPool),
      deriveDammV1VaultLPAddress(bVault, dammPool)
    ];
    const virtualPoolLp = getAssociatedTokenAddressSync2(
      lpMint,
      this.poolAuthority,
      true,
      TOKEN_PROGRAM_ID4,
      ASSOCIATED_TOKEN_PROGRAM_ID2
    );
    const transaction = await this.program.methods.migrateMeteoraDamm().accountsPartial({
      virtualPool: migrateToDammV1Param.virtualPool,
      migrationMetadata,
      config: poolState.config,
      poolAuthority: this.poolAuthority,
      pool: dammPool,
      dammConfig: migrateToDammV1Param.dammConfig,
      lpMint,
      tokenAMint: poolState.baseMint,
      tokenBMint: poolConfigState.quoteMint,
      aVault,
      bVault,
      aTokenVault,
      bTokenVault,
      aVaultLpMint,
      bVaultLpMint,
      aVaultLp,
      bVaultLp,
      baseVault: poolState.baseVault,
      quoteVault: poolState.quoteVault,
      virtualPoolLp,
      protocolTokenAFee,
      protocolTokenBFee,
      payer: migrateToDammV1Param.payer,
      rent: SYSVAR_RENT_PUBKEY2,
      mintMetadata,
      metadataProgram: METAPLEX_PROGRAM_ID,
      ammProgram: DAMM_V1_PROGRAM_ID,
      vaultProgram: VAULT_PROGRAM_ID,
      tokenProgram: TOKEN_PROGRAM_ID4,
      associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID2
    }).preInstructions(preInstructions).transaction();
    const modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({
      units: 5e5
    });
    transaction.add(modifyComputeUnits);
    return transaction;
  }
  /**
   * Lock DAMM V1 LP token for creator or partner
   * @param lockDammV1LpTokenParam - The parameters for the lock
   * @returns A lock transaction
   */
  async lockDammV1LpToken(lockDammV1LpTokenParam) {
    const poolState = await this.state.getPool(
      lockDammV1LpTokenParam.virtualPool
    );
    if (!poolState) {
      throw new Error(
        `Pool not found: ${lockDammV1LpTokenParam.virtualPool.toString()}`
      );
    }
    const poolConfigState = await this.state.getPoolConfig(poolState.config);
    const dammPool = deriveDammV1PoolAddress(
      lockDammV1LpTokenParam.dammConfig,
      poolState.baseMint,
      poolConfigState.quoteMint
    );
    const migrationMetadata = deriveDammV1MigrationMetadataAddress(
      lockDammV1LpTokenParam.virtualPool
    );
    const vaultProgram = this.getVaultProgram();
    const [
      { vaultPda: aVault, lpMintPda: aLpMintPda },
      { vaultPda: bVault, lpMintPda: bLpMintPda }
    ] = [
      deriveVaultPdas(poolState.baseMint),
      deriveVaultPdas(poolConfigState.quoteMint)
    ];
    const [aVaultAccount, bVaultAccount] = await Promise.all([
      vaultProgram.account.vault.fetchNullable(aVault),
      vaultProgram.account.vault.fetchNullable(bVault)
    ]);
    let aVaultLpMint = aLpMintPda;
    let bVaultLpMint = bLpMintPda;
    const preInstructions = [];
    if (!aVaultAccount) {
      const createVaultAIx = await createInitializePermissionlessDynamicVaultIx(
        poolState.baseMint,
        lockDammV1LpTokenParam.payer,
        vaultProgram
      );
      if (createVaultAIx) {
        preInstructions.push(createVaultAIx.instruction);
      }
    } else {
      aVaultLpMint = aVaultAccount.lpMint;
    }
    if (!bVaultAccount) {
      const createVaultBIx = await createInitializePermissionlessDynamicVaultIx(
        poolConfigState.quoteMint,
        lockDammV1LpTokenParam.payer,
        vaultProgram
      );
      if (createVaultBIx) {
        preInstructions.push(createVaultBIx.instruction);
      }
    } else {
      bVaultLpMint = bVaultAccount.lpMint;
    }
    const [aVaultLp, bVaultLp] = [
      deriveDammV1VaultLPAddress(aVault, dammPool),
      deriveDammV1VaultLPAddress(bVault, dammPool)
    ];
    const lpMint = deriveDammV1LpMintAddress(dammPool);
    const dammV1Program = this.getDammV1Program();
    let lockEscrowKey;
    if (lockDammV1LpTokenParam.isPartner) {
      lockEscrowKey = deriveDammV1LockEscrowAddress(
        dammPool,
        poolConfigState.feeClaimer
      );
      const lockEscrowData = await this.connection.getAccountInfo(lockEscrowKey);
      if (!lockEscrowData) {
        const ix = await createLockEscrowIx(
          lockDammV1LpTokenParam.payer,
          dammPool,
          lpMint,
          poolConfigState.feeClaimer,
          lockEscrowKey,
          dammV1Program
        );
        preInstructions.push(ix);
      }
    } else {
      lockEscrowKey = deriveDammV1LockEscrowAddress(
        dammPool,
        poolState.creator
      );
      const lockEscrowData = await this.connection.getAccountInfo(lockEscrowKey);
      if (!lockEscrowData) {
        const ix = await createLockEscrowIx(
          lockDammV1LpTokenParam.payer,
          dammPool,
          lpMint,
          poolState.creator,
          lockEscrowKey,
          dammV1Program
        );
        preInstructions.push(ix);
      }
    }
    const escrowVault = getAssociatedTokenAddressSync2(
      lpMint,
      lockEscrowKey,
      true,
      TOKEN_PROGRAM_ID4,
      ASSOCIATED_TOKEN_PROGRAM_ID2
    );
    const createEscrowVaultIx = createAssociatedTokenAccountIdempotentInstruction2(
      lockDammV1LpTokenParam.payer,
      escrowVault,
      lockEscrowKey,
      lpMint,
      TOKEN_PROGRAM_ID4,
      ASSOCIATED_TOKEN_PROGRAM_ID2
    );
    preInstructions.push(createEscrowVaultIx);
    const sourceTokens = getAssociatedTokenAddressSync2(
      lpMint,
      this.poolAuthority,
      true
    );
    return this.program.methods.migrateMeteoraDammLockLpToken().accountsPartial({
      virtualPool: lockDammV1LpTokenParam.virtualPool,
      migrationMetadata,
      poolAuthority: this.poolAuthority,
      pool: dammPool,
      lpMint,
      lockEscrow: lockEscrowKey,
      owner: lockDammV1LpTokenParam.isPartner ? poolConfigState.feeClaimer : poolState.creator,
      sourceTokens,
      escrowVault,
      aVault,
      bVault,
      aVaultLp,
      bVaultLp,
      aVaultLpMint,
      bVaultLpMint,
      ammProgram: DAMM_V1_PROGRAM_ID,
      tokenProgram: TOKEN_PROGRAM_ID4
    }).preInstructions(preInstructions).transaction();
  }
  /**
   * Claim DAMM V1 LP token for creator or partner
   * @param claimDammV1LpTokenParam - The parameters for the claim
   * @returns A claim transaction
   */
  async claimDammV1LpToken(claimDammV1LpTokenParam) {
    const poolAuthority = deriveDbcPoolAuthority();
    const virtualPoolState = await this.state.getPool(
      claimDammV1LpTokenParam.virtualPool
    );
    if (!virtualPoolState) {
      throw new Error(
        `Pool not found: ${claimDammV1LpTokenParam.virtualPool.toString()}`
      );
    }
    const poolConfigState = await this.state.getPoolConfig(
      virtualPoolState.config
    );
    const dammPool = deriveDammV1PoolAddress(
      claimDammV1LpTokenParam.dammConfig,
      virtualPoolState.baseMint,
      poolConfigState.quoteMint
    );
    const migrationMetadata = deriveDammV1MigrationMetadataAddress(
      claimDammV1LpTokenParam.virtualPool
    );
    const lpMint = deriveDammV1LpMintAddress(dammPool);
    let destinationToken;
    if (claimDammV1LpTokenParam.isPartner) {
      destinationToken = findAssociatedTokenAddress(
        poolConfigState.feeClaimer,
        lpMint,
        TOKEN_PROGRAM_ID4
      );
    } else {
      destinationToken = findAssociatedTokenAddress(
        virtualPoolState.creator,
        lpMint,
        TOKEN_PROGRAM_ID4
      );
    }
    const preInstructions = [];
    const createDestinationTokenIx = createAssociatedTokenAccountIdempotentInstruction2(
      claimDammV1LpTokenParam.payer,
      destinationToken,
      claimDammV1LpTokenParam.isPartner ? poolConfigState.feeClaimer : virtualPoolState.creator,
      lpMint,
      TOKEN_PROGRAM_ID4
    );
    preInstructions.push(createDestinationTokenIx);
    const sourceToken = getAssociatedTokenAddressSync2(
      lpMint,
      poolAuthority,
      true
    );
    const accounts = {
      virtualPool: claimDammV1LpTokenParam.virtualPool,
      migrationMetadata,
      poolAuthority,
      lpMint,
      sourceToken,
      destinationToken,
      owner: claimDammV1LpTokenParam.isPartner ? poolConfigState.feeClaimer : virtualPoolState.creator,
      sender: claimDammV1LpTokenParam.payer,
      tokenProgram: TOKEN_PROGRAM_ID4
    };
    return this.program.methods.migrateMeteoraDammClaimLpToken().accountsPartial(accounts).preInstructions(preInstructions).transaction();
  }
  ///////////////////////
  // DAMM V2 FUNCTIONS //
  ///////////////////////
  /**
   * Create metadata for the migration of Meteora DAMM V2
   * @param createDammV2MigrationMetadataParam - The parameters for the migration
   * @returns A migration transaction
   */
  async createDammV2MigrationMetadata(createDammV2MigrationMetadataParam) {
    const migrationMetadata = deriveDammV2MigrationMetadataAddress(
      createDammV2MigrationMetadataParam.virtualPool
    );
    const accounts = {
      virtualPool: createDammV2MigrationMetadataParam.virtualPool,
      config: createDammV2MigrationMetadataParam.config,
      migrationMetadata,
      payer: createDammV2MigrationMetadataParam.payer,
      systemProgram: SystemProgram3.programId
    };
    return this.program.methods.migrationDammV2CreateMetadata().accountsPartial(accounts).transaction();
  }
  /**
   * Migrate to DAMM V2
   * @param migrateToDammV2Param - The parameters for the migration
   * @returns A migrate transaction
   */
  async migrateToDammV2(migrateToDammV2Param) {
    const poolAuthority = deriveDbcPoolAuthority();
    const dammPoolAuthority = deriveDammV2PoolAuthority();
    const dammEventAuthority = deriveDammV2EventAuthority();
    const virtualPoolState = await this.state.getPool(
      migrateToDammV2Param.virtualPool
    );
    if (!virtualPoolState) {
      throw new Error(
        `Pool not found: ${migrateToDammV2Param.virtualPool.toString()}`
      );
    }
    const poolConfigState = await this.state.getPoolConfig(
      virtualPoolState.config
    );
    const migrationMetadata = deriveDammV2MigrationMetadataAddress(
      migrateToDammV2Param.virtualPool
    );
    const dammPool = deriveDammV2PoolAddress(
      migrateToDammV2Param.dammConfig,
      virtualPoolState.baseMint,
      poolConfigState.quoteMint
    );
    const firstPositionNftKP = Keypair.generate();
    const firstPosition = derivePositionAddress(
      firstPositionNftKP.publicKey
    );
    const firstPositionNftAccount = derivePositionNftAccount(
      firstPositionNftKP.publicKey
    );
    const secondPositionNftKP = Keypair.generate();
    const secondPosition = derivePositionAddress(
      secondPositionNftKP.publicKey
    );
    const secondPositionNftAccount = derivePositionNftAccount(
      secondPositionNftKP.publicKey
    );
    const tokenAVault = deriveDammV2TokenVaultAddress(
      dammPool,
      virtualPoolState.baseMint
    );
    const tokenBVault = deriveDammV2TokenVaultAddress(
      dammPool,
      poolConfigState.quoteMint
    );
    const tokenBaseProgram = poolConfigState.tokenType == 0 ? TOKEN_PROGRAM_ID4 : TOKEN_2022_PROGRAM_ID3;
    const tokenQuoteProgram = poolConfigState.quoteTokenFlag == 0 ? TOKEN_PROGRAM_ID4 : TOKEN_2022_PROGRAM_ID3;
    const tx = await this.program.methods.migrationDammV2().accountsStrict({
      virtualPool: migrateToDammV2Param.virtualPool,
      migrationMetadata,
      config: virtualPoolState.config,
      poolAuthority,
      pool: dammPool,
      firstPositionNftMint: firstPositionNftKP.publicKey,
      firstPosition,
      firstPositionNftAccount,
      secondPositionNftMint: secondPositionNftKP.publicKey,
      secondPosition,
      secondPositionNftAccount,
      dammPoolAuthority,
      ammProgram: DAMM_V2_PROGRAM_ID,
      baseMint: virtualPoolState.baseMint,
      quoteMint: poolConfigState.quoteMint,
      tokenAVault,
      tokenBVault,
      baseVault: virtualPoolState.baseVault,
      quoteVault: virtualPoolState.quoteVault,
      payer: migrateToDammV2Param.payer,
      tokenBaseProgram,
      tokenQuoteProgram,
      token2022Program: TOKEN_2022_PROGRAM_ID3,
      systemProgram: SystemProgram3.programId,
      dammEventAuthority
    }).remainingAccounts([
      {
        isSigner: false,
        isWritable: false,
        pubkey: migrateToDammV2Param.dammConfig
      }
    ]).transaction();
    const modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({
      units: 5e5
    });
    tx.add(modifyComputeUnits);
    return {
      transaction: tx,
      firstPositionNftKeypair: firstPositionNftKP,
      secondPositionNftKeypair: secondPositionNftKP
    };
  }
};

// src/services/partner.ts
import {
  SystemProgram as SystemProgram4
} from "@solana/web3.js";
import {
  createAssociatedTokenAccountIdempotentInstruction as createAssociatedTokenAccountIdempotentInstruction3,
  NATIVE_MINT as NATIVE_MINT4
} from "@solana/spl-token";
var PartnerService = class extends DynamicBondingCurveProgram {
  constructor(connection, commitment) {
    super(connection, commitment);
    this.state = new StateService(connection, commitment);
  }
  /**
   * Create a new config
   * @param createConfigParam - The parameters for the config
   * @returns A new config
   */
  async createConfig(createConfigParam) {
    const {
      config,
      feeClaimer,
      leftoverReceiver,
      quoteMint,
      payer,
      ...configParam
    } = createConfigParam;
    validateConfigParameters({ ...configParam, leftoverReceiver });
    return this.program.methods.createConfig(configParam).accountsPartial({
      config,
      feeClaimer,
      leftoverReceiver,
      quoteMint,
      payer
    }).transaction();
  }
  /**
   * Create partner metadata
   * @param createPartnerMetadataParam - The parameters for the partner metadata
   * @returns A create partner metadata transaction
   */
  async createPartnerMetadata(createPartnerMetadataParam) {
    const partnerMetadata = derivePartnerMetadata(
      createPartnerMetadataParam.feeClaimer
    );
    const partnerMetadataParam = {
      padding: new Array(96).fill(0),
      name: createPartnerMetadataParam.name,
      website: createPartnerMetadataParam.website,
      logo: createPartnerMetadataParam.logo
    };
    return this.program.methods.createPartnerMetadata(partnerMetadataParam).accountsPartial({
      partnerMetadata,
      payer: createPartnerMetadataParam.payer,
      feeClaimer: createPartnerMetadataParam.feeClaimer,
      systemProgram: SystemProgram4.programId
    }).transaction();
  }
  /**
   * Private method to claim trading fee with quote mint SOL
   * @param claimWithQuoteMintSolParam - The parameters for the claim with quote mint SOL
   * @returns A claim trading fee with quote mint SOL accounts, pre instructions and post instructions
   */
  async claimWithQuoteMintSol(claimWithQuoteMintSolParam) {
    const {
      feeClaimer,
      payer,
      feeReceiver,
      config,
      tempWSolAcc,
      pool,
      poolState,
      poolConfigState,
      tokenBaseProgram,
      tokenQuoteProgram
    } = claimWithQuoteMintSolParam;
    const preInstructions = [];
    const postInstructions = [];
    const tokenBaseAccount = findAssociatedTokenAddress(
      feeReceiver,
      poolState.baseMint,
      tokenBaseProgram
    );
    const tokenQuoteAccount = findAssociatedTokenAddress(
      tempWSolAcc,
      poolConfigState.quoteMint,
      tokenQuoteProgram
    );
    const createTokenBaseAccountIx = createAssociatedTokenAccountIdempotentInstruction3(
      payer,
      tokenBaseAccount,
      feeReceiver,
      poolState.baseMint,
      tokenBaseProgram
    );
    createTokenBaseAccountIx && preInstructions.push(createTokenBaseAccountIx);
    const createTokenQuoteAccountIx = createAssociatedTokenAccountIdempotentInstruction3(
      payer,
      tokenQuoteAccount,
      tempWSolAcc,
      poolConfigState.quoteMint,
      tokenQuoteProgram
    );
    createTokenQuoteAccountIx && preInstructions.push(createTokenQuoteAccountIx);
    const unwrapSolIx = unwrapSOLInstruction(tempWSolAcc, feeReceiver);
    unwrapSolIx && postInstructions.push(unwrapSolIx);
    const accounts = {
      poolAuthority: this.poolAuthority,
      config,
      pool,
      tokenAAccount: tokenBaseAccount,
      tokenBAccount: tokenQuoteAccount,
      baseVault: poolState.baseVault,
      quoteVault: poolState.quoteVault,
      baseMint: poolState.baseMint,
      quoteMint: poolConfigState.quoteMint,
      feeClaimer,
      tokenBaseProgram,
      tokenQuoteProgram
    };
    return { accounts, preInstructions, postInstructions };
  }
  /**
   * Private method to claim trading fee with quote mint not SOL
   * @param claimWithQuoteMintNotSolParam - The parameters for the claim with quote mint not SOL
   * @returns A claim trading fee with quote mint not SOL accounts and pre instructions
   */
  async claimWithQuoteMintNotSol(claimWithQuoteMintNotSolParam) {
    const {
      feeClaimer,
      payer,
      feeReceiver,
      config,
      pool,
      poolState,
      poolConfigState,
      tokenBaseProgram,
      tokenQuoteProgram
    } = claimWithQuoteMintNotSolParam;
    const {
      ataTokenA: tokenBaseAccount,
      ataTokenB: tokenQuoteAccount,
      instructions: preInstructions
    } = await this.prepareTokenAccounts(
      feeReceiver,
      payer,
      poolState.baseMint,
      poolConfigState.quoteMint,
      tokenBaseProgram,
      tokenQuoteProgram
    );
    const accounts = {
      poolAuthority: this.poolAuthority,
      config,
      pool,
      tokenAAccount: tokenBaseAccount,
      tokenBAccount: tokenQuoteAccount,
      baseVault: poolState.baseVault,
      quoteVault: poolState.quoteVault,
      baseMint: poolState.baseMint,
      quoteMint: poolConfigState.quoteMint,
      feeClaimer,
      tokenBaseProgram,
      tokenQuoteProgram
    };
    return { accounts, preInstructions };
  }
  /**
   * Claim partner trading fee
   * @param claimTradingFeeParam - The parameters for the claim trading fee
   * @returns A claim trading fee transaction
   */
  async claimPartnerTradingFee(claimTradingFeeParam) {
    const {
      feeClaimer,
      payer,
      pool,
      maxBaseAmount,
      maxQuoteAmount,
      receiver,
      tempWSolAcc
    } = claimTradingFeeParam;
    const poolState = await this.state.getPool(pool);
    if (!poolState) {
      throw new Error(`Pool not found: ${pool.toString()}`);
    }
    const poolConfigState = await this.state.getPoolConfig(poolState.config);
    if (!poolConfigState) {
      throw new Error(`Pool config not found: ${pool.toString()}`);
    }
    const tokenBaseProgram = getTokenProgram(poolConfigState.tokenType);
    const tokenQuoteProgram = getTokenProgram(
      poolConfigState.quoteTokenFlag
    );
    const isSOLQuoteMint = isNativeSol(poolConfigState.quoteMint);
    if (isSOLQuoteMint) {
      const tempWSol = receiver && !receiver.equals(feeClaimer) ? tempWSolAcc : feeClaimer;
      const feeReceiver = receiver ? receiver : feeClaimer;
      const result = await this.claimWithQuoteMintSol({
        feeClaimer,
        payer,
        feeReceiver,
        config: poolState.config,
        tempWSolAcc: tempWSol,
        pool,
        poolState,
        poolConfigState,
        tokenBaseProgram,
        tokenQuoteProgram
      });
      return this.program.methods.claimTradingFee(maxBaseAmount, maxQuoteAmount).accountsPartial(result.accounts).preInstructions(result.preInstructions).postInstructions(result.postInstructions).transaction();
    } else {
      const feeReceiver = receiver ? receiver : feeClaimer;
      const result = await this.claimWithQuoteMintNotSol({
        feeClaimer,
        payer,
        feeReceiver,
        config: poolState.config,
        pool,
        poolState,
        poolConfigState,
        tokenBaseProgram,
        tokenQuoteProgram
      });
      return this.program.methods.claimTradingFee(maxBaseAmount, maxQuoteAmount).accountsPartial(result.accounts).preInstructions(result.preInstructions).transaction();
    }
  }
  /**
   * Claim partner trading fee
   * @param claimTradingFee2Param - The parameters for the claim trading fee
   * @returns A claim trading fee transaction
   */
  async claimPartnerTradingFee2(claimTradingFee2Param) {
    const {
      feeClaimer,
      payer,
      pool,
      maxBaseAmount,
      maxQuoteAmount,
      receiver
    } = claimTradingFee2Param;
    const poolState = await this.state.getPool(pool);
    if (!poolState) {
      throw new Error(`Pool not found: ${pool.toString()}`);
    }
    const poolConfigState = await this.state.getPoolConfig(poolState.config);
    if (!poolConfigState) {
      throw new Error(`Pool config not found: ${pool.toString()}`);
    }
    const tokenBaseProgram = getTokenProgram(poolConfigState.tokenType);
    const tokenQuoteProgram = getTokenProgram(
      poolConfigState.quoteTokenFlag
    );
    const isSOLQuoteMint = isNativeSol(poolConfigState.quoteMint);
    if (isSOLQuoteMint) {
      const preInstructions = [];
      const postInstructions = [];
      const tokenBaseAccount = findAssociatedTokenAddress(
        receiver,
        poolState.baseMint,
        tokenBaseProgram
      );
      const tokenQuoteAccount = findAssociatedTokenAddress(
        feeClaimer,
        poolConfigState.quoteMint,
        tokenQuoteProgram
      );
      const createTokenBaseAccountIx = createAssociatedTokenAccountIdempotentInstruction3(
        payer,
        tokenBaseAccount,
        receiver,
        poolState.baseMint,
        tokenBaseProgram
      );
      createTokenBaseAccountIx && preInstructions.push(createTokenBaseAccountIx);
      const createTokenQuoteAccountIx = createAssociatedTokenAccountIdempotentInstruction3(
        payer,
        tokenQuoteAccount,
        feeClaimer,
        poolConfigState.quoteMint,
        tokenQuoteProgram
      );
      createTokenQuoteAccountIx && preInstructions.push(createTokenQuoteAccountIx);
      const unwrapSolIx = unwrapSOLInstruction(feeClaimer, receiver);
      unwrapSolIx && postInstructions.push(unwrapSolIx);
      const accounts = {
        poolAuthority: this.poolAuthority,
        pool,
        tokenAAccount: tokenBaseAccount,
        tokenBAccount: tokenQuoteAccount,
        baseVault: poolState.baseVault,
        quoteVault: poolState.quoteVault,
        baseMint: poolState.baseMint,
        quoteMint: poolConfigState.quoteMint,
        feeClaimer,
        tokenBaseProgram,
        tokenQuoteProgram
      };
      return this.program.methods.claimTradingFee(maxBaseAmount, maxQuoteAmount).accountsPartial(accounts).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    } else {
      const result = await this.claimWithQuoteMintNotSol({
        feeClaimer,
        payer,
        feeReceiver: receiver,
        config: poolState.config,
        pool,
        poolState,
        poolConfigState,
        tokenBaseProgram,
        tokenQuoteProgram
      });
      return this.program.methods.claimTradingFee(maxBaseAmount, maxQuoteAmount).accountsPartial(result.accounts).preInstructions(result.preInstructions).postInstructions([]).transaction();
    }
  }
  /**
   * Partner withdraw surplus
   * @param partnerWithdrawSurplusParam - The parameters for the partner withdraw surplus
   * @returns A partner withdraw surplus transaction
   */
  async partnerWithdrawSurplus(partnerWithdrawSurplusParam) {
    const poolState = await this.state.getPool(
      partnerWithdrawSurplusParam.virtualPool
    );
    if (!poolState) {
      throw new Error(
        `Pool not found: ${partnerWithdrawSurplusParam.virtualPool.toString()}`
      );
    }
    const poolConfigState = await this.state.getPoolConfig(poolState.config);
    const tokenQuoteProgram = getTokenProgram(
      poolConfigState.quoteTokenFlag
    );
    const preInstructions = [];
    const postInstructions = [];
    const { ataPubkey: tokenQuoteAccount, ix: createQuoteTokenAccountIx } = await getOrCreateATAInstruction(
      this.connection,
      poolConfigState.quoteMint,
      partnerWithdrawSurplusParam.feeClaimer,
      partnerWithdrawSurplusParam.feeClaimer,
      true,
      tokenQuoteProgram
    );
    createQuoteTokenAccountIx && preInstructions.push(createQuoteTokenAccountIx);
    if (poolConfigState.quoteMint.equals(NATIVE_MINT4)) {
      const unwrapSolIx = unwrapSOLInstruction(
        partnerWithdrawSurplusParam.feeClaimer,
        partnerWithdrawSurplusParam.feeClaimer
      );
      unwrapSolIx && postInstructions.push(unwrapSolIx);
    }
    return this.program.methods.partnerWithdrawSurplus().accountsPartial({
      poolAuthority: this.poolAuthority,
      config: poolState.config,
      virtualPool: partnerWithdrawSurplusParam.virtualPool,
      tokenQuoteAccount,
      quoteVault: poolState.quoteVault,
      quoteMint: poolConfigState.quoteMint,
      feeClaimer: partnerWithdrawSurplusParam.feeClaimer,
      tokenQuoteProgram
    }).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
  }
  async partnerWithdrawMigrationFee(withdrawMigrationFeeParams) {
    const { virtualPool, sender, feePayer } = withdrawMigrationFeeParams;
    const virtualPoolState = await this.state.getPool(virtualPool);
    const configState = await this.state.getPoolConfig(
      virtualPoolState.config
    );
    const { ataPubkey: tokenQuoteAccount, ix: preInstruction } = await getOrCreateATAInstruction(
      this.program.provider.connection,
      configState.quoteMint,
      sender,
      feePayer ?? sender,
      true,
      getTokenProgram(configState.quoteTokenFlag)
    );
    const postInstruction = [];
    if (configState.quoteMint.equals(NATIVE_MINT4)) {
      const unwarpSOLIx = unwrapSOLInstruction(sender, sender);
      unwarpSOLIx && postInstruction.push(unwarpSOLIx);
    }
    const transaction = await this.program.methods.withdrawMigrationFee(0).accountsPartial({
      poolAuthority: this.poolAuthority,
      config: virtualPoolState.config,
      virtualPool,
      tokenQuoteAccount,
      quoteVault: virtualPoolState.quoteVault,
      quoteMint: configState.quoteMint,
      sender,
      tokenQuoteProgram: getTokenProgram(configState.quoteTokenFlag)
    }).preInstructions([preInstruction]).postInstructions(postInstruction).transaction();
    return transaction;
  }
};

// src/services/creator.ts
import {
  SystemProgram as SystemProgram5
} from "@solana/web3.js";
import {
  createAssociatedTokenAccountIdempotentInstruction as createAssociatedTokenAccountIdempotentInstruction4,
  NATIVE_MINT as NATIVE_MINT5,
  TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID5
} from "@solana/spl-token";
var CreatorService = class extends DynamicBondingCurveProgram {
  constructor(connection, commitment) {
    super(connection, commitment);
    this.state = new StateService(connection, commitment);
  }
  /**
   * Create virtual pool metadata
   * @param createVirtualPoolMetadataParam - The parameters for the virtual pool metadata
   * @returns A create virtual pool metadata transaction
   */
  async createPoolMetadata(createVirtualPoolMetadataParam) {
    const virtualPoolMetadata = deriveDbcPoolMetadata(
      createVirtualPoolMetadataParam.virtualPool
    );
    return this.program.methods.createVirtualPoolMetadata({
      padding: new Array(96).fill(0),
      name: createVirtualPoolMetadataParam.name,
      website: createVirtualPoolMetadataParam.website,
      logo: createVirtualPoolMetadataParam.logo
    }).accountsPartial({
      virtualPool: createVirtualPoolMetadataParam.virtualPool,
      virtualPoolMetadata,
      creator: createVirtualPoolMetadataParam.creator,
      payer: createVirtualPoolMetadataParam.payer,
      systemProgram: SystemProgram5.programId
    }).transaction();
  }
  /**
   * Private method to claim trading fee with quote mint SOL
   * @param claimWithQuoteMintSolParam - The parameters for the claim with quote mint SOL
   * @returns A claim trading fee with quote mint SOL accounts, pre instructions and post instructions
   */
  async claimWithQuoteMintSol(claimWithQuoteMintSolParam) {
    const {
      creator,
      payer,
      feeReceiver,
      tempWSolAcc,
      pool,
      poolState,
      poolConfigState,
      tokenBaseProgram,
      tokenQuoteProgram
    } = claimWithQuoteMintSolParam;
    const preInstructions = [];
    const postInstructions = [];
    const tokenBaseAccount = findAssociatedTokenAddress(
      feeReceiver,
      poolState.baseMint,
      tokenBaseProgram
    );
    const tokenQuoteAccount = findAssociatedTokenAddress(
      tempWSolAcc,
      poolConfigState.quoteMint,
      tokenQuoteProgram
    );
    const createTokenBaseAccountIx = createAssociatedTokenAccountIdempotentInstruction4(
      payer,
      tokenBaseAccount,
      feeReceiver,
      poolState.baseMint,
      tokenBaseProgram
    );
    createTokenBaseAccountIx && preInstructions.push(createTokenBaseAccountIx);
    const createTokenQuoteAccountIx = createAssociatedTokenAccountIdempotentInstruction4(
      payer,
      tokenQuoteAccount,
      tempWSolAcc,
      poolConfigState.quoteMint,
      tokenQuoteProgram
    );
    createTokenQuoteAccountIx && preInstructions.push(createTokenQuoteAccountIx);
    const unwrapSolIx = unwrapSOLInstruction(tempWSolAcc, feeReceiver);
    unwrapSolIx && postInstructions.push(unwrapSolIx);
    const accounts = {
      poolAuthority: this.poolAuthority,
      pool,
      tokenAAccount: tokenBaseAccount,
      tokenBAccount: tokenQuoteAccount,
      baseVault: poolState.baseVault,
      quoteVault: poolState.quoteVault,
      baseMint: poolState.baseMint,
      quoteMint: poolConfigState.quoteMint,
      creator,
      tokenBaseProgram,
      tokenQuoteProgram
    };
    return { accounts, preInstructions, postInstructions };
  }
  /**
   * Private method to claim trading fee with quote mint not SOL
   * @param claimWithQuoteMintNotSolParam - The parameters for the claim with quote mint not SOL
   * @returns A claim trading fee with quote mint not SOL accounts and pre instructions
   */
  async claimWithQuoteMintNotSol(claimWithQuoteMintNotSolParam) {
    const {
      creator,
      payer,
      feeReceiver,
      pool,
      poolState,
      poolConfigState,
      tokenBaseProgram,
      tokenQuoteProgram
    } = claimWithQuoteMintNotSolParam;
    const {
      ataTokenA: tokenBaseAccount,
      ataTokenB: tokenQuoteAccount,
      instructions: preInstructions
    } = await this.prepareTokenAccounts(
      feeReceiver,
      payer,
      poolState.baseMint,
      poolConfigState.quoteMint,
      tokenBaseProgram,
      tokenQuoteProgram
    );
    const accounts = {
      poolAuthority: this.poolAuthority,
      pool,
      tokenAAccount: tokenBaseAccount,
      tokenBAccount: tokenQuoteAccount,
      baseVault: poolState.baseVault,
      quoteVault: poolState.quoteVault,
      baseMint: poolState.baseMint,
      quoteMint: poolConfigState.quoteMint,
      creator,
      tokenBaseProgram,
      tokenQuoteProgram
    };
    return { accounts, preInstructions };
  }
  /**
   * Claim creator trading fee
   * @param claimCreatorTradingFeeParam - The parameters for the claim creator trading fee
   * @returns A claim creator trading fee transaction
   */
  async claimCreatorTradingFee(claimCreatorTradingFeeParam) {
    const {
      creator,
      pool,
      maxBaseAmount,
      maxQuoteAmount,
      receiver,
      payer,
      tempWSolAcc
    } = claimCreatorTradingFeeParam;
    const poolState = await this.state.getPool(pool);
    if (!poolState) {
      throw new Error(`Pool not found: ${pool.toString()}`);
    }
    const poolConfigState = await this.state.getPoolConfig(poolState.config);
    if (!poolConfigState) {
      throw new Error(`Pool config not found: ${pool.toString()}`);
    }
    const tokenBaseProgram = getTokenProgram(poolConfigState.tokenType);
    const tokenQuoteProgram = getTokenProgram(
      poolConfigState.quoteTokenFlag
    );
    const isSOLQuoteMint = isNativeSol(poolConfigState.quoteMint);
    if (isSOLQuoteMint) {
      const tempWSol = receiver && !receiver.equals(creator) ? tempWSolAcc : creator;
      const feeReceiver = receiver ? receiver : creator;
      const result = await this.claimWithQuoteMintSol({
        creator,
        payer,
        feeReceiver,
        tempWSolAcc: tempWSol,
        pool,
        poolState,
        poolConfigState,
        tokenBaseProgram,
        tokenQuoteProgram
      });
      return this.program.methods.claimCreatorTradingFee(maxBaseAmount, maxQuoteAmount).accountsPartial(result.accounts).preInstructions(result.preInstructions).postInstructions(result.postInstructions).transaction();
    } else {
      const feeReceiver = receiver ? receiver : creator;
      const result = await this.claimWithQuoteMintNotSol({
        creator,
        payer,
        feeReceiver,
        pool,
        poolState,
        poolConfigState,
        tokenBaseProgram,
        tokenQuoteProgram
      });
      return this.program.methods.claimCreatorTradingFee(maxBaseAmount, maxQuoteAmount).accountsPartial(result.accounts).preInstructions(result.preInstructions).postInstructions([]).transaction();
    }
  }
  /**
   * Claim creator trading fee
   * @param claimCreatorTradingFeeParam - The parameters for the claim creator trading fee
   * @returns A claim creator trading fee transaction
   */
  async claimCreatorTradingFee2(claimCreatorTradingFee2Param) {
    const {
      creator,
      pool,
      maxBaseAmount,
      maxQuoteAmount,
      receiver,
      payer
    } = claimCreatorTradingFee2Param;
    const poolState = await this.state.getPool(pool);
    if (!poolState) {
      throw new Error(`Pool not found: ${pool.toString()}`);
    }
    const poolConfigState = await this.state.getPoolConfig(poolState.config);
    if (!poolConfigState) {
      throw new Error(`Pool config not found: ${pool.toString()}`);
    }
    const tokenBaseProgram = getTokenProgram(poolConfigState.tokenType);
    const tokenQuoteProgram = getTokenProgram(
      poolConfigState.quoteTokenFlag
    );
    const isSOLQuoteMint = isNativeSol(poolConfigState.quoteMint);
    if (isSOLQuoteMint) {
      const preInstructions = [];
      const postInstructions = [];
      const tokenBaseAccount = findAssociatedTokenAddress(
        receiver,
        poolState.baseMint,
        tokenBaseProgram
      );
      const tokenQuoteAccount = findAssociatedTokenAddress(
        creator,
        poolConfigState.quoteMint,
        tokenQuoteProgram
      );
      const createTokenBaseAccountIx = createAssociatedTokenAccountIdempotentInstruction4(
        payer,
        tokenBaseAccount,
        receiver,
        poolState.baseMint,
        tokenBaseProgram
      );
      createTokenBaseAccountIx && preInstructions.push(createTokenBaseAccountIx);
      const createTokenQuoteAccountIx = createAssociatedTokenAccountIdempotentInstruction4(
        payer,
        tokenQuoteAccount,
        creator,
        poolConfigState.quoteMint,
        tokenQuoteProgram
      );
      createTokenQuoteAccountIx && preInstructions.push(createTokenQuoteAccountIx);
      const unwrapSolIx = unwrapSOLInstruction(creator, receiver);
      unwrapSolIx && postInstructions.push(unwrapSolIx);
      const accounts = {
        poolAuthority: this.poolAuthority,
        pool,
        tokenAAccount: tokenBaseAccount,
        tokenBAccount: tokenQuoteAccount,
        baseVault: poolState.baseVault,
        quoteVault: poolState.quoteVault,
        baseMint: poolState.baseMint,
        quoteMint: poolConfigState.quoteMint,
        creator,
        tokenBaseProgram,
        tokenQuoteProgram
      };
      return this.program.methods.claimCreatorTradingFee(maxBaseAmount, maxQuoteAmount).accountsPartial(accounts).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
    } else {
      const result = await this.claimWithQuoteMintNotSol({
        creator,
        payer,
        feeReceiver: receiver,
        pool,
        poolState,
        poolConfigState,
        tokenBaseProgram,
        tokenQuoteProgram
      });
      return this.program.methods.claimCreatorTradingFee(maxBaseAmount, maxQuoteAmount).accountsPartial(result.accounts).preInstructions(result.preInstructions).postInstructions([]).transaction();
    }
  }
  /**
   * Withdraw creator surplus
   * @param creatorWithdrawSurplusParam - The parameters for the creator withdraw surplus
   * @returns A creator withdraw surplus transaction
   */
  async creatorWithdrawSurplus(creatorWithdrawSurplusParam) {
    const { creator, virtualPool } = creatorWithdrawSurplusParam;
    const poolState = await this.state.getPool(virtualPool);
    if (!poolState) {
      throw new Error(`Pool not found: ${virtualPool.toString()}`);
    }
    const poolConfigState = await this.state.getPoolConfig(poolState.config);
    if (!poolConfigState) {
      throw new Error(`Pool config not found: ${virtualPool.toString()}`);
    }
    const preInstructions = [];
    const postInstructions = [];
    const tokenQuoteAccount = findAssociatedTokenAddress(
      creator,
      poolConfigState.quoteMint,
      TOKEN_PROGRAM_ID5
    );
    const createQuoteTokenAccountIx = createAssociatedTokenAccountIdempotentInstruction4(
      creator,
      tokenQuoteAccount,
      creator,
      poolConfigState.quoteMint,
      TOKEN_PROGRAM_ID5
    );
    if (createQuoteTokenAccountIx) {
      preInstructions.push(createQuoteTokenAccountIx);
    }
    const isSOLQuoteMint = isNativeSol(poolConfigState.quoteMint);
    if (isSOLQuoteMint) {
      const unwrapIx = unwrapSOLInstruction(creator, creator);
      if (unwrapIx) {
        postInstructions.push(unwrapIx);
      }
    }
    const accounts = {
      poolAuthority: this.poolAuthority,
      config: poolState.config,
      virtualPool,
      tokenQuoteAccount,
      quoteVault: poolState.quoteVault,
      quoteMint: poolConfigState.quoteMint,
      creator,
      tokenQuoteProgram: TOKEN_PROGRAM_ID5
    };
    return this.program.methods.creatorWithdrawSurplus().accountsPartial(accounts).preInstructions(preInstructions).postInstructions(postInstructions).transaction();
  }
  async transferPoolCreator(transferPoolCreatorParams) {
    const { virtualPool, creator, newCreator } = transferPoolCreatorParams;
    const virtualPoolState = await this.state.getPool(virtualPool);
    const migrationMetadata = deriveDammV1MigrationMetadataAddress(virtualPool);
    const transaction = await this.program.methods.transferPoolCreator().accountsPartial({
      virtualPool,
      newCreator,
      config: virtualPoolState.config,
      creator
    }).remainingAccounts([
      {
        isSigner: false,
        isWritable: false,
        pubkey: migrationMetadata
      }
    ]).transaction();
    return transaction;
  }
  async creatorWithdrawMigrationFee(withdrawMigrationFeeParams) {
    const { virtualPool, sender, feePayer } = withdrawMigrationFeeParams;
    const virtualPoolState = await this.state.getPool(virtualPool);
    const configState = await this.state.getPoolConfig(
      virtualPoolState.config
    );
    const { ataPubkey: tokenQuoteAccount, ix: preInstruction } = await getOrCreateATAInstruction(
      this.program.provider.connection,
      configState.quoteMint,
      sender,
      feePayer ?? sender,
      true,
      getTokenProgram(configState.quoteTokenFlag)
    );
    const postInstruction = [];
    if (configState.quoteMint.equals(NATIVE_MINT5)) {
      const unwarpSOLIx = unwrapSOLInstruction(sender, sender);
      unwarpSOLIx && postInstruction.push(unwarpSOLIx);
    }
    const transaction = await this.program.methods.withdrawMigrationFee(1).accountsPartial({
      poolAuthority: this.poolAuthority,
      config: virtualPoolState.config,
      virtualPool,
      tokenQuoteAccount,
      quoteVault: virtualPoolState.quoteVault,
      quoteMint: configState.quoteMint,
      sender,
      tokenQuoteProgram: getTokenProgram(configState.quoteTokenFlag)
    }).preInstructions([preInstruction]).postInstructions(postInstruction).transaction();
    return transaction;
  }
};

// src/client.ts
var DynamicBondingCurveClient = class _DynamicBondingCurveClient {
  constructor(connection, commitment) {
    this.pool = new PoolService(connection, commitment);
    this.partner = new PartnerService(connection, commitment);
    this.creator = new CreatorService(connection, commitment);
    this.migration = new MigrationService(connection, commitment);
    this.state = new StateService(connection, commitment);
    this.commitment = commitment;
    this.connection = connection;
  }
  /**
   * Static method to create a client instance for a specific pool
   * @param connection - The connection to the Solana network
   * @returns A DynamicBondingCurveClient instance
   */
  static create(connection, commitment = "confirmed") {
    return new _DynamicBondingCurveClient(connection, commitment);
  }
};
export {
  ActivationType,
  BASE_ADDRESS,
  BASIS_POINT_MAX,
  BIN_STEP_BPS_DEFAULT,
  BIN_STEP_BPS_U128_DEFAULT,
  BaseFeeMode,
  CollectFeeMode,
  CreatorService,
  DAMM_V1_MIGRATION_FEE_ADDRESS,
  DAMM_V1_PROGRAM_ID,
  DAMM_V2_MIGRATION_FEE_ADDRESS,
  DAMM_V2_PROGRAM_ID,
  DYNAMIC_BONDING_CURVE_PROGRAM_ID,
  DYNAMIC_FEE_DECAY_PERIOD_DEFAULT,
  DYNAMIC_FEE_FILTER_PERIOD_DEFAULT,
  DYNAMIC_FEE_REDUCTION_FACTOR_DEFAULT,
  DynamicBondingCurveClient,
  DynamicBondingCurveProgram,
  FEE_DENOMINATOR,
  GetFeeMode,
  LOCKER_PROGRAM_ID,
  MAX_CREATOR_MIGRATION_FEE_PERCENTAGE,
  MAX_CURVE_POINT,
  MAX_FEE_BPS,
  MAX_FEE_NUMERATOR,
  MAX_MIGRATION_FEE_PERCENTAGE,
  MAX_PRICE_CHANGE_BPS_DEFAULT,
  MAX_RATE_LIMITER_DURATION_IN_SECONDS,
  MAX_RATE_LIMITER_DURATION_IN_SLOTS,
  MAX_SQRT_PRICE,
  MAX_SWALLOW_PERCENTAGE,
  METAPLEX_PROGRAM_ID,
  MIN_FEE_BPS,
  MIN_FEE_NUMERATOR,
  MIN_SQRT_PRICE,
  MigrationFeeOption,
  MigrationOption,
  MigrationService,
  OFFSET,
  ONE_Q64,
  PARTNER_SURPLUS_SHARE,
  PartnerService,
  PoolService,
  RESOLUTION,
  Rounding,
  SLOT_DURATION,
  SWAP_BUFFER_PERCENTAGE,
  TIMESTAMP_DURATION,
  TokenDecimal,
  TokenType,
  TokenUpdateAuthorityOption,
  TradeDirection,
  U64_MAX,
  VAULT_PROGRAM_ID,
  bpsToFeeNumerator,
  buildCurve,
  buildCurveWithLiquidityWeights,
  buildCurveWithMarketCap,
  buildCurveWithTwoSegments,
  calculateFeeSchedulerEndingBaseFeeBps,
  calculateQuoteExactInAmount,
  checkRateLimiterApplied,
  cleanUpTokenAccountTx,
  convertDecimalToBN,
  convertToLamports,
  createDammV1Program,
  createDammV2Program,
  createDbcProgram,
  createInitializePermissionlessDynamicVaultIx,
  createLockEscrowIx,
  createProgramAccountFilter,
  createVaultProgram,
  deriveBaseKeyForLocker,
  deriveDammV1EventAuthority,
  deriveDammV1LockEscrowAddress,
  deriveDammV1LpMintAddress,
  deriveDammV1MigrationMetadataAddress,
  deriveDammV1PoolAddress,
  deriveDammV1PoolAuthority,
  deriveDammV1ProtocolFeeAddress,
  deriveDammV1VaultLPAddress,
  deriveDammV2EventAuthority,
  deriveDammV2LockEscrowAddress,
  deriveDammV2MigrationMetadataAddress,
  deriveDammV2PoolAddress,
  deriveDammV2PoolAuthority,
  deriveDammV2TokenVaultAddress,
  deriveDbcEventAuthority,
  deriveDbcPoolAddress,
  deriveDbcPoolAuthority,
  deriveDbcPoolMetadata,
  deriveDbcTokenVaultAddress,
  deriveEscrow,
  deriveLockerEventAuthority,
  deriveMintMetadata,
  derivePartnerMetadata,
  derivePositionAddress,
  derivePositionNftAccount,
  deriveTokenVaultKey,
  deriveVaultAddress,
  deriveVaultLpMintAddress,
  deriveVaultPdas,
  feeNumeratorToBps,
  findAssociatedTokenAddress,
  fromDecimalToBN,
  getAccountCreationTimestamp,
  getAccountCreationTimestamps,
  getAccountData,
  getBaseFeeNumerator,
  getBaseFeeParams,
  getBaseTokenForSwap,
  getDeltaAmountBase,
  getDeltaAmountBaseUnsigned,
  getDeltaAmountQuoteUnsigned,
  getDynamicFeeParams,
  getFeeMode,
  getFeeNumeratorOnExponentialFeeScheduler,
  getFeeNumeratorOnLinearFeeScheduler,
  getFeeNumeratorOnRateLimiter,
  getFeeOnAmount,
  getFeeSchedulerParams,
  getFirstCurve,
  getFirstKey,
  getInitialLiquidityFromDeltaBase,
  getInitialLiquidityFromDeltaQuote,
  getInitializeAmounts,
  getLiquidity,
  getLockedVestingParams,
  getMigrationBaseToken,
  getMigrationMarketCap,
  getMigrationQuoteAmount,
  getMigrationQuoteAmountFromMigrationQuoteThreshold,
  getMigrationQuoteThresholdFromMigrationQuoteAmount,
  getMigrationThresholdPrice,
  getNextSqrtPriceFromAmountBaseRoundingUp,
  getNextSqrtPriceFromAmountQuoteRoundingDown,
  getNextSqrtPriceFromInput,
  getOrCreateATAInstruction,
  getPercentageSupplyOnMigration,
  getPriceFromSqrtPrice,
  getRateLimiterParams,
  getSecondKey,
  getSqrtPriceFromMarketCap,
  getSqrtPriceFromPrice,
  getSwapAmountFromBaseToQuote,
  getSwapAmountFromQuoteToBase,
  getSwapAmountWithBuffer,
  getSwapResult,
  getTokenDecimals,
  getTokenProgram,
  getTokenType,
  getTotalSupplyFromCurve,
  getTotalTokenSupply,
  getTotalVestingAmount,
  getTwoCurve,
  getVariableFee,
  isDefaultLockedVesting,
  isNativeSol,
  prepareTokenAccountTx,
  swapQuote,
  unwrapSOLInstruction,
  validateActivationType,
  validateBalance,
  validateBaseTokenType,
  validateCollectFeeMode,
  validateConfigParameters,
  validateCurve,
  validateFeeRateLimiter,
  validateFeeScheduler,
  validateLPPercentages,
  validateMigrationAndTokenType,
  validateMigrationFeeOption,
  validatePoolFees,
  validateSwapAmount,
  validateTokenDecimals,
  validateTokenSupply,
  validateTokenUpdateAuthorityOptions,
  wrapSOLInstruction
};
//# sourceMappingURL=index.js.map